<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>懂珠宝的NetW0rker的个人博客</title>
  
  
  <link href="http://dianwoshishi.github.io/atom.xml" rel="self"/>
  
  <link href="http://dianwoshishi.github.io/"/>
  <updated>2021-06-17T01:09:50.974Z</updated>
  <id>http://dianwoshishi.github.io/</id>
  
  <author>
    <name>懂珠宝的NetW0rker</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Watering Hole Attack 水坑攻击</title>
    <link href="http://dianwoshishi.github.io/2021/06/17/Watering%20Hole%20Attack%20%E6%B0%B4%E5%9D%91%E6%94%BB%E5%87%BB/"/>
    <id>http://dianwoshishi.github.io/2021/06/17/Watering%20Hole%20Attack%20%E6%B0%B4%E5%9D%91%E6%94%BB%E5%87%BB/</id>
    <published>2021-06-17T04:00:00.000Z</published>
    <updated>2021-06-17T01:09:50.974Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Watering-Hole-Attack-水坑攻击"><a href="#Watering-Hole-Attack-水坑攻击" class="headerlink" title="Watering Hole Attack 水坑攻击"></a>Watering Hole Attack 水坑攻击</h1><p><img src="https://mlv4zfjisxd7.i.optimole.com/2lVZDuw-V-hqZl6Z/w:auto/h:auto/q:90/https://freelearningtech.in/wp-content/uploads/2020/01/watering-hole-attacks.png"></p><h2 id="什么是水坑攻击"><a href="#什么是水坑攻击" class="headerlink" title="什么是水坑攻击"></a>什么是水坑攻击</h2><p>水坑攻击时一种看似简单但成功率较高的网络攻击方式。攻击目标多为特定的团体（组织、行业、地区等）。攻击者首先通过猜测（或观察）确定这组目标经常访问的网站，然后入侵其中一个或多个网站，植入恶意软件。在目标访问该网站时，会被重定向到恶意网址或触发恶意软件执行，导致该组目标中部分成员甚至全部成员被感染。按照这个思路，水坑攻击其实也可以算是鱼叉式钓鱼的一种延伸。</p><p><img src="https://mk0cybersecuritxhwmn.kinstacdn.com/wp-content/uploads/2020/02/Watering-Hole-Attack.jpg" alt="查看源图像"></p><p><img src="https://blog.authentic8.com/content/images/2019/03/watering-hole-attack-infographic-GoldPhish.jpg" alt="img"></p><p>早在 2012 年，国外就有研究人员提出了“水坑攻击”的概念。这种攻击方式的命名受狮子等猛兽的狩猎方式启发。在捕猎时，狮子并不总是会主动出击，他们有时会埋伏水坑边上，等目标路过水坑停下来喝水的时候，就抓住时机展开攻击。这样的攻击成功率就很高，因为目标总是要到水坑“喝水”的。</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20170823/283a4924a17b4a66a5023a9d7cfd578d.jpeg"></p><h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><p>水坑攻击主要呈现出两个特征：</p><ol><li><p>多属于 APT 攻击，目标多为是大型、重要企业的员工或网站；</p></li><li><p>多利用 0-day 漏洞。</p></li></ol><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>水坑攻击的案例不时会有出现。2012 年底，美国外交关系委员会的网站遭遇水坑攻击；2013 年初，苹果、微软、纽约时报、Facebook、Twitter 等知名大流量网站也相继中招。国内网站也难以幸免：2013 年，西藏政府网站遭遇水坑攻击；2015 年，百度、阿里等国内知名网站也因为 JSONP 漏洞而遭受水坑攻击。</p><h2 id="预防"><a href="#预防" class="headerlink" title="预防"></a>预防</h2><p>针对这类攻击，重要的一点也是对用户进行教育，让他们意识到这类攻击及其危害性，遇到点击链接的要求时越谨慎越好。其次企业组织本身也要提高警惕，采取更高级的手段检测并对抗攻击。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.sohu.com/a/166589989_472906">https://www.sohu.com/a/166589989_472906</a></p>]]></content>
    
    
    <summary type="html">Watering Hole Attack 水坑攻击


什么是水坑攻击
水坑攻击时一种看似简单但成功率较高的网络攻击方式。攻击目标多为特定的团体（组织、行业、地区等）。攻击者首先通过猜测（或观察）确定这组目标经常访问的网站，然后入侵其中一个或多个网站，植入恶意软件。在目标访问该网站时，会被重定向到恶意网址或触发恶意软件执行，导致该组目标中部分成员甚至全部成员被感染。按照这个思路，水坑攻击其实也可以算是鱼叉式钓鱼的一种延伸。





早在 2012 年，国外就有研究人员提出了“水坑攻击”的概念。这种攻击方式的命名受狮子等猛兽的狩猎方式启发。在捕猎时，狮子并不总是会主动出击，他们有时会埋伏水坑边</summary>
    
    
    
    <category term="网络空间" scheme="http://dianwoshishi.github.io/categories/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4/"/>
    
    <category term="网络战" scheme="http://dianwoshishi.github.io/categories/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4/%E7%BD%91%E7%BB%9C%E6%88%98/"/>
    
    
    <category term="网络攻击" scheme="http://dianwoshishi.github.io/tags/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB/"/>
    
  </entry>
  
  <entry>
    <title>以色列网络作战部队之C4i</title>
    <link href="http://dianwoshishi.github.io/2021/06/17/%E4%BB%A5%E8%89%B2%E5%88%97%E7%BD%91%E7%BB%9C%E4%BD%9C%E6%88%98%E9%83%A8%E9%98%9FC4i/"/>
    <id>http://dianwoshishi.github.io/2021/06/17/%E4%BB%A5%E8%89%B2%E5%88%97%E7%BD%91%E7%BB%9C%E4%BD%9C%E6%88%98%E9%83%A8%E9%98%9FC4i/</id>
    <published>2021-06-17T04:00:00.000Z</published>
    <updated>2021-06-17T01:09:26.770Z</updated>
    
    <content type="html"><![CDATA[<h1 id="以色列网络作战部队之C4i"><a href="#以色列网络作战部队之C4i" class="headerlink" title="以色列网络作战部队之C4i"></a>以色列网络作战部队之C4i</h1><p><img src="https://www.idf.il/media/4399/%D7%9C%D7%95%D7%92%D7%95-%D7%97%D7%99%D7%9C-%D7%94%D7%A7%D7%A9%D7%A8-%D7%95%D7%94%D7%AA%D7%A7%D7%A9%D7%95%D7%91.png?anchor=center&mode=crop&width=130&height=130&rnd=131265435960000000"></p><p>“We are everywhere. From the fiber optic to the satellite, from the support base to the most forward operating soldier,” said Col. R, who commands the Code, Cipher, and Security Unit of the C4i Directorate.</p><p>“从光纤到卫星，从支援保障到最前沿的士兵，我们无处不在”——C4i 指挥部编码、密码、安全部门指挥官R上校</p><p><img src="https://image.3001.net/images/20200331/1585660812_5e83438c2d924.jpg" alt="img"></p><p>图片来源:<a href="https://www.freebuf.com/articles/network/232118.html">https://www.freebuf.com/articles/network/232118.html</a></p><h2 id="官网简介"><a href="#官网简介" class="headerlink" title="官网简介"></a>官网简介</h2><blockquote><p>来源：<a href="https://www.idf.il/en/minisites/c4i-and-cyber-defense-directorate/">https://www.idf.il/en/minisites/c4i-and-cyber-defense-directorate/</a></p></blockquote><p>C4i指挥部是IDF的精英技术单位。 C4i指挥部的主要活动是为战场指挥官提供他们需要的技术，以便以尽可能好的方式掌控战场局势。该指挥部的主要目标是发起、发展、开发和加强IDF(以色列国防军)的技术集成系统。C4i首长是少将Lior Carmeli。</p><p>在过去的二十年里，随着技术的进步，指挥部已经成为一个领跑者。它负责以色列国防军在战场上的所有联系、计算机和通信。它还负责IDF的所有网络防御。网络防御部(Cyber Defense Unit)定期举办黑客马拉松（hackathons ），以挑战自我、提高技能。</p><p>该处隶属于参谋长，并与业务处合作工作。</p><h2 id="培训"><a href="#培训" class="headerlink" title="培训"></a>培训</h2><blockquote><p>来源：<a href="https://www.idf.il/en/minisites/training-and-preparation/the-24-hour-hackathon-exercise-of-the-c4i-and-cyber-defense-directorate/">https://www.idf.il/en/minisites/training-and-preparation/the-24-hour-hackathon-exercise-of-the-c4i-and-cyber-defense-directorate/</a></p></blockquote><p>C4I和网络防御局在军官培训学校完成军官课程后，为即将上任的军官设置了一门特殊课程。本课程是专为刚从军官训练学校毕业的首军官而设，内容包括多项训练，以协助他们胜任其岗位</p><h3 id="课程"><a href="#课程" class="headerlink" title="课程"></a>课程</h3><p>新军官在网络防御局的完成来自<strong>计算机软件，电气工程和网络防御</strong>背景的课程。在课程中，他们将学习未来工作的专业知识，并了解技术部门的不同单位。他们也熟悉了理事会的各种计划和项目。</p><p>“结业课程非常具有挑战性和复杂性。归根到底，学员面临的挑战不是理论上的，而是通过完成分配的实际任务获得的经验。们未来所需要的经验是通过各种演习获得的，其中之一就是‘黑客马拉松’。”</p><h3 id="什么是“黑客马拉松”"><a href="#什么是“黑客马拉松”" class="headerlink" title="什么是“黑客马拉松”?"></a>什么是“黑客马拉松”?</h3><p>“黑客马拉松”是课程第9周完成的练习。这种持续24小时的练习，本质上是产品开发和创新的短期“冲刺”。这是一个独特的模拟系统，以帮助培训C4I和网络防御局的新军官。</p><p>“黑客马拉松”的主要目的是让新军官发现问题，并从那里开发新的创造性想法，利用技术提供解决方案。</p><p><img src="https://www.idf.il/media/30803/hackathon.jpeg?width=744&height=496"></p><h3 id="从学员到军官"><a href="#从学员到军官" class="headerlink" title="从学员到军官"></a>从学员到军官</h3><p>完成课程的军官最终会拥有高水平的领导能力和专业技能。课程结束后，他们在网络防御局中担任各种职务，比如项目领导，这意味着他们负责正在进行的项目和编程，这包括编程和开发应用程序、分析等。</p><h2 id="Cyberdome演习"><a href="#Cyberdome演习" class="headerlink" title="Cyberdome演习"></a>Cyberdome演习</h2><blockquote><p>来源：<a href="https://www.israelnationalnews.com/News/News.aspx/271365">https://www.israelnationalnews.com/News/News.aspx/271365</a></p></blockquote><p>C4i &amp; 网络防御局会定期与外国网络防御实体进行演练，以提高部队的能力和战备状态，并加强部队之间的联系，鼓励各机构之间的相互学习。例如2019年11月，其与美国进行名为“Cyberdome”的演习，该演习是C4i和网络防御局与美国司令部正在进行的训练的一部分，有助于两组织之间现有的网络防御战略伙伴关系。</p><p><img src="https://u.a7.org/pictures/926/926268.jpg"></p><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p>解构全球网军之以色列网络作战部队，<a href="https://www.freebuf.com/articles/network/232118.html">https://www.freebuf.com/articles/network/232118.html</a></p><p>The 24-hour “Hackathon” Exercise of the C4I and Cyber Defense Directorate，<a href="https://www.idf.il/en/minisites/training-and-preparation/the-24-hour-hackathon-exercise-of-the-c4i-and-cyber-defense-directorate/">https://www.idf.il/en/minisites/training-and-preparation/the-24-hour-hackathon-exercise-of-the-c4i-and-cyber-defense-directorate/</a></p><p>C4I and Cyber Defense Directorate，<a href="https://www.idf.il/en/minisites/c4i-and-cyber-defense-directorate/">https://www.idf.il/en/minisites/c4i-and-cyber-defense-directorate/</a></p><p>Israeli and US armies conduct cyber battlefield exercise，<a href="https://www.israelnationalnews.com/News/News.aspx/271365">https://www.israelnationalnews.com/News/News.aspx/271365</a></p>]]></content>
    
    
    <summary type="html">以色列网络作战部队之C4i


“We are everywhere. From the fiber optic to the satellite, from the support base to the most forward operating soldier,” said Col. R, who commands the Code, Cipher, and Security Unit of the C4i Directorate.

“从光纤到卫星，从支援保障到最前沿的士兵，我们无处不在”——C4i 指挥部编码、密码、安全部门指挥官R上校



图片来源:https://www.fr</summary>
    
    
    
    <category term="网络空间" scheme="http://dianwoshishi.github.io/categories/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4/"/>
    
    <category term="网络战" scheme="http://dianwoshishi.github.io/categories/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4/%E7%BD%91%E7%BB%9C%E6%88%98/"/>
    
    
    <category term="网络攻击" scheme="http://dianwoshishi.github.io/tags/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB/"/>
    
  </entry>
  
  <entry>
    <title>颠覆传统网络安全结构--Zero Trust</title>
    <link href="http://dianwoshishi.github.io/2021/06/13/%E9%9B%B6%E4%BF%A1%E4%BB%BB/"/>
    <id>http://dianwoshishi.github.io/2021/06/13/%E9%9B%B6%E4%BF%A1%E4%BB%BB/</id>
    <published>2021-06-13T04:00:00.000Z</published>
    <updated>2021-06-17T09:54:09.474Z</updated>
    
    <content type="html"><![CDATA[<h1 id="颠覆传统网络安全结构–Zero-Trust"><a href="#颠覆传统网络安全结构–Zero-Trust" class="headerlink" title="颠覆传统网络安全结构–Zero Trust"></a>颠覆传统网络安全结构–Zero Trust</h1><p>《林海雪原》中，侠客般的杨子荣靠着“黑话”/“暗号”，赢得了土匪头子“座山雕”的信任，成功打入土匪内部，智取了威虎山。</p><p>假如将这一场景类比于网络，它与早期的网络攻击何其相似。</p><p>传统的网络安全中，用户与系统之间依靠防火墙隔离，用户只需完成如“盖地虎，镇河妖”的“暗号”就可访问系统内部整个网络区域，使网络存在非常大的安全隐患。随着企业业务复杂性的增加、黑客的“进化”以及网络虚拟化等技术的发展，安全防御方式也在进一步提升，“盖地虎，镇河妖”式“暗号”已不能支撑整个网络安全系统.[8]</p><p>为了解决这个问题，零信任模型被提出，一些大的机构也提出了自己的零信任体系，如NIST[6],NSA[7],奇安信[5]等。可以看出，零信任模型作为一种颠覆性的安全结构设计，已经逐渐得到人们的认可。下面我们就简要的介绍一下零信任的相关知识。</p><h2 id="传统的网络安全结构"><a href="#传统的网络安全结构" class="headerlink" title="传统的网络安全结构"></a>传统的网络安全结构</h2><p>传统的网络安全结构把不同的网络（或者单个网络的一部分）划分为不同的区域，不同区域之间使用防火墙进行隔离。每个区域都被授予某种程度的信任，它决定了哪些网络资源允许被访问。这种安全模型提供了非常强大的纵深防御能力。比如，互联网可访问的Web服务器等高风险的网络资源，被部署在特定的区域（一般称为“隔离区”, DMZ），该区域的网络流量被严密监控和严格控制。这是一种常见的网络安全架构。</p><p><img src="/2021/06/13/%E9%9B%B6%E4%BF%A1%E4%BB%BB/image-20210617162619409.png" alt="传统的网络安全架构"></p><p>这种保护机制可以称为，<strong>城堡护城河式保护</strong>：传统的基于边界的网络安全方法是<strong>先连接，后信任</strong>，在网络边界验证用户身份，确定用户是否值得信任。如果用户被认定为是可信任的，就能进入网络，而一旦通过边界进入到网络内部，访问基本就通行无阻了。</p><p>传统的安全模型主要有以下缺点。</p><ul><li>缺乏网络内部的流量检查。</li><li>主机部署缺乏物理及逻辑上的灵活性。</li><li>存在单点故障</li></ul><h3 id="以横向移动举例说明传统的网络安全结构的问题"><a href="#以横向移动举例说明传统的网络安全结构的问题" class="headerlink" title="以横向移动举例说明传统的网络安全结构的问题"></a>以横向移动举例说明传统的网络安全结构的问题</h3><p><img src="/2021/06/13/%E9%9B%B6%E4%BF%A1%E4%BB%BB/image-20210617163038490.png" alt="攻击者在办公网络中横向移动，最终进入生产网络"></p><p>① 通过钓鱼邮件锁定企业的员工。</p><p>② 攻陷办公网的员工计算机，获得Shell。</p><p>③ 在办公网络中横向移动。</p><p>④ 定位拥有特权的计算机。</p><p>⑤ 安装键盘记录器的特权计算机本地提权。</p><p>⑥ 窃取开发人员的口令。</p><p>⑦ 从特权计算机攻击生产应用主机。</p><p>⑧ 利用开发人员口令在生产应用主机上提升权限。</p><p>⑨ 从应用程序中窃取数据库口令。</p><p>⑩ 通过失陷的应用主机外泄数据库中的数据。</p><blockquote><p>横向移动（Lateral Movement）就是当攻击者获得了某台内网机器的控制权限后，会以被攻陷的主机为跳板，继续访问或控制其他内网机器的过程.</p><p><img src="https://alln-extcloud-storage.cisco.com/ciscoblogs/lateral-movement.jpg" alt="查看源图像"></p></blockquote><p>在上述过程中，一旦攻击者获取了内网的某台主机的访问控制权限，又由于现有防御策略对内网控制不那么强， 攻击者可以通过一些系列操作，实现内网的横向移动，最终控制整个内部网络。</p><p>如何解决这个问题呢？首先问题的关键是<strong>信任</strong>出了问题。传统网络安全结构，对内网中的用户具有一定的默认权限，即默认信任内网用户。因此尽可能减少信任是更明智的做法。</p><h2 id="零信任架构"><a href="#零信任架构" class="headerlink" title="零信任架构"></a>零信任架构</h2><p>一种解决上述粗粒度的访问控制的方式是进行更加细粒度的访问控制，即分段安全。分段安全用物理安全设备分割网络可以实现更强的违规控制。但此种方法成本昂贵</p><h3 id="分段安全的缺陷"><a href="#分段安全的缺陷" class="headerlink" title="分段安全的缺陷"></a>分段安全的缺陷</h3><p><img src="/2021/06/13/%E9%9B%B6%E4%BF%A1%E4%BB%BB/image-20210617164143293.png" alt="image-20210617164143293"></p><ul><li><p>传统的周边安全缺乏必要的控制来限制攻击和恶意软件在周边的移动(上图左)。</p></li><li><p>用物理安全设备分割网络可以实现更强的违规控制，但会迅速增加成本并产生变更管理挑战，特别是在工作负载变得可移动的情况下(上图右)。</p></li></ul><h3 id="解决方案：零信任"><a href="#解决方案：零信任" class="headerlink" title="解决方案：零信任"></a>解决方案：零信任</h3><p>零信任网络模型在2010年由John Kindervag提出，后来Gartner和Forrester由对零信任概念、应用场景、迁移方式进行了完善和补充。</p><p>零信任架构的做法是先信任，后连接，意味着每个用户、设备、服务或应用程序都是不可信任的，必须经历身份和访问管理过程才能获得最低级别的信任和关联访问特权。零信任模型不信任任何人，所有对数据和服务(统称为资源)的访问都需要授权,这是和传统网络安全方法的主要区别。</p><p>《零信任网络：在不可信网络中构建安全系统》[3]对零信任安全进行了抽象：</p><ul><li><p>网络无时无刻不处于危险的环境中</p></li><li><p>网络中自始至终存在外部或内部威胁</p></li><li><p>网络位置不足以决定网络的可信程度</p></li><li><p>所有的设备、用户和网络流量都应当经过认证和授权</p></li><li><p>安全策略必须是动态的，并基于尽可能多的数据源计算而来。</p></li></ul><h3 id="基于零信任的网络安全架构"><a href="#基于零信任的网络安全架构" class="headerlink" title="基于零信任的网络安全架构"></a>基于零信任的网络安全架构</h3><p>利用分布式策略实施和应用零信任原则，可以构建如下图所示的网络安全架构</p><p><img src="/2021/06/13/%E9%9B%B6%E4%BF%A1%E4%BB%BB/image-20210617162810842.png" alt="零信任架构"></p><p>其中，零信任架构的支撑系统称为控制平面，其他部分称为数据平面，数据平面由控制平面指挥和配置。</p><h3 id="零信任的数据平面和控制平面"><a href="#零信任的数据平面和控制平面" class="headerlink" title="零信任的数据平面和控制平面"></a>零信任的数据平面和控制平面</h3><ul><li><p>数据平面。零信任网络中的数据平面由直接处理网络流量的应用程序、防火墙、代理服务器和路由器组成。</p></li><li><p>控制平面。零信任网络中的控制平面由一系列组件构成，这些组件接收并处理来自数据平面的请求，这些请求或者是希望访问网络资源，或者是授予网络资源的访问权限。访问受保护资源的请求首先经过控制平面处理，包括设备和用户的身份认证与授权。细粒度的控制策略也在这一层进行，控制平面可以基于组织中的角色、时间或设备类型进行授权。一旦控制平面完成检查，确定该请求具备合法的授权，它就会动态配置数据平面，接收来自该客户端（且仅限该客户端）的访问流量。此外，控制平面还能够为访问请求者和被访问的资源协调配置加密隧道的具体参数，包括一次性的临时凭证、密钥和临时端口号等。</p><p><img src="/2021/06/13/%E9%9B%B6%E4%BF%A1%E4%BB%BB/image-20210617165425098.png" alt="零信任客户端与控制平面进行交互以访问服务资源"></p></li></ul><h2 id="奇安信零信任安全白皮书"><a href="#奇安信零信任安全白皮书" class="headerlink" title="奇安信零信任安全白皮书"></a>奇安信零信任安全白皮书</h2><h3 id="零信任架构的关键能力模型"><a href="#零信任架构的关键能力模型" class="headerlink" title="零信任架构的关键能力模型"></a>零信任架构的关键能力模型</h3><p>零信任架构的本质是以身份为基石的动态可信访问控制，聚焦身份、信任、业务访问和动态访问控制等维度的安全能力，基于业务场景的人、流程、环境、访问上下文等多维的因素，对信任进行持续评估，并通过信任等级对权限进行动态调整，形成具备较强风险应对能力的动态自适应的安全闭环体系。</p><p><img src="/2021/06/13/%E9%9B%B6%E4%BF%A1%E4%BB%BB/image-20210617170017904.png" alt="image-20210617170017904"></p><h3 id="零信任架构核心逻辑架构组件"><a href="#零信任架构核心逻辑架构组件" class="headerlink" title="零信任架构核心逻辑架构组件"></a>零信任架构核心逻辑架构组件</h3><ul><li><p>可信代理是零信任架构的数据平面组件，是确保业务安全访问的第一道关口，是动态访问控制能力的策略执行点</p></li><li><p>动态访问控制引擎和可信代理联动，对所有访问请求进行认证和动态授权，是零信任架构控制平面的策略判定点</p></li><li><p>信任评估引擎是是零信任架构中实现持续信任评估能力的核心组件，和动态访问控制引擎联动，为其提供信任等级评估作为授权判定依据。信任评估引擎持续接收可信代理、动态访问控制引擎的日志信息，结合身份库、权限库数据，基于大数据和人工智能技术，对身份进行持续画像，对访问行为进行持续分析，对信任进行持续评估，最终生成和维护信任库，为动态访问控制引擎提供决策依据。</p></li><li><p>身份基础设施至少包含身份管理和权限管理功能组件，通过身份管理实现各种实体的身份化及身份生命周期管理，通过权限管理，对授权策略进行细粒度的管理和跟踪分析。</p></li></ul><p><img src="/2021/06/13/%E9%9B%B6%E4%BF%A1%E4%BB%BB/image-20210617170113622.png" alt="零信任架构核心逻辑架构组件"></p><h2 id="零信任案例"><a href="#零信任案例" class="headerlink" title="零信任案例"></a>零信任案例</h2><p><img src="/2021/06/13/%E9%9B%B6%E4%BF%A1%E4%BB%BB/image-20210617171531839.png" alt="image-20210617171531839"></p><p>在这个例子中[7]，一个恶意的网络行为者通过一个基于互联网的移动代码漏洞损害了用户的设备。或者，该行为者是一个有恶意的内部授权用户。在一个典型的、非零信任的情况下，行为者使用用户的证书，列举网络，提升权限，并通过网络横向移动，破坏大量的数据存储，并最终实现持久化控制。</p><p>在 “零信任 “网络中，被破坏的用户的证书和设备已经被认为是恶意的，而且网络被分割，限制了枚举和横向移动的机会。虽然恶意行为者可以同时以用户和设备的身份进行认证，但对数据的访问将根据安全策略、用户角色以及用户和设备属性进行限制。在一个成熟的零信任环境中，即使用户被允许访问，数据加密和数字权利管理也可以提供额外的保护，限制哪些数据可以被访问，可以对敏感数据采取的行动。此外，还将持续监测账户、设备、网络活动和数据访问的异常活动。虽然在这种情况下仍会发生一定程度的损害，但损害是有限的，防御系统检测和启动适当的缓解反应的时间也大大减少。</p><h2 id="零信任和传统安全结构的区别"><a href="#零信任和传统安全结构的区别" class="headerlink" title="零信任和传统安全结构的区别"></a>零信任和传统安全结构的区别</h2><p>边界安全模型与零信任模型存在根本上的差别。边界安全模型试图在可信资源和不可信资源（本地网络和互联网）之间建一堵墙，而零信任模型则“认输”了，它接受“坏人”无处不在的现实。零信任模型不是依靠建造城墙来保护墙内柔弱的身体，而是让全体民众都拥有了自保的能力。</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ol><li>构建零信任网络并不需要太多新的技术，而是采用全新的方式使用现有技术。</li><li>零信任模型颠覆了传统网络安全模型，不信任任何人是零信任的核心。</li><li>零信任的核心是计算，这肯定会增加设备的负载；同时动态的信任评估也需要相互之间的协作。零信任之路，仍在路上。</li></ol><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p>[1]零信任（Zero Trust）简介， <a href="https://blog.csdn.net/baidu_41700102/article/details/104314323">https://blog.csdn.net/baidu_41700102/article/details/104314323</a></p><p>[2]What Is Zero Trust Security?<a href="https://www.mcafee.com/enterprise/zh-cn/security-awareness/cloud/what-is-zero-trust.html">https://www.mcafee.com/enterprise/zh-cn/security-awareness/cloud/what-is-zero-trust.html</a></p><p>[3]零信任网络：在不可信网络中构建安全系统,【美】埃文·吉尔曼（Evan Gilman），道格·巴斯（Doug Barth）,人民邮电出版社</p><p>[4]国内首份零信任安全白皮书：全面解读零信任安全架构， <a href="https://www.secrss.com/articles/18624">https://www.secrss.com/articles/18624</a></p><p>[5]Zero Trust Architecture and Solutions, <a href="https://www.gartner.com/teamsiteanalytics/servePDF?g=/imagesrv/media-products/pdf/Qi-An-Xin/Qi-An-Xin-1-1OKONUN2.pdf">https://www.gartner.com/teamsiteanalytics/servePDF?g=/imagesrv/media-products/pdf/Qi-An-Xin/Qi-An-Xin-1-1OKONUN2.pdf</a></p><p>[6]Rose, S. , Borchert, O. , Mitchell, S. and Connelly, S. (2020), Zero Trust Architecture, Special Publication (NIST SP), National Institute of Standards and Technology, Gaithersburg, MD, [online], <a href="https://doi.org/10.6028/NIST.SP.800-207">https://doi.org/10.6028/NIST.SP.800-207</a>, <a href="https://tsapps.nist.gov/publication/get_pdf.cfm?pub_id=930420">https://tsapps.nist.gov/publication/get_pdf.cfm?pub_id=930420</a> (Accessed June 16, 2021)</p><p>[7]Embracing a Zero Trust Security Model, <a href="https://media.defense.gov/2021/Feb/25/2002588479/-1/-1/0/CSI_EMBRACING_ZT_SECURITY_MODEL_UOO115131-21.PDF">https://media.defense.gov/2021/Feb/25/2002588479/-1/-1/0/CSI_EMBRACING_ZT_SECURITY_MODEL_UOO115131-21.PDF</a></p><p>[8]如果土匪都懂“零信任网络”，杨子荣还能智取威虎山吗？,<a href="https://cloud.tencent.com/developer/article/1429187">https://cloud.tencent.com/developer/article/1429187</a></p>]]></content>
    
    
    <summary type="html">颠覆传统网络安全结构–Zero Trust
《林海雪原》中，侠客般的杨子荣靠着“黑话”/“暗号”，赢得了土匪头子“座山雕”的信任，成功打入土匪内部，智取了威虎山。

假如将这一场景类比于网络，它与早期的网络攻击何其相似。

传统的网络安全中，用户与系统之间依靠防火墙隔离，用户只需完成如“盖地虎，镇河妖”的“暗号”就可访问系统内部整个网络区域，使网络存在非常大的安全隐患。随着企业业务复杂性的增加、黑客的“进化”以及网络虚拟化等技术的发展，安全防御方式也在进一步提升，“盖地虎，镇河妖”式“暗号”已不能支撑整个网络安全系统.[8]

为了解决这个问题，零信任模型被提出，一些大的机构也提出了自己的零信</summary>
    
    
    
    <category term="网络空间" scheme="http://dianwoshishi.github.io/categories/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4/"/>
    
    
    <category term="网络安全" scheme="http://dianwoshishi.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>（转载）来网络空间钓鱼吧</title>
    <link href="http://dianwoshishi.github.io/2021/06/12/%E6%9D%A5%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E9%92%93%E9%B1%BC%E5%90%A7/"/>
    <id>http://dianwoshishi.github.io/2021/06/12/%E6%9D%A5%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E9%92%93%E9%B1%BC%E5%90%A7/</id>
    <published>2021-06-12T04:00:00.000Z</published>
    <updated>2021-06-17T01:10:12.366Z</updated>
    
    <content type="html"><![CDATA[<h1 id="（转载）来网络空间钓鱼吧"><a href="#（转载）来网络空间钓鱼吧" class="headerlink" title="（转载）来网络空间钓鱼吧"></a>（转载）来网络空间钓鱼吧</h1><p><img src="https://img.php.cn/upload/article/000/000/024/5c2dbc0a34396146.jpg"></p><h2 id="什么是网络钓鱼？"><a href="#什么是网络钓鱼？" class="headerlink" title="什么是网络钓鱼？"></a>什么是网络钓鱼？</h2><p>网络钓鱼是一种尝试使用欺骗性电子邮件和网站收集个人信息的攻击方式。攻击者会伪装成信誉良好的实体或个人通过电子邮件或其他通信渠道，使用网络钓鱼电子邮件分发可执行各种功能的恶意链接或附件，从受害者中提取登录凭据或帐户信息；或者自动下载恶意软件，让受害者使用恶意软件感染自己的计算机。</p><p><img src="https://tse4-mm.cn.bing.net/th/id/OIP.7PzuDJygEAmoeVP7YAWqZgHaDx?pid=ImgDet&rs=1"></p><h2 id="网络钓鱼的类型"><a href="#网络钓鱼的类型" class="headerlink" title="网络钓鱼的类型"></a>网络钓鱼的类型</h2><p>网络钓鱼很猖獗，这使得它很危险。模拟网站与真实网站普通人无法区分，黑客们正在寻找方法来克服日益复杂的垃圾邮件过滤。除了电子邮件和网站钓鱼之外，还有“vishing”（语音网络钓鱼），“smishing”（短信网络钓鱼）和网络犯罪分子不断提出的其他几种网络钓鱼技术。 下面我们来看看常见的网络钓鱼攻击类型。</p><h3 id="1、鱼叉式网络钓鱼攻击"><a href="#1、鱼叉式网络钓鱼攻击" class="headerlink" title="1、鱼叉式网络钓鱼攻击"></a>1、鱼叉式网络钓鱼攻击</h3><p>这是一种个人触摸的大量网络钓鱼。发件人将使用可用信息看似合法。此类别中最常见的伪装是银行，攻击可以发送您的姓名，地址等。</p><p>它针对特定的个人或公司，通常是用来收集的受害者特定信息，以更成功地将该信息表示为真实信息。鱼叉式网络钓鱼电子邮件可能包括对受害者组织的同事或管理人员的引用，以及受害者姓名，地点或其他个人信息的使用。</p><p><img src="https://inews.gtimg.com/newsapp_bt/0/10449960979/1000"></p><h3 id="2、捕鲸攻击（行政网络钓鱼）"><a href="#2、捕鲸攻击（行政网络钓鱼）" class="headerlink" title="2、捕鲸攻击（行政网络钓鱼）"></a>2、捕鲸攻击（行政网络钓鱼）</h3><p>这是一种专门针对组织内的高级管理人员的钓鱼攻击，通常是为了窃取大笔资金。</p><p>典型的捕鲸攻击针对的是能够授权付款的员工，网络钓鱼消息似乎是来自管理人员的命令，用于向供应商授予大额付款，而实际上是向攻击者付款。</p><h3 id="3、克隆网络钓鱼"><a href="#3、克隆网络钓鱼" class="headerlink" title="3、克隆网络钓鱼"></a>3、克隆网络钓鱼</h3><p>它会收集先前已发送的电子邮件并复制其内容，将任何合法链接替换为恶意链接。然后使用欺骗帐户将电子邮件发送给原始电子邮件的收件人。基本上，攻击者克隆了合法的电子邮件。</p><p>大多数克隆网络钓鱼的目标是感染目标计算机上的病毒，恶意软件传播到分支机器网络。随着链接的消失，更多用户被感染，然后发送更多受感染的链接。</p><h3 id="4、域欺骗"><a href="#4、域欺骗" class="headerlink" title="4、域欺骗"></a>4、域欺骗</h3><p>它是一种新的网络钓鱼形式，依赖于DNS缓存污染，将用户从合法站点重定向到欺诈站点，并欺骗用户使用他们的登录凭据尝试登录欺诈站点。</p><h3 id="5、语音网络钓鱼"><a href="#5、语音网络钓鱼" class="headerlink" title="5、语音网络钓鱼"></a>5、语音网络钓鱼</h3><p>它也称为vishing，是一种通过语音通信媒体发生的网络钓鱼形式，包括IP语音（VoIP）或POTS（普通老式电话服务）。犯罪者会使用语音合成软件留下声称通知受害者银行或信用账户中的可疑活动的语音邮件，并请求受害者回复恶意电话号码以验证他的身份 - 从而危及受害者的账户凭证。</p><h3 id="6、短信网络钓鱼"><a href="#6、短信网络钓鱼" class="headerlink" title="6、短信网络钓鱼"></a>6、短信网络钓鱼</h3><p>它也称为SMishing或SMShing，犯罪者会使用短信来说服受害者披露帐户凭据或安装恶意软件。</p><h2 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h2><p><a href="https://www.php.cn/windows-414137.html">https://www.php.cn/windows-414137.html</a></p>]]></content>
    
    
    <summary type="html">（转载）来网络空间钓鱼吧


什么是网络钓鱼？
网络钓鱼是一种尝试使用欺骗性电子邮件和网站收集个人信息的攻击方式。攻击者会伪装成信誉良好的实体或个人通过电子邮件或其他通信渠道，使用网络钓鱼电子邮件分发可执行各种功能的恶意链接或附件，从受害者中提取登录凭据或帐户信息；或者自动下载恶意软件，让受害者使用恶意软件感染自己的计算机。



网络钓鱼的类型
网络钓鱼很猖獗，这使得它很危险。模拟网站与真实网站普通人无法区分，黑客们正在寻找方法来克服日益复杂的垃圾邮件过滤。除了电子邮件和网站钓鱼之外，还有“vishing”（语音网络钓鱼），“smishing”（短信网络钓鱼）和网络犯罪分子不断提出的其他几种</summary>
    
    
    
    <category term="网络空间" scheme="http://dianwoshishi.github.io/categories/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4/"/>
    
    <category term="网络战" scheme="http://dianwoshishi.github.io/categories/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4/%E7%BD%91%E7%BB%9C%E6%88%98/"/>
    
    
    <category term="网络攻击" scheme="http://dianwoshishi.github.io/tags/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB/"/>
    
  </entry>
  
  <entry>
    <title>(转载)Cyber-Kill-Chain-网络杀伤链</title>
    <link href="http://dianwoshishi.github.io/2021/06/08/Cyber-Kill-Chain-%E7%BD%91%E7%BB%9C%E6%9D%80%E4%BC%A4%E9%93%BE/"/>
    <id>http://dianwoshishi.github.io/2021/06/08/Cyber-Kill-Chain-%E7%BD%91%E7%BB%9C%E6%9D%80%E4%BC%A4%E9%93%BE/</id>
    <published>2021-06-08T04:00:00.000Z</published>
    <updated>2021-06-07T03:11:42.568Z</updated>
    
    <content type="html"><![CDATA[<h1 id="转载-Cyber-Kill-Chain-网络杀伤链"><a href="#转载-Cyber-Kill-Chain-网络杀伤链" class="headerlink" title="(转载)Cyber-Kill-Chain-网络杀伤链"></a>(转载)Cyber-Kill-Chain-网络杀伤链</h1><h2 id="网络杀伤链"><a href="#网络杀伤链" class="headerlink" title="网络杀伤链"></a>网络杀伤链</h2><p>“网络杀伤链”，是美国国防承包商洛克希德·马丁公司（Lockheed Martin）提出的网络安全威胁的杀伤链模型[2]（普遍适用的网络攻击流程与防御概念，参考军事上的杀伤链(Kill Chain)概念）。</p><blockquote><p>杀伤链源自军事领域，它是一个描述攻击环节的模型，理论上也可以用来预防此类攻击（即反杀伤链）。杀伤链共有发现-定位-跟踪-瞄准-打击-达成目标六个环节，每一环节都是对攻击做出侦测和反应的机会。</p></blockquote><p>内容包括成功的网络攻击所需的七个阶段：侦察跟踪、武器构建、载荷投递、漏洞利用、安装植入、命令与控制、目标达成。</p><p><img src="https://img2020.cnblogs.com/blog/1073473/202008/1073473-20200827125455160-2135375247.png"></p><h2 id="针对网络杀伤链的防御对策"><a href="#针对网络杀伤链的防御对策" class="headerlink" title="针对网络杀伤链的防御对策"></a>针对网络杀伤链的防御对策</h2><p>洛克希德·马丁公司在2015年发布的白皮书中提出预防措施，以降低上述每个阶段的影响程度。</p><h3 id="1、侦察跟踪"><a href="#1、侦察跟踪" class="headerlink" title="1、侦察跟踪"></a>1、侦察跟踪</h3><p>　　描述：攻击者进行探测、识别及确定攻击对象（目标）的阶段。信息一般通过互联网进行收集（内容包括网站、邮箱、电话、社会工程学等一切可能相关的情报）</p><p>　　预防：侦察跟踪阶段往往是防守方感知比较少的阶段；应关注于日常异常流量、日志和数据（特别是已经泄露的数据），将其存储备查是必要的，更重要的是建立和优化分析模型。</p><h3 id="2、武器构建"><a href="#2、武器构建" class="headerlink" title="2、武器构建"></a>2、武器构建</h3><p>　　描述：攻击者通过侦察跟踪阶段确定目标、收集足够的信息后，准备网络武器的阶段。网络武器一般由攻击者直接构建或使用自动化工具构建等。</p><p>　　预防：武器构建行为本身对于防守方来说几乎无感知，但又与防守方的“资源”密切相关，武器的构建需要基于“资源”的漏洞或缺陷（包括操作系统、应用软件、甚至社会工程）；应关注“资产”相关漏洞、补丁、修复流程是否完备。</p><h3 id="3、载荷投递"><a href="#3、载荷投递" class="headerlink" title="3、载荷投递"></a>3、载荷投递</h3><p>　　描述：攻击者将构建完成的网络武器向目标投递的阶段。投递方式一般包括钓鱼邮件、物理USB投递等。</p><p>　　预防：防护策略在该阶段尤为重要，云防护、边界防护、区域防护、系统防护、应用防护等，应关注是否具备且有效防护措施，另外安全意识也同样重要，人的弱点往往比设备的弱点更容易被利用。</p><h3 id="4、漏洞利用"><a href="#4、漏洞利用" class="headerlink" title="4、漏洞利用"></a>4、漏洞利用</h3><p>　　描述：攻击者将网络武器投递到目标系统后，启动恶意代码的阶段。一般会利用应用程序或操作系统的漏洞或缺陷等。</p><p>　　预防：安全检测、安全监测、阻断+审计，这就是日常的安全监控工作（看大门的工作，重要！）</p><h3 id="5、安装植入"><a href="#5、安装植入" class="headerlink" title="5、安装植入"></a>5、安装植入</h3><p>　　描述：攻击者在目标系统设置木马、后门等，一定期限内在目标系统营造活动环境的阶段。</p><p>　　预防：在最短的时间内发现并隔离，关注终端/服务器安全管理策略、防病毒。</p><h3 id="6、命令与控制"><a href="#6、命令与控制" class="headerlink" title="6、命令与控制"></a>6、命令与控制</h3><p>　　描述：攻击者建立目标系统攻击路径的阶段。一般使用自动和手工相结合的方式进行，一旦攻击路径确立后，攻击者将能够控制目标系统。</p><p>　　预防：洛克希德·马丁公司描述此阶段为“防御者阻止攻击的最后机会……如果对手无法发出命令，防御者便可控制影响”，此阶段正是考验响应策略的最后一次尝试，所以更应关注访问控制。</p><h3 id="7、目标达成"><a href="#7、目标达成" class="headerlink" title="7、目标达成"></a>7、目标达成</h3><p>　　描述：攻击者达到预期目标的阶段。攻击目标呈现多样化，可能包括侦察、敏感信息收集、数据破坏、系统摧毁等。</p><p>　　预防：虽然木已成舟，但仍需要集中精力把损失降低到最小，吸取教训、改进措施，才能避免在同一个地方摔倒两次。</p><p><img src="https://img2020.cnblogs.com/blog/1073473/202008/1073473-20200827121907246-1035985227.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>现阶段大部分的攻击者可能都在遵循上述的步骤， 但APT（高级可持续攻击）趋势正在迅速增长，甚至未知威胁，所以防御对策也必须要不断的更新迭代来应对这潜移默化的威胁。</p><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p>[1] 原文，Cyber-Kill-Chain-网络杀伤链，<a href="https://www.cnblogs.com/Michael-Scofields/p/13570827.html">https://www.cnblogs.com/Michael-Scofields/p/13570827.html</a></p><p>[2] Intelligence-Driven Computer Network Defense Informed by Analysis of Adversary Campaigns and Intrusion Kill Chains, <a href="https://www.lockheedmartin.com/content/dam/lockheed-martin/rms/documents/cyber/LM-White-Paper-Intel-Driven-Defense.pdf">https://www.lockheedmartin.com/content/dam/lockheed-martin/rms/documents/cyber/LM-White-Paper-Intel-Driven-Defense.pdf</a></p>]]></content>
    
    
    <summary type="html">(转载)Cyber-Kill-Chain-网络杀伤链
网络杀伤链
“网络杀伤链”，是美国国防承包商洛克希德·马丁公司（Lockheed Martin）提出的网络安全威胁的杀伤链模型[2]（普遍适用的网络攻击流程与防御概念，参考军事上的杀伤链(Kill Chain)概念）。

杀伤链源自军事领域，它是一个描述攻击环节的模型，理论上也可以用来预防此类攻击（即反杀伤链）。杀伤链共有发现-定位-跟踪-瞄准-打击-达成目标六个环节，每一环节都是对攻击做出侦测和反应的机会。

内容包括成功的网络攻击所需的七个阶段：侦察跟踪、武器构建、载荷投递、漏洞利用、安装植入、命令与控制、目标达成。



针对网络杀伤</summary>
    
    
    
    <category term="网络空间" scheme="http://dianwoshishi.github.io/categories/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4/"/>
    
    <category term="网络战" scheme="http://dianwoshishi.github.io/categories/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4/%E7%BD%91%E7%BB%9C%E6%88%98/"/>
    
    
    <category term="网络攻击" scheme="http://dianwoshishi.github.io/tags/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB/"/>
    
  </entry>
  
  <entry>
    <title>俄罗斯-格鲁吉亚网络冲突事件</title>
    <link href="http://dianwoshishi.github.io/2021/06/06/2008%E4%BF%84%E7%BD%97%E6%96%AF-%E6%A0%BC%E9%B2%81%E5%90%89%E4%BA%9A%E7%BD%91%E7%BB%9C%E5%86%B2%E7%AA%81%E4%BA%8B%E4%BB%B6/"/>
    <id>http://dianwoshishi.github.io/2021/06/06/2008%E4%BF%84%E7%BD%97%E6%96%AF-%E6%A0%BC%E9%B2%81%E5%90%89%E4%BA%9A%E7%BD%91%E7%BB%9C%E5%86%B2%E7%AA%81%E4%BA%8B%E4%BB%B6/</id>
    <published>2021-06-06T04:00:00.000Z</published>
    <updated>2021-06-06T02:17:49.932Z</updated>
    
    <content type="html"><![CDATA[<h1 id="俄罗斯-格鲁吉亚网络冲突事件"><a href="#俄罗斯-格鲁吉亚网络冲突事件" class="headerlink" title="俄罗斯-格鲁吉亚网络冲突事件"></a>俄罗斯-格鲁吉亚网络冲突事件</h1><p>“正如你所看到的，看似平静的世界，硝烟弥漫。” ——点我试试</p><h2 id="事件简介"><a href="#事件简介" class="headerlink" title="事件简介"></a>事件简介</h2><p>2008 年 8 月，为了把格鲁吉亚从南奥塞梯驱逐出去，俄罗斯军队进攻格鲁吉亚。此次军事行动开展的同时，也伴随了大量经过协调的网络攻击行动。这是第一次与大规模地面作战行动配合的大规模网络攻击，对格鲁吉亚展开了全面的“蜂群”式网络阻瘫攻击，致使格方电视媒体、金融和交通等重要系统瘫痪，机场、物流和通信等信息网络崩溃，急需的战争物资无法及时运达指定位置，战争潜力被严重削弱，直接影响了格鲁吉亚的社会秩序以及军队的作战指挥和调度。</p><h2 id="网络攻击阶段"><a href="#网络攻击阶段" class="headerlink" title="网络攻击阶段"></a>网络攻击阶段</h2><p>一位安全专家将俄罗斯对格鲁吉亚的网络攻击分为两个阶段。</p><h3 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h3><p>在第一阶段中，俄罗斯黑客发起的攻击类型主要是<strong>分布式拒绝服务（DDoS）攻击</strong>。</p><p><img src="https://vinsep.com/wp-content/uploads/2020/12/What-is-a-DDoS-attack.png"></p><p>此阶段的DDoS主要通过<strong>僵尸网络</strong>开展。</p><p><img src="https://tse1-mm.cn.bing.net/th/id/OIP.IoiJwYnib7wq7fFUU6gOowHaFO?pid=ImgDet&rs=1">俄罗斯商业网络（Russian Business Network ，RBN)这类犯罪组织出于各种目的使用并租赁僵尸网络。攻击格鲁吉亚网站中所使用的僵尸网络都隶属于俄罗斯的犯罪组织，其中就有包括 RBN。</p><p><img src="https://cdn.medcom.id/dynamic/content/2015/08/12/156965/dJb2yGIKj8.jpg?w=1024"></p><blockquote><p>注：RBN是一种专门为违法犯罪分子进行网络犯罪提供庇护的自治域。</p></blockquote><p>第一阶段的攻击主要针对格鲁吉亚政府和媒体网站。俄罗斯的僵尸网络依靠强力的 DDoS 对这些目标采取行动。爱沙尼亚的网络在一年前受到俄罗斯黑客攻击，而格鲁吉亚的网络，由于其本身脆弱，比起前者更容易受到数据洪流包的影响 </p><h3 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h3><p>格鲁吉亚媒体和政府网站持续受到 DDoS 攻击的同时，俄罗斯第二阶段的网络作战力求对更多目标进行破坏，其破坏目标名单上包括金融机构企业教育机构西方媒体（英国广播公司和美国有线电视新闻网络）以及一处格鲁吉亚黑客网站 （图 3.1）。对这些服务器的攻击不仅包括 DDoS 攻击，还包括篡改服务器的网站（如：在政府网站上添加将格鲁吉亚总统米哈伊尔·萨卡什维利比作阿道夫·希特勒的亲俄涂鸦）。此外，一些俄罗斯黑客利用格鲁吉亚政治人物公开可用的电子邮件地址，发起垃圾邮件攻击。</p><p>同时，俄罗斯黑客利用BGP劫持，通过俄罗斯的服务器重新路由了格鲁吉亚的互联网流量，借机破坏政府网站，入侵电视和广播电台。</p><p><img src="https://th.bing.com/th/id/Rd683502377568ecde40b05694d1209ab?rik=85rCIN7iXtnnpA&pid=ImgRaw"></p><h2 id="对格鲁吉亚网络攻击的特点"><a href="#对格鲁吉亚网络攻击的特点" class="headerlink" title="对格鲁吉亚网络攻击的特点"></a>对格鲁吉亚网络攻击的特点</h2><h3 id="攻击目标"><a href="#攻击目标" class="headerlink" title="攻击目标"></a>攻击目标</h3><p>俄罗斯网络攻击的目标是“隔离和压制”格鲁吉亚人。攻击有效地使（1）格鲁吉亚媒体沉默并（2）使格鲁吉亚从国际社会孤立开来。</p><h3 id="与常规部队的配合"><a href="#与常规部队的配合" class="headerlink" title="与常规部队的配合"></a><strong>与常规部队的配合</strong></h3><p>网络攻击与常规部队的协调是非常有限的。</p><h3 id="侦察和准备"><a href="#侦察和准备" class="headerlink" title="侦察和准备"></a><strong>侦察和准备</strong></h3><p>许多安全专家认为，在 8 月 7 日最初的网络攻击之前，俄罗斯黑客已经准备好行动。</p><h2 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h2><p>2008 年 8 月俄罗斯对格鲁吉亚发动的网络攻击是第一次与主要常规军事行动同时发生的大规模网络攻击。这些网络攻击削弱了格鲁吉亚人与外界沟通的能力，在信息和心理上对媒体、政府以及公众产生了重大影响。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="网络武器库"><a href="#网络武器库" class="headerlink" title="网络武器库"></a>网络武器库</h3><p>2017年，NSA网络武器库的泄露[2]更是像世界展示了美国在网络战领域的狼子野心。僵尸网络，DDoS是发动网络攻击中非常有效的工具和手段。</p><h3 id="好用又廉价，网络战是未来战争不可缺少的一环"><a href="#好用又廉价，网络战是未来战争不可缺少的一环" class="headerlink" title="好用又廉价，网络战是未来战争不可缺少的一环"></a>好用又廉价，网络战是未来战争不可缺少的一环</h3><p>1991年海湾战争让世界眼前一亮。现在网络战、网络武器也进入人民的视野。网络战具有隐蔽、攻击范围大，对信息基础设施影响大（甚至是物理基础设施，见震网、美东部输油管道中断等），容易制造舆论压力等特点，<strong>好用又廉价。</strong>未来战争，网络战是其中必不可少的一部分。</p><h3 id="“网络人民战争”"><a href="#“网络人民战争”" class="headerlink" title="“网络人民战争”"></a>“网络人民战争”</h3><p>有意思的是，在网络攻击期间，俄罗斯网民可以从网站上下载黑客软件，安装之后点击“开始攻击”按钮即可进行网络攻击。媒体评论俄罗斯打了一场名副其实的“网络人民战争”。</p><p>正如你所看到的，看似平静的世界，硝烟弥漫。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1]<strong>《网络战》中文第三章：2008 年俄罗斯对格鲁吉亚的网络</strong>，<a href="https://blog.51cto.com/tasnrh/1908672">https://blog.51cto.com/tasnrh/1908672</a></p><p>[2] 2017 NSA网络武器库泄露工具总结分析,<a href="https://zhuanlan.zhihu.com/p/31793688">https://zhuanlan.zhihu.com/p/31793688</a></p>]]></content>
    
    
    <summary type="html">俄罗斯-格鲁吉亚网络冲突事件
“正如你所看到的，看似平静的世界，硝烟弥漫。” ——点我试试

事件简介
2008 年 8 月，为了把格鲁吉亚从南奥塞梯驱逐出去，俄罗斯军队进攻格鲁吉亚。此次军事行动开展的同时，也伴随了大量经过协调的网络攻击行动。这是第一次与大规模地面作战行动配合的大规模网络攻击，对格鲁吉亚展开了全面的“蜂群”式网络阻瘫攻击，致使格方电视媒体、金融和交通等重要系统瘫痪，机场、物流和通信等信息网络崩溃，急需的战争物资无法及时运达指定位置，战争潜力被严重削弱，直接影响了格鲁吉亚的社会秩序以及军队的作战指挥和调度。

网络攻击阶段
一位安全专家将俄罗斯对格鲁吉亚的网络攻击分为两个阶段。</summary>
    
    
    
    <category term="网络空间" scheme="http://dianwoshishi.github.io/categories/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4/"/>
    
    <category term="网络战" scheme="http://dianwoshishi.github.io/categories/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4/%E7%BD%91%E7%BB%9C%E6%88%98/"/>
    
    
    <category term="网络攻击" scheme="http://dianwoshishi.github.io/tags/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB/"/>
    
  </entry>
  
  <entry>
    <title>网络战武器——震网(Stuxnet)病毒</title>
    <link href="http://dianwoshishi.github.io/2021/06/06/%E7%BD%91%E7%BB%9C%E6%88%98%E6%AD%A6%E5%99%A8%E2%80%94%E2%80%94%E9%9C%87%E7%BD%91(Stuxnet)%E7%97%85%E6%AF%92/"/>
    <id>http://dianwoshishi.github.io/2021/06/06/%E7%BD%91%E7%BB%9C%E6%88%98%E6%AD%A6%E5%99%A8%E2%80%94%E2%80%94%E9%9C%87%E7%BD%91(Stuxnet)%E7%97%85%E6%AF%92/</id>
    <published>2021-06-06T04:00:00.000Z</published>
    <updated>2021-06-06T02:17:08.279Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络战武器——震网-Stuxnet-病毒"><a href="#网络战武器——震网-Stuxnet-病毒" class="headerlink" title="网络战武器——震网(Stuxnet)病毒"></a>网络战武器——震网(Stuxnet)病毒</h1><h2 id="震网事件"><a href="#震网事件" class="headerlink" title="震网事件"></a>震网事件</h2><p> 2010 年 6 月 17 日，白俄罗斯一家小 公司 VirusBlockAda 的安全研究人员 发现一种能感染可移动存储设备的恶意软 件。2010年7月，“震网”（Stuxnet）蠕虫攻击事件浮出水面，引发了国际主流安全厂商和安全研究者的全面关注，卡巴斯基、赛门铁克、安天等安全厂商，Ralph Langne等著名安全研究者，以及多国的应急组织和研究机构，都投入到了全面的分析接力中。2010 年 11 月，伊朗总统艾哈迈迪内贾 德公开承认，一种计算机病毒对“我国（核） 离心机中为数不多的几台机制造了一些问 题，”</p><p>最终使这场攻击的大量细节被呈现出来：这是一起经过长期规划准备和入侵潜伏作业；借助高度复杂的恶意代码和多个零日漏洞作为攻击武器；以铀离心机为攻击目标；以造成超压导致离心机批量损坏和改变离心机转数导致铀无法满足武器要求为致效机理，以阻断伊朗核武器进程为目的的攻击。</p><h3 id="事件时间轴"><a href="#事件时间轴" class="headerlink" title="事件时间轴"></a>事件时间轴</h3><p>下图取自安天实验室关于震网的报告：</p><p><img src="https://www.antiy.cn/images/20190930/1-1.jpg"></p><h2 id="震网病毒"><a href="#震网病毒" class="headerlink" title="震网病毒"></a>震网病毒</h2><p>Stuxnet 是一种计算机蠕虫，大约写于 2005 年到 2010 年之间。主要针对西门子型号为S7-315 和 S7-417 的工控机。其中对于315在攻击发生时，就让他宕机，对于417就使用类似中间人攻击的方式，对工控系统进行欺骗。具体可参考[3].</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>工作原理如下图所示，蠕虫的基本操作。</p><p><img src="https://static.oschina.net/uploads/space/2018/0520/075415_tRMq_2720166.jpg"></p><h2 id="震网影响"><a href="#震网影响" class="headerlink" title="震网影响"></a>震网影响</h2><h3 id="Stuxnet-是网空武器针对工业设备的首件案例。"><a href="#Stuxnet-是网空武器针对工业设备的首件案例。" class="headerlink" title="Stuxnet 是网空武器针对工业设备的首件案例。"></a>Stuxnet 是网空武器针对工业设备的首件案例。</h3><p>Stuxnet 成功地 影响了一个非虚拟实体。这是武器研制的一 项重大进展——在计算机打开后才存在的一 个 软 件 能 成 功 地 对 真 实 世 界 造 成 破 坏。 Stuxnet 清楚地展示，网空武器在军事行动中 能发挥重要作用。</p><h3 id="Stuxnet-所引发的军事革命-的最后一个方面是，它证明一些安全假设是-站不住脚的。"><a href="#Stuxnet-所引发的军事革命-的最后一个方面是，它证明一些安全假设是-站不住脚的。" class="headerlink" title="Stuxnet 所引发的军事革命 的最后一个方面是，它证明一些安全假设是 站不住脚的。"></a>Stuxnet 所引发的军事革命 的最后一个方面是，它证明一些安全假设是 站不住脚的。</h3><h4 id="常见的第一个假设是，物理隔-离的系统更安全。"><a href="#常见的第一个假设是，物理隔-离的系统更安全。" class="headerlink" title="常见的第一个假设是，物理隔 离的系统更安全。"></a>常见的第一个假设是，物理隔 离的系统更安全。</h4><p>按照定义，SCADA 系统控 制对使命具有关键意义的设备，很多管理人 员不把这些计算机同外部网络相连，以物理 隔离的方式来保证安全，结果是采用可移动 媒介把文件传至计算机。Stuxnet 的设计者利 用了这一假设，使病毒通过 U 盘等可移动存 储设备来传播。一旦 U 盘被感染，病毒软件 本身就在后来使用被感染驱动器的计算机上 运行 ；使用者只要在视窗上点击相关图形， 便开始被感染。这是 Stuxnet 利用其中一个 零日漏洞的直接应用。</p><h4 id="被-Stuxnet-证明是错误的另外一个关键-安全假设，是数字签名证书设立的信任关系。"><a href="#被-Stuxnet-证明是错误的另外一个关键-安全假设，是数字签名证书设立的信任关系。" class="headerlink" title="被 Stuxnet 证明是错误的另外一个关键 安全假设，是数字签名证书设立的信任关系。"></a>被 Stuxnet 证明是错误的另外一个关键 安全假设，是数字签名证书设立的信任关系。</h4><p>为了提供更大的稳定性，当代操作系统，包 括微软视窗，限制计算机的程序访问系统部 件。一个正常的程序要求系统经由驱动软件 呼叫硬件。鉴于这种情况，驱动软件比其他 程序具更高权限访问低层级系统部件。为了 避免轻易产生恶意驱动软件，微软视窗依赖 数字签名证书识别。Stuxnet 为了防止被杀毒 软件发现，使用了合法的数字签名证书。这 是此前没有发现的 Stuxnet 的另外一个方 面。早期的 Stuxnet 版本使用瑞昱（Realtek） 半导体系统公司提供的证书，后来的版本使 用智微（JMicron）科技公司的证书。使用这 些证书使病毒在微软视窗面前呈现合法软件 的假象。ESET 的安全专家注意到，两家公司 都在台湾地区，因此怀疑这些证书系被盗窃。 此外，他们相信，这极可能是实物盗窃（甚 至可能是内贼所为），因为在互联网的黑市上 驱动软件的数字证书并不常见。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ol><li><strong>网络空间作为一个新的虚拟空间，网络作战的参与方的能量不能以现实实体的大小来标定。</strong></li></ol><p>最近的事件表面，即使是个人，也能够宣告对公司、企业发动勒索；即使是组织，也能在网络空间中，对某国发动攻击。那么，网络空间的国家意志如何体现呢？在美国，或许就是网络空间作战司令部吧。</p><ol start="2"><li><strong>网络空间已经渗透入生活的方方面面，发动网络攻击对现实社会的影响巨大。</strong></li></ol><p>前段时间，美国东部输油管道被勒索，导致供应紧张，这件事情前后还报道了有相关的对物理基础设施的攻击事件，足以见到网络武器的威力。一枪一炮或许威力有限，但是对信息社会来说，信息类攻击的损失无可估量，每天都上演的DDoS分布式拒绝服务攻击造成了极大的经济损失。</p><ol start="3"><li><strong>与自然空间相比，人造空间还是有差距啊。</strong></li></ol><p>在网络空间中，规则是协议，落地是代码，协议和代码都是人设计和实现的，所以难免有漏洞，只要还有人的参与，漏洞就依旧会存在。自然空间就不一样了，规律就是规律(谁设计的呢？)，例如热力学第一定律（解释了为什么没有永动机），熵增定律（解释了人为啥会内卷）</p><blockquote><p> 闲扯一句：这就是为什么唯物辩证法说，一定要掌握事物运行的规律，运动和静止都是相对的等等</p><p>马克思诚不欺我也</p></blockquote><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1]震网事件的九年再复盘与思考，<a href="https://www.antiy.cn/research/notice&amp;report/research_report/20190930.html">https://www.antiy.cn/research/notice&amp;report/research_report/20190930.html</a></p><p>[2]震网——掀起网空战争军事革命， <a href="http://www.knowfar.org.cn/publication/uploadfiles/0204/0129/4.1.pdf">http://www.knowfar.org.cn/publication/uploadfiles/0204/0129/4.1.pdf</a></p><p>[3]  Stuxnet: Dissecting a Cyberwarfare Weapon, <a href="https://courses.cs.duke.edu/spring20/compsci342/netid/readings/stuxnet-dissect.pdf">https://courses.cs.duke.edu/spring20/compsci342/netid/readings/stuxnet-dissect.pdf</a></p>]]></content>
    
    
    <summary type="html">网络战武器——震网(Stuxnet)病毒
震网事件
 2010 年 6 月 17 日，白俄罗斯一家小 公司 VirusBlockAda 的安全研究人员 发现一种能感染可移动存储设备的恶意软 件。2010年7月，“震网”（Stuxnet）蠕虫攻击事件浮出水面，引发了国际主流安全厂商和安全研究者的全面关注，卡巴斯基、赛门铁克、安天等安全厂商，Ralph Langne等著名安全研究者，以及多国的应急组织和研究机构，都投入到了全面的分析接力中。2010 年 11 月，伊朗总统艾哈迈迪内贾 德公开承认，一种计算机病毒对“我国（核） 离心机中为数不多的几台机制造了一些问 题，”

最终使这场攻击的大量细节</summary>
    
    
    
    <category term="网络空间" scheme="http://dianwoshishi.github.io/categories/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4/"/>
    
    <category term="网络战" scheme="http://dianwoshishi.github.io/categories/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4/%E7%BD%91%E7%BB%9C%E6%88%98/"/>
    
    
    <category term="网络攻击" scheme="http://dianwoshishi.github.io/tags/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB/"/>
    
  </entry>
  
  <entry>
    <title>Unit 8200 世界上最强的网络部队之一</title>
    <link href="http://dianwoshishi.github.io/2021/06/05/Unit%208200%20%E4%B8%96%E7%95%8C%E4%B8%8A%E6%9C%80%E5%BC%BA%E7%9A%84%E7%BD%91%E7%BB%9C%E9%83%A8%E9%98%9F%E4%B9%8B%E4%B8%80/"/>
    <id>http://dianwoshishi.github.io/2021/06/05/Unit%208200%20%E4%B8%96%E7%95%8C%E4%B8%8A%E6%9C%80%E5%BC%BA%E7%9A%84%E7%BD%91%E7%BB%9C%E9%83%A8%E9%98%9F%E4%B9%8B%E4%B8%80/</id>
    <published>2021-06-05T09:00:00.000Z</published>
    <updated>2021-06-09T05:23:15.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Unit-8200-世界上最强的网络部队之一"><a href="#Unit-8200-世界上最强的网络部队之一" class="headerlink" title="Unit 8200 世界上最强的网络部队之一"></a>Unit 8200 世界上最强的网络部队之一</h1><h2 id="神秘的Unit-8200"><a href="#神秘的Unit-8200" class="headerlink" title="神秘的Unit 8200"></a>神秘的Unit 8200</h2><p>2014年，以色列出口的网络安全产品（即公司、银行和政府购买使自己免受黑客、病毒攻击的产品）总值达60亿美金，首次超越了以色列军事硬件的出口值，占领了全球10%的网络安全市场。2014-2016年，微软用3.2亿美元买下数据隐私公司Adallom；Facebook花了1.5亿美元收购移动端数据分析公司Onavo；PayPal以6千万美元收下CyActive, 一家能预判黑客进攻行为的公司；谷歌更是斥11亿美元收购Waze ，一款通过众包形式更新地图数据的导航应用</p><p><strong>而这些被高价收购的公司都有一个共同点：初创者均为以色列国防军（IDF，Israel Defense Forces）下属部队Unit 8200的退伍士兵。</strong></p><p>不仅如此，Unit 8200还盛产纳斯达克上市公司：Wix（WIX），目前世界上领先的建立在云架构基础上的网页开发平台；CheckPoint（CHKP）， 全球首屈一指的 Internet 安全解决方案供应商；Imperva（IMPV）, 全球领先的新型数据应用公司，提供数据库安全和审计解决方案；NICE（NICE），企业级安全解决方案公司； 卫星应用企业Gilat Network（GILT）</p><p><strong>被称为创业之国的以色列，是平均出产科学家、技术大拿、风投机构最多的国家，这其中 Unit 8200是个绕不过去的存在。</strong></p><h2 id="Unit-8200历史沿革"><a href="#Unit-8200历史沿革" class="headerlink" title="Unit 8200历史沿革"></a>Unit 8200历史沿革</h2><p><img src="https://th.bing.com/th/id/R3310ad320151d0dfdc1b035c822d5821?rik=6XHVm7zqDM4MZw&riu=http://s3.amazonaws.com/zweb-s3.uploads/visiontv/2017/04/21152853/Unit8200_Website_600.jpg&ehk=B3HZyvIE/+EfiwTJ8YDtVAjaQk8h6E4dlJ217jy7kh8=&risl=&pid=ImgRaw"></p><p><em>Unit 8200 是以色列情报部队的一部分，以培养世界上一些受欢迎的网络安全公司的创始人而闻名。</em></p><p>它的前身始于20世纪30年代的英国托管时期（British Mandate Period）, 最开始被称为“Shin Mem 2”，即希伯来语的“第二信息服务部门”, 负责窃听阿拉伯部落的电话线，提前获取暴动的消息。</p><p>1948年以色列建国时，它被称为515部队，这个随意想出来的数字为的是在公开谈话中无需特意避讳。1952年，它正式成为单独的情报部门，1956年，第二次中东战争时，它又变成848部队。 1973年第四次中东战争后， 改名为Unit 8200，沿用至今。</p><p>根据一些情报专家的分析，Unit 8200可以与美国国家安全局 （NSA，National Security Agency）或英国政府通讯总部（ GCHQ，Britain’s Government Communications Headquarters）相提并论，在某些领域甚至更强。它负责综合协调军队的情报工作，以色列之外的所有地区都属于它的势力范围（包括巴勒斯坦）。</p><blockquote><p>Unit 8200参与过的行动：</p><blockquote><p>1967年，“8200部队”获得了当年最成功的情报——在“<a href="https://baike.baidu.com/item/%E5%85%AD%E6%97%A5%E6%88%98%E4%BA%89">六日战争</a>”的第一天，就成功截获埃及总统<a href="https://baike.baidu.com/item/%E7%BA%B3%E8%B5%9B%E5%B0%94">纳赛尔</a>和约旦国王<a href="https://baike.baidu.com/item/%E4%BE%AF%E8%B5%9B%E5%9B%A0">侯赛因</a>的高保密专线电话，从而详尽地了解己方战果以及敌方下一步计划。</p><p>1985年，Unit 8200提供了一份电话监听记录，证实了阿拉法特与1973年发生在苏丹的美外交官被劫、被杀事件有关；</p><p>2007年，根据Unit 8200提供的情报，以色列炸掉了一个叙利亚核反应堆；</p><p>2010年，伊朗核反应堆中了Stuxnet电脑病毒， 五分之一的离心器被摧毁，伊朗拥有核武器的时间因此延迟了好几年，而“据说”这是Unit 8200和CIA联手的成果（IDF拒不承认）</p><p>相关资料：<a href="http://paranoidechochamber.com/unit-8200/">http://paranoidechochamber.com/unit-8200/</a></p><p><img src="http://paranoidechochamber.com/wp-content/uploads/2017/05/download-8.jpeg"></p></blockquote></blockquote><h2 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h2><p>根据以色列国防军的序列</p><p><img src="https://s.secrss.com/anquanneican/875e8cb619cc40f44518b7cf0d7a136a.jpg"></p><p>8200部队隶属于以色列国防军军事情报部(简写：AMAN，而AMAN隶属于国防军总参谋部)的。</p><h2 id="Unit8200组成序列（补充）"><a href="#Unit8200组成序列（补充）" class="headerlink" title="Unit8200组成序列（补充）"></a>Unit8200组成序列（补充）</h2><ul><li><p>Unit Hatzav</p><p>开源情报部队，主要面向全世界的媒体：电视，广播，新闻报纸，Internet，甚至是社交网络。</p></li><li><p>Unit81</p><p>AMAN 的技术部队，主要是搜集和支持最先进的技术（通常结合软硬件产品），大约有1000人。</p></li><li><p>Gedasim</p><p>信息作战团。主要是实时获取地面情报并实时传输战场。</p></li></ul><h2 id="以色列人才孵化器"><a href="#以色列人才孵化器" class="headerlink" title="以色列人才孵化器"></a>以色列人才孵化器</h2><p>以色列最优秀的人才集中在部队。军事部门可以直接对优秀的高中毕业生选召，如果能被8200部队选上，对犹太人来讲，则是一生的荣誉。</p><p>以色列强制兵役规定，犹太人满18岁需服兵役。一般情况下，他们会被随机分配到不同的部队。但一批天资聪颖，最具培养前途的孩子则被Unit 8200经过严格筛选后挑走。这是一支专攻网络安全及情报收集的秘密部队，是顶尖的以色列高科技情报部门。当然8200部队选拔过程极其严格，每年挑选50-100人。同龄人中智力水平最高，最有培养前途，品格正直敢于承担责任的那些人才有可能被安排进入代表以色列最高水平的高科技情报部门在实战中学习与服役。进入Unit 8200后，这些大部分刚满18岁的孩子马上就被投入实战，边服役边学习。<em>加入该单位的年轻人会接触到真实的计算机黑客和网络间谍活动任务</em>。服役完毕后，他们可以选择加入高科技公司，也可以选择继续深造。</p><p>目前，Unit 8200集情报部门、人才训练营、科技孵化器为一体，是以色列国防军中最大且发展速度最快的部门，据估有5000人。每时每刻，它都处理着海量电子数据，数据来源包括移动端、网络、微波信号发生器和卫星。以色列国防军中最重要的信号情报（signals intelligence, SIGINT）部门Urim SIGINIT Base也是Unit 8200的一部分。</p><p>美国《福布斯》报道说，以色列的高科技领域的精英大多来自神秘的8200部队。这些人要么是企业家，要么是公司的创立人或者是中高级主管。以色列的三大高科技公司Nice、Comverse和Check Point的很多技术都来自这个神秘的8200部队。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>Unit 8200: How NSA of Israel Has One Of The Most Powerful Cyber Armies In The World，<a href="https://fossbytes.com/unit-8200-israel-cyber-army/">https://fossbytes.com/unit-8200-israel-cyber-army/</a></p><p><a href="https://www.sohu.com/a/119924768_464003">https://www.sohu.com/a/119924768_464003</a></p><p>The Israeli Unit 8200 An OSINT-based study，<a href="https://www.research-collection.ethz.ch/handle/20.500.11850/389135">https://www.research-collection.ethz.ch/handle/20.500.11850/389135</a></p><p>以色列网电空间作战力量浅析, <a href="https://www.secrss.com/articles/29670">https://www.secrss.com/articles/29670</a></p>]]></content>
    
    
    <summary type="html">Unit 8200 世界上最强的网络部队之一
神秘的Unit 8200
2014年，以色列出口的网络安全产品（即公司、银行和政府购买使自己免受黑客、病毒攻击的产品）总值达60亿美金，首次超越了以色列军事硬件的出口值，占领了全球10%的网络安全市场。2014-2016年，微软用3.2亿美元买下数据隐私公司Adallom；Facebook花了1.5亿美元收购移动端数据分析公司Onavo；PayPal以6千万美元收下CyActive, 一家能预判黑客进攻行为的公司；谷歌更是斥11亿美元收购Waze ，一款通过众包形式更新地图数据的导航应用

而这些被高价收购的公司都有一个共同点：初创者均为以色列国防</summary>
    
    
    
    <category term="网络空间" scheme="http://dianwoshishi.github.io/categories/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4/"/>
    
    <category term="网络战" scheme="http://dianwoshishi.github.io/categories/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4/%E7%BD%91%E7%BB%9C%E6%88%98/"/>
    
    
    <category term="网络空间" scheme="http://dianwoshishi.github.io/tags/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4/"/>
    
  </entry>
  
  <entry>
    <title>互联网发展简史(5)第一次浏览器大战</title>
    <link href="http://dianwoshishi.github.io/2021/06/04/%E4%BA%92%E8%81%94%E7%BD%91%E5%8F%91%E5%B1%95%E7%AE%80%E5%8F%B2(5)%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A4%A7%E6%88%98/"/>
    <id>http://dianwoshishi.github.io/2021/06/04/%E4%BA%92%E8%81%94%E7%BD%91%E5%8F%91%E5%B1%95%E7%AE%80%E5%8F%B2(5)%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A4%A7%E6%88%98/</id>
    <published>2021-06-04T01:00:00.000Z</published>
    <updated>2021-06-04T01:43:01.344Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://pic3.zhimg.com/80/v2-6ee73b0ea861779f5516ad8c0dc92272_720w.jpg"></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>万维网真正开始在 1990 年代中期起飞。如果你想使用它，你需要一个网络浏览器。早期的互联网用户可以使用简单的基于文本的终端软件，但 Web 从一开始就有一个图形界面。</p><h3 id="早期的网络浏览器"><a href="#早期的网络浏览器" class="headerlink" title="早期的网络浏览器"></a>早期的网络浏览器</h3><p>由 Tim Berners-Lee设计的第一个网络浏览器被称为World Wide Web，但它<strong>无法在文档中显示图像</strong>，只能在弹出窗口中显示。然而，万维网只不过是一个原型。很快，其他开发商也加入了竞争。中国台湾工程师魏培元开发了一款名为 ViolaWWW 的浏览器。这可以在网页中显示图像，并具有基本的框架和脚本。但是 ViolaWWW 很快就被所有现代浏览器之父 Mosaic 打败。</p><h4 id="马赛克"><a href="#马赛克" class="headerlink" title="马赛克"></a>马赛克</h4><p>Mosaic是在伊利诺伊大学国家超级计算应用中心(NCSA) 开发的。与其他早期浏览器相比，Mosaic 更易于使用，具有更好的网页渲染，包括<strong>内嵌图形</strong>。最重要的是，它背后有一支才华横溢的工程师团队。Mosaic 不是第一个浏览器，但它确是第一个做对的浏览器，点燃了浏览器的市场。</p><p><img src="https://pic3.zhimg.com/80/v2-dbe94e32f1b223f299cba226ab8d8756_720w.jpg"></p><h4 id="网景"><a href="#网景" class="headerlink" title="网景"></a>网景</h4><p>Netscape 的浏览器对网络冲浪体验进行了大量技术改进，例如 cookie 和 Javascript。Navigator 是一种商业产品，售价约为 30 美元。他们 Netscape 对大学和 ISP 的许可有宽松的政策，因此许多人可以免费获得它。由于广泛分布和大量技术创新，Netscape Navigator 迅速成为主导标准。</p><p><img src="https://pic1.zhimg.com/80/v2-35016fd5753ad63659c06be1142abba4_720w.jpg"></p><h4 id="望远镜-Spyglass-和-Internet-Explorer"><a href="#望远镜-Spyglass-和-Internet-Explorer" class="headerlink" title="望远镜(Spyglass)和 Internet Explorer"></a>望远镜(Spyglass)和 Internet Explorer</h4><p>尽管 Netscape 取得了成功，但它并没有杀死 Mosaic。为了将他们的浏览器货币化，NCSA 将他们的商业资产分拆成一家名为Spyglass的公司。Spyglass 与 Netscape 竞争了一段时间，直到世界上最强大的软件公司微软进入网络浏览器市场。因此，他们从 Spyglass 获得了 Mosaic 许可，并创建了一个名为 Internet Explorer (IE) 的新浏览器。第一次浏览器战争由此开始。</p><p><img src="https://tse4-mm.cn.bing.net/th/id/OIP.BluQ89-KWP4n4m_WTeazGgHaHO?pid=ImgDet&rs=1"></p><h2 id="第一次浏览器战争"><a href="#第一次浏览器战争" class="headerlink" title="第一次浏览器战争"></a>第一次浏览器战争</h2><p>在 1990 年代中期，Netscape 是硅谷的宠儿。Netscape 的商业模式建立在<strong>销售 Navigator 之上</strong>。但微软的大部分收入来自销售Windows 95和微软Office。为了抢占浏览器市场，Microsoft 决定将 Internet Explorer 与 Windows 98 的每个副本捆绑在一起。不仅捆绑在一起，而且集成到操作系统中(<strong>免费赠送 Internet Explorer</strong>)。在 Windows 98 中，计算机默认使用 IE。</p><h3 id="网景分崩离析"><a href="#网景分崩离析" class="headerlink" title="网景分崩离析"></a>网景分崩离析</h3><p>Netscape 通过向他们的产品添加更多功能来回击。他们将 Navigator 4.0 集成到名为 Netscape Communicator 的应用程序套件中。这包括浏览器以及电子邮件客户端、HTML 编辑器、新闻聚合器和其他 Internet 实用程序。但随着 Netscape 添加更多功能，它们的代码库变得笨拙。</p><p>1998 年初，Netscape 创建了一个非盈利基金会来创建开源代码库。他们以他们的吉祥物 Mozilla 命名基金会。Mozilla 基金会有潜力，但 Netscape 作为一个商业实体继续受到影响。那年晚些时候，他们与AOL合并。这也帮助他们免费提供他们的浏览器，但随着 Windows 98 接管桌面，为时已晚。在短短几年内，甚至 AOL 也转向了 Internet Explorer。Netscape的时代过去了。</p><p><img src="https://pic1.zhimg.com/80/v2-85b36a8c3f618555aeb6e5698dc5aac0_720w.jpg"></p><h3 id="微软的胜利"><a href="#微软的胜利" class="headerlink" title="微软的胜利"></a>微软的胜利</h3><p>通过将 Internet Explorer 与 Windows 以及 Mac OS 捆绑在一起，微软完全占领了市场。到 2002 年，Internet Explorer 占据了超过 95% 的市场份额。微软赢得了第一次浏览器战争。然后他们固步自封。当Windows XP时，微软已经停止创新。他们认为 IE 只是操作系统的另一部分，就像纸牌一样。随后几年停滞不前，但随着 Web 的发展和变化，新产品将从 Netscape 的灰烬中崛起。几乎被遗忘的 Mozilla 项目将再次挑战 IE，为第二次浏览器战争开辟道路。</p><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p>The First Browser War <a href="http://steve-lovelace.com/the-first-browser-war/">http://steve-lovelace.com/the-first-browser-war/</a></p><p>欢迎关注我的微信公众号，扫描下方二维码，就可以找到我，我会持续为你分享 IT 技术和珠宝知识。</p><p><img src="https://pic1.zhimg.com/80/v2-8ff04a9934840c3c552ed41497bc4748_720w.jpg" alt="欢迎关注我的微信公众号，扫描下方二维码，就可以找到我，我会持续为你分享 IT 技术和珠宝知识"></p><p>也可以关注我的个人博客:<a href="https://dianwoshishi.github.io/">点我试试的个人博客</a></p><p><a href="https://dianwoshishi.github.io/" target="_blank" class="LinkCard">点我试试的个人博客</a></p>]]></content>
    
    
    <summary type="html">背景
万维网真正开始在 1990 年代中期起飞。如果你想使用它，你需要一个网络浏览器。早期的互联网用户可以使用简单的基于文本的终端软件，但 Web 从一开始就有一个图形界面。

早期的网络浏览器
由 Tim Berners-Lee设计的第一个网络浏览器被称为World Wide Web，但它无法在文档中显示图像，只能在弹出窗口中显示。然而，万维网只不过是一个原型。很快，其他开发商也加入了竞争。中国台湾工程师魏培元开发了一款名为 ViolaWWW 的浏览器。这可以在网页中显示图像，并具有基本的框架和脚本。但是 ViolaWWW 很快就被所有现代浏览器之父 Mosaic 打败。

马赛克
Mosa</summary>
    
    
    
    <category term="总结" scheme="http://dianwoshishi.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="互联网" scheme="http://dianwoshishi.github.io/tags/%E4%BA%92%E8%81%94%E7%BD%91/"/>
    
    <category term="历史" scheme="http://dianwoshishi.github.io/tags/%E5%8E%86%E5%8F%B2/"/>
    
  </entry>
  
  <entry>
    <title>互联网发展简史(4) WWW</title>
    <link href="http://dianwoshishi.github.io/2021/06/03/%E4%BA%92%E8%81%94%E7%BD%91%E5%8F%91%E5%B1%95%E7%AE%80%E5%8F%B2(4)%20WWW/"/>
    <id>http://dianwoshishi.github.io/2021/06/03/%E4%BA%92%E8%81%94%E7%BD%91%E5%8F%91%E5%B1%95%E7%AE%80%E5%8F%B2(4)%20WWW/</id>
    <published>2021-06-03T01:00:00.000Z</published>
    <updated>2021-06-03T00:49:49.072Z</updated>
    
    <content type="html"><![CDATA[<h2 id="互联网发展简史-4-WWW"><a href="#互联网发展简史-4-WWW" class="headerlink" title="互联网发展简史(4) WWW"></a>互联网发展简史(4) WWW</h2><p><img src="https://pic3.zhimg.com/80/v2-c2cfb99f03d33c3f8fc20a95b220fe82_720w.jpg" alt="18k金ins气质风CD耳钉"></p><p>万维网(World Wide Web, WWW)是可以通过一种被称为超文本传输协议(HTTP)来搜索和检索网站。该协议简化了地址的书写（使用前面所说的DNS系统），自动在互联网上搜索指定的地址，并自动调出文件查看，正如你现在浏览本文时看到的一样，不过那时候可没有现在这么酷。</p><h3 id="万维网"><a href="#万维网" class="headerlink" title="万维网"></a>万维网</h3><p>万维网的概念是1989年由Tim Berners-Lee和CERN(日内瓦的欧洲高能物理中心)的科学家们设计(前文说过研究资料在网上开放，但是需要自己检索，但他们觉得检索文件太麻烦，为了简化检索程序，提出了万维网的概念)。1990年，他们开发了一个“浏览器/编辑器”程序，并命名为“万维网”(World Wide Web)。该程序在ftp网站上免费发布，这极大的简化了检索程序。 这个系统可以让链接隐藏在文本后面(使用超文本标记语言，HTML)，点击“鼠标”就可以激活。但这种新系统似乎并没有迅速应用起来，到1992年底，世界上只有50个网站，一年后这个数字仍然不超过150个。</p><p><img src="https://www.let.leidenuniv.nl/history/ivh/screen1994.gif" alt="An early WWW screen (1994)"></p><p>上面的图片显示了1994年浏览器技术的“最先进”(早期版本不支持颜色，徽号和图表也在不同的窗口中)。</p><h3 id="点燃Web"><a href="#点燃Web" class="headerlink" title="点燃Web"></a>点燃Web</h3><h4 id="Mosaic-马赛克"><a href="#Mosaic-马赛克" class="headerlink" title="Mosaic(马赛克)"></a>Mosaic(马赛克)</h4><p>1993年，NCSA(美国国家超级计算应用中心，伊利诺斯州)的Mark Andreesen推出了Mosaic x(没错，这就是后来的网景浏览器，中文翻译可以叫做马赛克… …互联网历史上第一个获普遍使用和能够显示图片的网页浏览器)。它易于安装、使用，而且有24小时的客户支持。它还极大地提高了图形功能和安装的许多我们现在熟悉的特性(被后来Netscape Navigator和比尔·盖茨的Internet Explorer继承)。像其他许多互联网创新一样，Mosaic的试用版也免费提供给教育社区。Mosaic x很快就成为了一个大热门。到1994年，在世界各地的计算机上安装了成千上万个版本。</p><blockquote><p>当时的Mosaic开发的中心人物Mark Andreesen(这哥们曾经说，在网景面前，Windows只是一堆设计拙劣的驱动程序)和Silicon Graphic(计算机绘图用的高性能计算机制造公司，简称为SGI)公司的创始人吉姆·克拉克设立了「MOSAIC Communication Corp.」，这家公司之后1994年11月改名为「Netscape Communication Corp.」，中译为<strong>网景</strong>。于1997年1月7日正式终止开发和支持</p><p>虽然网景消失了，但是从html的img标签开始，到创造javascript，开创SSL，奠定了未来几十年的互联网Web基础，当年的星星之火现已燎原。</p><p>第一次浏览器大战后，在1998年网景公开了浏览器源代码，并将其命名为Mozilla。2004年基于Mozilla源代码，另一个杰出的浏览器诞生了，它就是Firefox（火狐）</p><p>笔者认为，这个公司在互联网历史上真的是神一样的存在。</p></blockquote><p><img src="https://www.let.leidenuniv.nl/history/ivh/mosaic.gif" alt="An early opening screen for Mosaic and Netscape"></p><p><img src="https://www.let.leidenuniv.nl/history/ivh/netscape.gif" alt="An early opening screen for Mosaic and Netscape"></p><p>HTML可以创建具有吸引力的图形网站，这些网站可以通过新一代的浏览器轻松访问，这为全新的群体打开了Web。</p><p>到目前为止，Web已经服务于两个主要社区——科学界(访问在线文档)和更广泛的“网民”(网民)社区(访问电子邮件和新闻组设施)。现在商业网站开始大量涌现，紧随其后的是不远处的当地学校/俱乐部/家庭网站。功能更强大(也更便宜)的个人电脑(增加了网民数量和潜在的商业市场)的出现，以及通信基础设施容量的增加，加速了这些发展。</p><h4 id="蓬勃发展"><a href="#蓬勃发展" class="headerlink" title="蓬勃发展"></a>蓬勃发展</h4><p>1994年，有3,200万个主机和3,000个网站。12个月后，主机数量翻了一番，网站数量攀升至2.5万个。到第二年年底，主机的数量又翻了一番，网站的数量也增加了十倍以上。顺便提一下，在那一年，莱顿大学历史系建立了自己的网站，使其网站成为有史以来第一批的网站之一。<strong>第二年，我们开设了“历史学家的互联网”课程，在经济和社会历史板块内，我们开始开发“基于课程”的网站</strong>(云课堂？？？)。这一切都发生在1997年，当时集成到网络的主机数量已经达到了1,950万台，而网站的数量已经激增到1,200万台。据2001年1月的最新统计，主机数量达到1.1亿，网站数量达到3000万。</p><h3 id="互联网和网络之间的区别是什么"><a href="#互联网和网络之间的区别是什么" class="headerlink" title="互联网和网络之间的区别是什么?"></a>互联网和网络之间的区别是什么?</h3><p>Tim Berners-Lee(没错，就是提出万维网概念的那个哥们)经常被问到同样的问题，他的回答是:</p><ul><li>“互联网(‘Net’)是网络的网络。基本上它是由电脑和电缆制成的。Vint Cerf 和 Bob Khan所做的是弄清楚如何用它来发送小“包”的信息。正如Vint Cerf 指出的，数据包有点像明信片，上面有一个简单的地址。如果你把正确的地址放在一个数据包上，并把它交给任何一台作为网络一部分相连的计算机，每台计算机就会找出下一条电缆将它发送下去，这样它就能到达目的地。这就是互联网的作用。它可以在一秒钟之内将数据包发送到世界上的任何地方。</li><li>网络是一个抽象的(想象的)信息空间。<ul><li>在互联网上，你可以找到电脑——在Web上，你可以找到文件、声音、视频，….信息。</li><li>在互联网上，连接是计算机之间的电缆;在Web上，连接是超文本链接。</li><li>互联网的存在是由于网络上计算机之间通信的程序。没有互联网就没有Web。万维网使互联网变得有用（现在这个说法好像不太准确），因为人们对信息真的很感兴趣(更不用说知识和智慧了!)，而不是真的想知道关于计算机和电缆的知识。</li></ul></li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>Chapter Two: From ARPANET to World Wide Web</p><p>欢迎关注我的微信公众号，扫描下方二维码，就可以找到我，我会持续为你分享 IT 技术和珠宝知识。</p><p><img src="https://pic1.zhimg.com/80/v2-8ff04a9934840c3c552ed41497bc4748_720w.jpg" alt="欢迎关注我的微信公众号，扫描下方二维码，就可以找到我，我会持续为你分享 IT 技术和珠宝知识"></p><p>也可以关注我的个人博客:<a href="https://dianwoshishi.github.io/">点我试试的个人博客</a></p><p><a href="https://dianwoshishi.github.io/" target="_blank" class="LinkCard">点我试试的个人博客</a></p>]]></content>
    
    
    <summary type="html">互联网发展简史(4) WWW


万维网(World Wide Web, WWW)是可以通过一种被称为超文本传输协议(HTTP)来搜索和检索网站。该协议简化了地址的书写（使用前面所说的DNS系统），自动在互联网上搜索指定的地址，并自动调出文件查看，正如你现在浏览本文时看到的一样，不过那时候可没有现在这么酷。

万维网
万维网的概念是1989年由Tim Berners-Lee和CERN(日内瓦的欧洲高能物理中心)的科学家们设计(前文说过研究资料在网上开放，但是需要自己检索，但他们觉得检索文件太麻烦，为了简化检索程序，提出了万维网的概念)。1990年，他们开发了一个“浏览器/编辑器”程序，并命名为</summary>
    
    
    
    <category term="总结" scheme="http://dianwoshishi.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="互联网" scheme="http://dianwoshishi.github.io/tags/%E4%BA%92%E8%81%94%E7%BD%91/"/>
    
    <category term="历史" scheme="http://dianwoshishi.github.io/tags/%E5%8E%86%E5%8F%B2/"/>
    
  </entry>
  
  <entry>
    <title>互联网发展简史(3)从Internet到WWW</title>
    <link href="http://dianwoshishi.github.io/2021/06/01/%E4%BA%92%E8%81%94%E7%BD%91%E5%8F%91%E5%B1%95%E7%AE%80%E5%8F%B2(3)/"/>
    <id>http://dianwoshishi.github.io/2021/06/01/%E4%BA%92%E8%81%94%E7%BD%91%E5%8F%91%E5%B1%95%E7%AE%80%E5%8F%B2(3)/</id>
    <published>2021-06-01T13:00:00.000Z</published>
    <updated>2021-06-01T15:51:16.525Z</updated>
    
    <content type="html"><![CDATA[<p>新品ISN潮流质感钻石G项链气质百搭款</p><p><img src="/2021/06/01/%E4%BA%92%E8%81%94%E7%BD%91%E5%8F%91%E5%B1%95%E7%AE%80%E5%8F%B2(3)/image-20210601204355672.png" alt="新品ISN潮流质感钻石G项链气质百搭款"></p><p>前文讲到，TCP/IP协议助力ARPANET统一了网络协议标准，自此使用TCP/IP协议标准的Internet诞生了。</p><p>到目前为止，网络的发展几乎完全是“科学主导的”，本节我们将讲述Internet到万维网(WWW)的发展。</p><h3 id="网络出现瓶颈"><a href="#网络出现瓶颈" class="headerlink" title="网络出现瓶颈"></a>网络出现瓶颈</h3><p>此前计算机能力和速度的并行进步使Internet得以扩张。但规模扩张的同时也带来了问题。</p><p>到20世纪80年代初，当互联网正式开始运营时</p><ul><li>连接到网络上的计算机“主机”比最初设想的要多(1984年主机的数量首次超过1000台);</li><li>每台主机的流量要大得多(主要是因为电子邮件的成功)。</li></ul><p>越来越多的人预言，整个网络最终会陷入瘫痪。</p><h3 id="解决网络瓶颈"><a href="#解决网络瓶颈" class="headerlink" title="解决网络瓶颈"></a>解决网络瓶颈</h3><p>这一时期产生了两个重要事件，有效的缓解了网络瓶颈，并促进了网络的发展：</p><p><strong>第一个重要的发展是1984年引入的域名服务器(Domain Name System)。</strong></p><ul><li>DNS系统使得主机的名称更容易记住，用户不用去记住每一个又数字组成的IP地址，如116.25.XXX.XXX，而是类似于<a href="http://www.example[.]com的容易记住的名字。">www.example[.]com的容易记住的名字。</a></li><li>DNS系统在互联网地址中引入了一些分层结构,更加利于组织众多域名和主机，如edu(教育),com(商业)、gov(政府)和org(组织)和一系列国家代码。</li></ul><p><strong>第二个是各国政府决定鼓励在整个高等教育系统中使用互联网，并制定了一系列利好政策，促进了互联网的进一步统一和繁荣。</strong></p><p>1984年，英国政府宣布建立JANET(联合学术网络)，为英国大学服务；1985年，基于同样的目的，美国国家科学基金会(National Science Foundation)建立了国家科学基金网(NSFNet)(为其提供资助的条件是，“校园内所有合格用户”都必须能够访问该网络)。美国的这项计划涉及了一系列对互联网发展至关重要的决定：</p><ul><li><p>所有参与者都必须使用TCP/IP协议</p></li><li><p>联邦机构将分担建立公共基础设施(如跨洋连接)的费用并支持网关</p></li><li><p>NSFNet与其他科学网络(包括阿帕网ARPANet)签署了共享基础设施的“no-metered-cost”协议，为所有后续协议做出了示范。</p></li><li><p>鼓励进一步国际合作</p></li><li><p>NSFNet同意为美国互联网服务提供“主干”，并提供5台“超级计算机”来服务通信。第一批计算机提供每秒56 000字节(56KB/s)的网络能力</p><blockquote><p>国家科学基金网（NSFNet）的建立对互联网产生了巨大的影响。</p><ul><li><p>首先，它打破了网络的容量瓶颈。</p></li><li><p>其次，它促进了互联网使用的激增。之前用了十年的时间，联网的主机数量才突破了千台大关；到1986年，主机的数量已经达到5000台，一年后这个数字攀升到28000台。</p></li></ul></blockquote></li></ul><p><img src="https://www.let.leidenuniv.nl/history/ivh/nsf_backbone.gif" alt="NSF骨干网"></p><p><img src="https://www.let.leidenuniv.nl/history/ivh/nsfnet.gif" alt="NSFnet1991"></p><h3 id="互联网商业化发展"><a href="#互联网商业化发展" class="headerlink" title="互联网商业化发展"></a>互联网商业化发展</h3><p>我们注意到，之前网络的参与者基本上没有商业用户，这是由于NSFNet将商业用户排除在其网络之外。</p><p>虽然NSFNet将商业用户排除在网络之外，但并不意味着他们的对互联网不感兴趣。多年来，硬件和软件供应商一直在将TCP/IP添加到他们的产品包中，但他们对产品如何工作缺乏经验，因此他们在提供满足需求的产品方面遇到了困难。这时，互联网活动委员会(IAB)迈出了一步：</p><p>1985年，IAB组织了第一个专门针对私营部门的研讨会，讨论TCP/IP协议的潜力(和目前的限制)， 这次讨论在在政府/学术科学家和私营部门之间，以及私营企业家之间进行。其中一个重要的内容就是：确保他们的产品的互操作性</p><h3 id="“晦涩难懂”的互联网"><a href="#“晦涩难懂”的互联网" class="headerlink" title="“晦涩难懂”的互联网"></a>“晦涩难懂”的互联网</h3><p>到1989年，主机的数量首次超过了10万，并在一年后攀升至30万。</p><p>但在这个阶段，<strong>互联网仍然只是少数人内行的网络</strong>，对外行来说仍然是一个相当令人生畏的地方。例如：查找数据的访问命令从复杂到难以理解，可用的文档大多是(高度)科学的，显示不吸引人(信使脚本，没有颜色)，寻找东西是一件棘手的事情，传输时间相对较慢)。对商业部门的主要吸引力是电子邮件设施和使用电子邮件、新闻组、“聊天”设施和电脑游戏。</p><h3 id="互联网发展的分界点"><a href="#互联网发展的分界点" class="headerlink" title="互联网发展的分界点"></a>互联网发展的分界点</h3><p>转眼来到了上世纪80年代末和90年代初，这个时间点是互联网发展的一个分界点，原因有几个：</p><ul><li>1990年，阿帕网(1983年被剥夺了军事研究功能)成为了自身成功的牺牲品。</li><li>1990年，蒙特利尔麦吉尔大学开发了第一个用于查找和检索计算机文件的互联网搜索引擎Archie。</li><li>1991年，美国国家科学基金会取消了对私人访问其骨干计算机的限制，</li><li>“信息高速公路”项目应运而生。这是为了普及戈尔的高性能计算法案而起的名字，该法案为进一步研究计算和改善美国互联网结构的基础设施提供了资金。</li><li>1992- 1996年期间，其最大拨款为国家科学基金15亿美元，NASA 6亿美元，能源部660美元。</li><li>1991年，万维网(WWW)问世</li></ul><p>下一节，我们将讲述WWW(万维网)的发展。敬请关注。</p><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p>[1] <a href="https://www.let.leidenuniv.nl/history/ivh/chap2.htm">Chapter Two: From ARPANET to World Wide Web</a></p><p>欢迎关注我的微信公众号，扫描下方二维码，就可以找到我，我会持续为你分享 IT 技术和珠宝知识。</p><p><img src="https://pic1.zhimg.com/80/v2-8ff04a9934840c3c552ed41497bc4748_720w.jpg" alt="欢迎关注我的微信公众号，扫描下方二维码，就可以找到我，我会持续为你分享 IT 技术和珠宝知识"></p><p>也可以关注我的个人博客</p><p><a href="https://dianwoshishi.github.io/">点我试试的个人博客</a></p>]]></content>
    
    
    <summary type="html">新品ISN潮流质感钻石G项链气质百搭款



前文讲到，TCP/IP协议助力ARPANET统一了网络协议标准，自此使用TCP/IP协议标准的Internet诞生了。

到目前为止，网络的发展几乎完全是“科学主导的”，本节我们将讲述Internet到万维网(WWW)的发展。

网络出现瓶颈
此前计算机能力和速度的并行进步使Internet得以扩张。但规模扩张的同时也带来了问题。

到20世纪80年代初，当互联网正式开始运营时

 * 连接到网络上的计算机“主机”比最初设想的要多(1984年主机的数量首次超过1000台);
 * 每台主机的流量要大得多(主要是因为电子邮件的成功)。

越来越多的人</summary>
    
    
    
    <category term="总结" scheme="http://dianwoshishi.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="互联网" scheme="http://dianwoshishi.github.io/tags/%E4%BA%92%E8%81%94%E7%BD%91/"/>
    
    <category term="历史" scheme="http://dianwoshishi.github.io/tags/%E5%8E%86%E5%8F%B2/"/>
    
  </entry>
  
  <entry>
    <title>互联网发展简史(2)从ARPANET到Internet</title>
    <link href="http://dianwoshishi.github.io/2021/06/01/%E4%BA%92%E8%81%94%E7%BD%91%E5%8F%91%E5%B1%95%E7%AE%80%E5%8F%B2(2)/"/>
    <id>http://dianwoshishi.github.io/2021/06/01/%E4%BA%92%E8%81%94%E7%BD%91%E5%8F%91%E5%B1%95%E7%AE%80%E5%8F%B2(2)/</id>
    <published>2021-05-31T16:00:00.000Z</published>
    <updated>2021-06-01T15:51:20.500Z</updated>
    
    <content type="html"><![CDATA[<p><strong>今日珠宝</strong></p><p><img src="https://pic4.zhimg.com/80/v2-5b67214ba6baf09e996ae7954768f217_720w.jpg"></p><p>原文为知乎，现转移到个人博客。<br><a href="https://zhuanlan.zhihu.com/p/376893651" target="_blank" class="LinkCard">知乎原文</a></p><p>原文为微信公众号文章，现转移到个人博客。<br><a href="https://mp.weixin.qq.com/s/LH6PU0afKLVra6Kn6coemQ" target="_blank" class="LinkCard">微信公众号原文</a></p><h2 id="互联网发展简史-2-从ARPANET到Internet"><a href="#互联网发展简史-2-从ARPANET到Internet" class="headerlink" title="互联网发展简史(2) 从ARPANET到Internet"></a>互联网发展简史(2) 从ARPANET到Internet</h2><h3 id="ARPANET公开亮相"><a href="#ARPANET公开亮相" class="headerlink" title="ARPANET公开亮相"></a>ARPANET公开亮相</h3><p><strong>1972年10月，ARPANET公开亮相</strong>。在华盛顿举行的第一届国际计算机与通信会议上，ARPA的科学家们演示了这个系统：<strong>将来自40个不同地点的计算机连接在一起</strong>。</p><h3 id="ARPANET发展"><a href="#ARPANET发展" class="headerlink" title="ARPANET发展"></a>ARPANET发展</h3><p>与此同时，美国国防部高级研究计划局(ARPA)的科学家们正在改进该系统，扩大其能力。</p><ul><li><p>1972年，他们成功地采用了一种新的程序，即我们现在所称的<strong>电子邮件</strong>，允许在网上发送信息，允许人与人之间的直接交流。</p></li><li><p>同样在70年代早期，科学家们开发了主机(host)对主机的协议。 在此之前，系统只允许一个“远程终端”访问每个单独主机的文件。 新的协议允许访问主机的程序(在连接期间有效地将两台主机合并为一台)。  </p></li><li><p>1974年，ARPA的科学家们与斯坦福大学的专家们密切合作，开发出一种使不同的网络能够相互交流的“共同语言”。这被称为**传输控制协议/互联网协议(TCP/IP)**。</p><blockquote><p>TCP/IP的发展标志着网络发展的一个关键阶段，现如今使用最广泛的协议仍然是TCP/IP协议，其分层、解耦合的设计是他生命力所在。</p></blockquote></li></ul><h3 id="各种NET的”百家争鸣”"><a href="#各种NET的”百家争鸣”" class="headerlink" title="各种NET的”百家争鸣”"></a>各种NET的”百家争鸣”</h3><p>前面讲到ARPANET的公开亮相，激发了整个西方世界科学界对互联网的进一步的研究。很快其他的网络也出现了。在这个阶段，各类网络各自为战，提出了自己的技术和协议。华盛顿会议还成立了一个互联工作组(IWG，Internetworking Working Group)来协调正在进行的研究。例如：</p><ul><li>1974年，斯坦福大学开通了<strong>Telenet</strong>，这是第一个公开访问的公共“分组数据服务”(ARPANET的商业版本)。</li><li>上世纪70年代，美国能源部为磁性聚变能的研究人员建立了<strong>MFENet</strong>，这催生了致力于高能物理的HEPNet。这启发了NASA的物理学家们建立了空间物理学家<strong>SPAN</strong>。</li><li>1976年，美国电话电报公司贝尔实验室开发了一种<strong>Unix-to-Unix协议</strong>，并免费分发给所有使用Unix的计算机用户(因为Unix是大学使用的主要操作系统，这为学术界打开了网络的大门)。</li><li>在1979年<strong>Usenet</strong>建立，一个开放的系统专注于电子邮件通信和致力于“新闻组”的开放，并仍然蓬勃发展到今天。</li><li>在1981年，纽约城市大学开发了<strong>Bitnet</strong>，用来连接美国东部大学的科学家，使用IBM计算机，不管学科。</li><li><strong>CSNet</strong>由美国国家科学基金会资助，旨在促进大学、工业和政府计算机科学家的交流。</li><li>1982年，欧洲版本的Unix网络<strong>Eunet</strong>建立，连接了英国、斯堪的纳维亚和荷兰的网络。</li><li>1984年又建立了欧洲版本的Bitnet，称为<strong>EARN</strong>(欧洲学术和研究网络)。 </li></ul><p>在这一时期，世界仍然相当混乱，有过多的相互竞争的技术和协议。<strong>ARPANET仍然是整个系统的主干。</strong></p><p><img src="https://www.let.leidenuniv.nl/history/ivh/arpanet2.gif" alt="ARPANET (1980)"></p><h3 id="TCP-IP一统天下"><a href="#TCP-IP一统天下" class="headerlink" title="TCP/IP一统天下"></a>TCP/IP一统天下</h3><p>虽然1974年标志着TCP/IP协议的开始，但它需要经过几年的修改和重新设计，才得以竞争和普遍采用。例如，在20世纪70年代中期，已经设计了一个简化版，可以并入正在开发的新型微型计算机中。第二个设计挑战是开发一个与每个计算机网络(包括阿帕网本身)兼容的软件版本。</p><p>最终在1982年， TCP/IP 协议统一了天下，成为了标准，<strong>使用TCP/IP标准的互联网诞生了！</strong></p><p>下一期，我们将讲述：从Internet到WWW，从因特网到万维网。敬请关注</p><h3 id="参考连接："><a href="#参考连接：" class="headerlink" title="参考连接："></a>参考连接：</h3><p>‌[1] <a href="https://www.let.leidenuniv.nl/history/ivh/chap2.htm#The%20Creation%20of%20ARPANET">Chapter Two: From ARPANET to World Wide Web</a> , </p><p>[‌2] <a href="https://baijiahao.baidu.com/s?id=1639113082776464538&wfr=spider&for=pc">关于互联网的由来和发展简史</a></p><hr><p> 欢迎关注我的微信公众号，扫描下方二维码，就可以找到我，我会持续为你分享 IT 技术和珠宝知识。</p><p><img src="https://pic1.zhimg.com/80/v2-8ff04a9934840c3c552ed41497bc4748_720w.jpg" alt="欢迎关注我的微信公众号，扫描下方二维码，就可以找到我，我会持续为你分享 IT 技术和珠宝知识"></p><p>也可以关注我的个人博客</p><p><a href="https://dianwoshishi.github.io/">点我试试的个人博客</a></p>]]></content>
    
    
    <summary type="html">今日珠宝



原文为知乎，现转移到个人博客。
知乎原文

原文为微信公众号文章，现转移到个人博客。
微信公众号原文

互联网发展简史(2) 从ARPANET到Internet
ARPANET公开亮相
1972年10月，ARPANET公开亮相。在华盛顿举行的第一届国际计算机与通信会议上，ARPA的科学家们演示了这个系统：将来自40个不同地点的计算机连接在一起。

ARPANET发展
与此同时，美国国防部高级研究计划局(ARPA)的科学家们正在改进该系统，扩大其能力。

 * 1972年，他们成功地采用了一种新的程序，即我们现在所称的电子邮件，允许在网上发送信息，允许人与人之间的直接交流。
  </summary>
    
    
    
    <category term="总结" scheme="http://dianwoshishi.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="互联网" scheme="http://dianwoshishi.github.io/tags/%E4%BA%92%E8%81%94%E7%BD%91/"/>
    
    <category term="历史" scheme="http://dianwoshishi.github.io/tags/%E5%8E%86%E5%8F%B2/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统下的系统资源和网络资源控制</title>
    <link href="http://dianwoshishi.github.io/2021/05/30/%E8%B5%84%E6%BA%90%E4%BF%9D%E9%9A%9C/"/>
    <id>http://dianwoshishi.github.io/2021/05/30/%E8%B5%84%E6%BA%90%E4%BF%9D%E9%9A%9C/</id>
    <published>2021-05-29T16:00:00.000Z</published>
    <updated>2021-06-03T01:55:23.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="今日珠宝"><a href="#今日珠宝" class="headerlink" title="今日珠宝"></a>今日珠宝</h2><p>宝格丽BVLGARI系列戒指</p><p>18K玫瑰金材质镶嵌7颗钻石，非常经典优雅的设计风格。指圈大小63号（正品实拍）</p><p><img src="https://pic1.zhimg.com/80/v2-a78042ef069ac261a2b24c645c26204c_720w.jpg" alt="宝格丽BVLGARI系列戒指"></p><p>原文为<a href="https://zhuanlan.zhihu.com/p/376501404">知乎</a>，现转移到个人博客。<br><a href="https://zhuanlan.zhihu.com/p/376501404" target="_blank" class="LinkCard">知乎原文</a></p><h1 id="Linux系统下的系统资源和网络资源控制"><a href="#Linux系统下的系统资源和网络资源控制" class="headerlink" title="Linux系统下的系统资源和网络资源控制"></a>Linux系统下的系统资源和网络资源控制</h1><p>众所周知，在互联网诞生之初都是各个高校和科研机构相互通讯，并没有网络流量控制方面的考虑和设计，IP协议的原则是尽可能好地为所有数据流服务，不同的数据流之间是平等的。然而多年的实践表明，这种原则并不是最理想的，有些数据流应该得到特别的照顾， 比如，远程登录的交互数据流应该比数据下载有更高的优先级。</p><p>同样，我们希望操作系统内的资源也是不平等的，我们总是希望某些进程占用更多的资源，以满足我们当前最迫切的需求，比如看电影的时候，我们希望视频播放器更多的资源，而不希望这个时候浏览器占用过多的资源。</p><p>因此细粒度的对操作系统资源的控制是我们每一个人都想做的事，自己的地盘自己做主。</p><h2 id="限制系统资源"><a href="#限制系统资源" class="headerlink" title="限制系统资源"></a>限制系统资源</h2><p>在Linux上限制系统资源主要使用的工具是<code>cgroup</code>.</p><p>基本语法不在赘述，相关文章很多<code>见参考资料</code>。我们想限制的系统资源主要是CPU，内存还有IO设备(例如，硬盘读写速度)。在Linux系统中，这些资源的分配和管理都由相应目录<code>/cgroup/cpu/,/cgroup/memory ,/cgroup/blkio</code>下配置。下面举例进行说明：例如你想建一个cpu控制策略，取名为<code>foo</code>,则你只需要在目录<code>/cgroup/cpu/</code>中<code>mkdir foo</code>，操作系统会为你创造一些列文件，就可以用操作文件的方式控制你的系统了。如下例：</p><h3 id="cpu限制实例"><a href="#cpu限制实例" class="headerlink" title="cpu限制实例"></a><strong>cpu限制实例</strong></h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">1. [root@localhost &#x2F;]# mkdir -p &#x2F;cgroup&#x2F;cpu&#x2F;foo&#x2F; 2. [root@localhost &#x2F;]# mkdir -p &#x2F;cgroup&#x2F;cpuset&#x2F;foo&#x2F; 3. [root@localhost &#x2F;]# echo 50000 &gt; &#x2F;cgroup&#x2F;cpu&#x2F;foo&#x2F;cpu.cfs_quota_us 4. [root@localhost &#x2F;]# echo 100000 &gt; &#x2F;cgroup&#x2F;cpu&#x2F;foo&#x2F;cpu.cfs_period_us 5. [root@localhost &#x2F;]# echo &quot;0&quot; &gt; &#x2F;cgroup&#x2F;cpuset&#x2F;foo&#x2F;cpuset.mems 6. [root@localhost &#x2F;]# echo &quot;1&quot; &gt; &#x2F;cgroup&#x2F;cpuset&#x2F;foo&#x2F;cpuset.cpus 7. [root@localhost &#x2F;]# echo 28819 &gt; &#x2F;cgroup&#x2F;cpu&#x2F;foo&#x2F;tasks  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="内存限制实例"><a href="#内存限制实例" class="headerlink" title="内存限制实例"></a><strong>内存限制实例</strong></h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">1. [root@localhost &#x2F;]# mkdir -p &#x2F;cgroup&#x2F;memory&#x2F;foo 2. [root@localhost &#x2F;]# echo &gt; &#x2F;cgroup&#x2F;memory&#x2F;foo&#x2F;memory.limit_in_bytes 3. [root@localhost &#x2F;]# echo 44476 &gt; &#x2F;cgroup&#x2F;memory&#x2F;foo&#x2F;tasks  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>内存参数</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">cgroup.event_control       #用于eventfd的接口memory.usage_in_bytes      #显示当前已用的内存memory.limit_in_bytes      #设置&#x2F;显示当前限制的内存额度memory.failcnt             #显示内存使用量达到限制值的次数memory.max_usage_in_bytes  #历史内存最大使用量memory.soft_limit_in_bytes #设置&#x2F;显示当前限制的内存软额度memory.stat                #显示当前cgroup的内存使用情况memory.use_hierarchy       #设置&#x2F;显示是否将子cgroup的内存使用情况统计到当前cgroup里面memory.force_empty         #触发系统立即尽可能的回收当前cgroup中可以回收的内存memory.pressure_level      #设置内存压力的通知事件，配合cgroup.event_control一起使用memory.swappiness          #设置和显示当前的swappinessmemory.move_charge_at_immigrate #设置当进程移动到其他cgroup中时，它所占用的内存是否也随着移动过去memory.oom_control         #设置&#x2F;显示oom controls相关的配置memory.numa_stat           #显示numa相关的内存<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h3 id="IO限制实例"><a href="#IO限制实例" class="headerlink" title="IO限制实例"></a><strong>IO限制实例</strong></h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">1. [root@localhost ~]# mkdir -p &#x2F;cgroup&#x2F;blkio&#x2F;foo 2. [root@localhost ~]# echo &#39;8:0  10485760&#39; &gt; &#x2F;cgroup&#x2F;blkio&#x2F;foo&#x2F;blkio.throttle.read_bps_device 3. [root@localhost ~]# echo 45033 &gt; &#x2F;cgroup&#x2F;blkio&#x2F;foo&#x2F;tasks #  注2：8:0对应主设备号和副设备号，可以通过ls -l &#x2F;dev&#x2F;sda查看<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="一个限制内存和CPU的具体例子"><a href="#一个限制内存和CPU的具体例子" class="headerlink" title="一个限制内存和CPU的具体例子"></a>一个限制内存和CPU的具体例子</h3><p>之前在学习cgroup的时候，较多的都是减少原理和一些简单的例子，但这对直观的取理解cgroup还是有点障碍，所以学习的过程中，参考他人的博客结合自己的理解写了一个例子，供大家参考。</p><p>例子分为两个部分</p><h4 id="0x01-被限制应用"><a href="#0x01-被限制应用" class="headerlink" title="0x01 被限制应用"></a>0x01 被限制应用</h4><p>被限制应用是一个CPU消耗型，具体见下面代码</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> i<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>直接编译，假如这里编译出的程序名为<code>deadloop</code>, <code>top</code>查看如下：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"> PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND     31404 root  20   0    4220    656    588 R  98.7  0.0   8:45.27 deadloop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="0x02-限制规则"><a href="#0x02-限制规则" class="headerlink" title="0x02 限制规则"></a>0x02 限制规则</h4><p>这里我们做两个方面的工作：限制CPU使用率和限制内存。具体代码如下：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 增加规则代码#!&#x2F;bin&#x2F;bash# 规则集合在testdeadgname&#x3D;&#39;testdead&#39;value&#x3D;50000prog&#x3D;$1mem_val&#x3D;1024000rmdir &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu&#x2F;$&#123;gname&#125;;rmdir &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memory&#x2F;$gname;mkdir &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu&#x2F;$gname;mkdir &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memory&#x2F;$gname;echo $value | sudo tee &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu&#x2F;$gname&#x2F;cpu.cfs_quota_us;echo $mem_val | sudo tee &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memory&#x2F;$gname&#x2F;memory.limit_in_bytes;for x in $(pidof $prog)do echo $x  | sudo tee &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu&#x2F;$gname&#x2F;tasks;echo $x | sudo tee &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memory&#x2F;$gname&#x2F;tasksecho 0 | sudo tee &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memory&#x2F;$gname&#x2F;memory.swappinessdone<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 删除规则代码#!&#x2F;bin&#x2F;bashdname&#x3D;testdeadcgdelete cpu:$dname<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述规则应用后，<code>top</code>查看如下：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">31404 root  20   0    4220    656    588 R  49.8  0.0   8:08.46 deadloop   <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看出，两次的CPU使用率不一样，显示出了cgroup的限制效果。</p><h2 id="限制网络资源"><a href="#限制网络资源" class="headerlink" title="限制网络资源"></a>限制网络资源</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>Linux操作系统中，报文分组从输入网卡(入口)接收进来，经过路由的查找， 以确定是发给本机的，还是需要转发的。如果是发给本机的，就直接向上递交给上层的协议，比如TCP，如果是转发的， 则会从输出网卡(出口)发出。网络流量的控制通常发生在输出网卡处。虽然在路由器的入口处也可以进行流量控制，Linux也具有相关的功能， 但一般说来， 由于我们无法控制自己网络之外的设备， 入口处的流量控制相对较难。本文将集中介绍出口处的流量控制。</p><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p>流量控制（<code>Traffic Control</code>， <code>tc</code>）是<code>Linux</code>内核提供的流量限速、整形和策略控制机制。它以<code>qdisc-class-filter</code>的树形结构来实现对流量的分层控制</p><p>在Linux中，流量控制都是通过TC这个工具来完成的。通常， 要对网卡进行流量控制的配置，需要进行如下的步骤:</p><ul><li><p>为网卡配置一个队列;</p></li><li><p>在该队列上建立分类;</p></li><li><p>根据需要建立子队列和子分类;</p></li><li><p>为每个分类建立过滤器。</p></li></ul><p><img src="/2021/05/30/%E8%B5%84%E6%BA%90%E4%BF%9D%E9%9A%9C/tc2.jpeg" alt="Traffic Control"></p><h3 id="基本组成"><a href="#基本组成" class="headerlink" title="基本组成"></a>基本组成</h3><p>从上图中可以看到，tc由<code>qdisc</code>、<code>fitler</code>和<code>class</code>三部分组成：</p><ul><li><p><code>qdisc</code>通过队列将数据包缓存起来，用来控制网络收发的速度</p><ul><li>常见的classless qdisc有：choke, codel, p/bfifo,fq, fq_codel, gred, hhf, ingress,mqprio, multiq, netem, pfifo_fast, pie, red, rr, sfb, sfq, tbf。linux默认使用的就是fifo_fast。</li><li>常见的classful qdisc有：ATM, CBQ, DRR, DSMARK, HFSC, HTB, PRIO, QFQ</li></ul></li><li><p><code>class</code>用来表示控制策略</p><ul><li><p>分类只存在于可分类排队规则（classful qdisc）（例如，HTB和CBQ）中。</p></li><li><blockquote><p><strong>default</strong> 这是HTB排队规则的一个可选参数，默认值为0， 当值为0时意味着会绕过所有和rootqdisc相关联的分类，然后以最大的速度出队任何未分类的流量。 </p><p><strong>rate</strong> 这个参数用来设置流量发送的最小期望速率。这个速率可以被当作承诺信息速率(CIR), 或者给某个叶子分类的保证带宽。 </p><p><strong>ceil</strong> 这个参数用来设置流量发送的最大期望速率。租借机制将会决定这个参数的实际用处。 这个速率可以被称作“突发速率”。 </p><p><strong>burst</strong> 这个参数是rate桶的大小(参见令牌桶这一节)。HTB将会在更多令牌到达之前将burst个字节的数据包出队。 </p><p><strong>cburst</strong> 这个参数是ceil桶的大小（参见令牌桶这一节）。HTB将会更多令牌(ctoken)到达之前将cburst个字节的数据包出队。 </p><p><strong>quantum</strong> 这个是HTB控制租借机制的关键参数。正常情况下，HTB自己会计算合适的quantum值，而不是由用户来设定。对这个值的轻微调整都会对租借和整形造成巨大的影响，因为HTB不仅会根据这个值向各个子分类分发流量(速率应高于rate，小于ceil)，还会根据此值输出各个子分类中的数据。 </p><p><strong>r2q</strong> 通常,quantum 的值由HTB自己计算，用户可以通过此参数设置一个值来帮助HTB为某个分类计算一个最优的quantum值。</p></blockquote></li></ul></li><li><p><code>filter</code>用来将数据包划分到具体的控制策略中</p><ul><li>包含了一个分类器实现，常见的分类器如u32，u32分类器可以允许用户基于数据包的属性来选择数据包。</li></ul></li></ul><p>语法不再赘述，相关参考资料里有。</p><h3 id="入流量调度"><a href="#入流量调度" class="headerlink" title="入流量调度"></a>入流量调度</h3><p>Linux中的QoS分为入口(Ingress)部分和出口(Egress)部分，入口部分主要用于进行入口流量限速(policing)，出口部分主要用于队列调度(queuing scheduling)。</p><p>大多数排队规则(qdisc)都是用于输出方向的，输入方向只有一个排队规则，即ingress qdisc。ingress qdisc本身的功能很有限，但可用于重定向incoming packets。通过Ingress qdisc把输入方向的数据包重定向到虚拟设备ifb，而ifb的输出方向可以配置多种qdisc，就可以达到对输入方向的流量做队列调度的目的。</p><p><img src="/2021/05/30/%E8%B5%84%E6%BA%90%E4%BF%9D%E9%9A%9C/1354528849_1019.png" alt="输入流量调度示意"></p><p>IFB说明：</p><blockquote><p>IFB — Intermediate Functional Block device。<br>Q: How can we use qdisc (e.g., netem) on incoming traffic?<br>A: You need to use IFB. This network device allows attaching queueing disciplines to incoming packets.<br>To use an IFB, you must have IFB support in your kernel (configuration option CONFIG_IFB). Assuming that you have a modular kernel, the name of the IFB module is ifb and may be loaded using the command <code>modprobe ifb</code> (if you have modprobe installed) or <code>insmod /path/to/module/ifb</code>.</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">ip link set ifb0 upip link set ifb1 up<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>By default, two IFB devices(ifb0 and ifb1) are created.<br>IFB allows for queueing incoming traffic for shaping instead of dropping.</p><p>参考资料:<a href="https://blog.csdn.net/eydwyz/article/details/53392227">https://blog.csdn.net/eydwyz/article/details/53392227</a></p></blockquote><h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#!&#x2F;bin&#x2F;bash#fb驱动并创建ifb网卡(使用ifconfig -a 如果看到已有则无需该步骤)#分别为出设备和入设备outdevice&#x3D;ens33indevice&#x3D;ifb0modprobe ifb numifbs&#x3D;1# up网卡ip link set dev $indevice up# ------# 清除原有的根队列(根据实际情况操作,非必要) tc qdisc del dev $outdevice root 2&gt;&#x2F;dev&#x2F;nulltc qdisc del dev $outdevice ingress 2&gt;&#x2F;dev&#x2F;nulltc qdisc del dev $indevice root 2&gt;&#x2F;dev&#x2F;null #  将$outdevice的ingress流量全部重定向到 $indevice 处理tc qdisc add dev $outdevice handle ffff: ingresstc filter add dev $outdevice parent ffff: protocol ip u32 match u32 0 0 action mirred egress redirect dev $indevice # $outdevice的出向限速:$outdevice添加根队列,使用htb,添加1:1类,使用htb tc qdisc add dev $outdevice root handle 1: htb r2q 625 default 65tc class add dev $outdevice parent 1: classid 1:1 htb rate 1000Mbit # $outdevice的入向限速:$indevice添加根队列,使用htb,添加1:1类,使用htb tc qdisc add dev $indevice root handle 1: htb r2q 625 default 65tc class add dev $indevice parent 1: classid 1:1 htb rate 1000Mbit # $outdevice的出向限速:$outdevice设备添加子类\对应的filter配置规则和子类的队列tc class add dev $outdevice parent 1:1 classid 1:10 htb rate 10Mbittc filter add dev $outdevice parent 1: protocol all prio 1 u32 match ip dst 192.168.0.2 classid 1:10tc qdisc add dev $outdevice parent 1:10 handle 10: sfq # $outdevice的出向限速:$outdevice设备添加子类\对应的filter配置规则和子类的队列 tc class add dev $outdevice parent 1:1 classid 1:11 htb rate 20Mbittc filter add dev $outdevice parent 1: protocol all prio 1 u32 match ip dst 192.168.0.3 classid 1:11tc qdisc add dev $outdevice parent 1:11 handle 11: sfq  # $outdevice的入向限速:$indevice设备添加子类\对应的filter配置规则和子类的队列tc class add dev $indevice parent 1:1 classid 1:10 htb rate 10Mbittc filter add dev $indevice parent 1: protocol all prio 1 u32 match ip src 192.168.0.2 classid 1:10tc qdisc add dev $indevice parent 1:10 handle 10: sfq  # $outdevice的入向限速:$indevice设备添加子类\对应的filter配置规则和子类的队列 tc class add dev $indevice parent 1:1 classid 1:11 htb rate 20Mbittc filter add dev $indevice parent 1: protocol all prio 1 u32 match ip src 192.168.0.3 classid 1:11tc qdisc add dev $indevice parent 1:11 handle 11: sfq<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="网络压力测试"><a href="#网络压力测试" class="headerlink" title="网络压力测试"></a>网络压力测试</h3><p>压力测试工具使用<code>iperf网络测试工具</code></p><blockquote><p>常用参数指南（详见附录）：</p><p>-c/s：客户端模式/服务端模式</p><p>-p：指定iperf测试端口</p><p>-i：指定报告间隔</p><p>-b：设置UDP的发送带宽，单位bit/s</p><p>-t：设置测试的时长，单位为秒，不设置默认10s</p><p>-l：指定包大小，TCP默认8k，UDP默认1470字节</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 针对TCP进行带宽性能测试#服务端命令：iperf -s -i 1 -p 3389#iperf -c 192.168.158.128 -p 3389 -i 1#针对UDP进行带宽性能测试#服务端命令iperf -u -s -i 1 -p 3389#客户端命令iperf -u -c 192.168.158.128 -p 3389 -b 1500M -i 1 # 参考资料：iperf网络测试工具， https:&#x2F;&#x2F;cloud.tencent.com&#x2F;developer&#x2F;article&#x2F;1688469<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>带宽查看使用工具<code>iftop</code></p><blockquote><pre><code>TX：发送流量RX：接收流量TOTAL：总流量Cumm：运行iftop到目前时间的总流量peak：流量峰值rates：分别表示过去 2s 10s 40s 的平均流量</code></pre></blockquote><p>执行脚本前后，对于网络带宽进行检测，发现流量带宽明显受到TC的控制。实验成功。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文通过对Linux操作系统中<code>cgroup</code>、<code>tc</code>的使用，实现了对Linux操作系统中系统资源和网络资源的控制。本文的方法和工具在写作过程中可能还有用到，但是没有写进来的，欢迎大家留言或通过微信公众号联系我，我会尽力为大家解答。</p><h2 id="其他补充"><a href="#其他补充" class="headerlink" title="其他补充"></a>其他补充</h2><h3 id="如何获取进程ID"><a href="#如何获取进程ID" class="headerlink" title="如何获取进程ID"></a>如何获取进程ID</h3><h4 id="根据进程名称获取pid"><a href="#根据进程名称获取pid" class="headerlink" title="根据进程名称获取pid"></a>根据进程名称获取pid</h4><p> 最简单的方法是使用 <strong>pidof</strong> 命令，用法：pidof  process_name，例如：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 查看初始进程的pidpidof init# <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>有事可能因为同一个名称的程序启动了多个进程，使用pidof时会返回多个pid，使用空格分开</p><h4 id="查找当前激活状态的网络链接及进程ID"><a href="#查找当前激活状态的网络链接及进程ID" class="headerlink" title="查找当前激活状态的网络链接及进程ID"></a>查找当前激活状态的网络链接及进程ID</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">lsof -i -n（不反向解析DNS）# eglsof -i -n | awk   &#39;&#123;print $2, $9&#125;&#39;# 输出为#PID NAME#29646 192.168.153.129:51044-&gt;13.250.177.223:https#29646 192.168.153.129:52970-&gt;54.149.208.57:httpslsof -i -n -P  | awk &#39;&#123;print $1, $2,$5,$9&#125;&#39;# 输出时，不解析端口，应该将https-&gt;443<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p>Linux 资源隔离机制 – CGroup <a href="https://zhuanlan.zhihu.com/p/47590418">https://zhuanlan.zhihu.com/p/47590418</a></p><p><a href="https://www.cnblogs.com/caoxiaojian/p/5633430.html">CGroup 介绍、应用实例及原理描述</a> <a href="https://www.cnblogs.com/caoxiaojian/p/5633430.html">https://www.cnblogs.com/caoxiaojian/p/5633430.html</a></p><p>流量控制 <a href="https://tonydeng.github.io/sdn-handbook/linux/tc.html">https://tonydeng.github.io/sdn-handbook/linux/tc.html</a></p><p>Traffic Control HOWTO <a href="https://tldp.org/HOWTO/Traffic-Control-HOWTO/">https://tldp.org/HOWTO/Traffic-Control-HOWTO/</a></p><p>Linux TC(Traffic Control)框架原理解析， <a href="https://blog.csdn.net/dog250/article/details/40483627">https://blog.csdn.net/dog250/article/details/40483627</a></p><p> <a href="https://www.cnblogs.com/yulia/p/10346339.html">linux下使用tc(Traffic Control) 流量控制命令模拟网络延迟和丢包</a></p><p>TC流量控制 <a href="https://blog.csdn.net/who538592/article/details/79483323">https://blog.csdn.net/who538592/article/details/79483323</a></p>]]></content>
    
    
    <summary type="html">今日珠宝
宝格丽BVLGARI系列戒指

18K玫瑰金材质镶嵌7颗钻石，非常经典优雅的设计风格。指圈大小63号（正品实拍）



原文为知乎，现转移到个人博客。
知乎原文

Linux系统下的系统资源和网络资源控制
众所周知，在互联网诞生之初都是各个高校和科研机构相互通讯，并没有网络流量控制方面的考虑和设计，IP协议的原则是尽可能好地为所有数据流服务，不同的数据流之间是平等的。然而多年的实践表明，这种原则并不是最理想的，有些数据流应该得到特别的照顾， 比如，远程登录的交互数据流应该比数据下载有更高的优先级。

同样，我们希望操作系统内的资源也是不平等的，我们总是希望某些进程占用更多的资源，以满</summary>
    
    
    
    <category term="学习" scheme="http://dianwoshishi.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Linux" scheme="http://dianwoshishi.github.io/tags/Linux/"/>
    
    <category term="系统管理" scheme="http://dianwoshishi.github.io/tags/%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/"/>
    
    <category term="网络管理" scheme="http://dianwoshishi.github.io/tags/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>互联网发展简史(1)ARPANET的建立</title>
    <link href="http://dianwoshishi.github.io/2021/05/30/%E4%BA%92%E8%81%94%E7%BD%91%E5%8F%91%E5%B1%95%E7%AE%80%E5%8F%B2(1)/"/>
    <id>http://dianwoshishi.github.io/2021/05/30/%E4%BA%92%E8%81%94%E7%BD%91%E5%8F%91%E5%B1%95%E7%AE%80%E5%8F%B2(1)/</id>
    <published>2021-05-29T16:00:00.000Z</published>
    <updated>2021-06-01T15:51:13.119Z</updated>
    
    <content type="html"><![CDATA[<p>原文为<a href="https://zhuanlan.zhihu.com/p/376627686">知乎</a>，现转移到个人博客。<br><a href="https://zhuanlan.zhihu.com/p/376627686" target="_blank" class="LinkCard">知乎原文</a></p><p>原文为<a href="https://mp.weixin.qq.com/s/eiYEhlHfRICdkzf2aXxCDg">微信公众号原文</a>，现转移到个人博客。<br><a href="https://mp.weixin.qq.com/s/eiYEhlHfRICdkzf2aXxCDg" target="_blank" class="LinkCard">微信公众号原文</a></p><h2 id="互联网发展简史-1-ARPANET的建立"><a href="#互联网发展简史-1-ARPANET的建立" class="headerlink" title="互联网发展简史(1)ARPANET的建立"></a>互联网发展简史(1)ARPANET的建立</h2><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>[TOC]</p><p>Internet发展简史（ARPANET的建立）</p><h3 id="1955年"><a href="#1955年" class="headerlink" title="1955年"></a>1955年</h3><p>要了解互联网的起源，我们必须回到1957年。这一年大家都致力于收集有关高层大气在一个强烈的太阳活动时期的信息。1955年，艾森豪威尔宣布，作为活动的一部分，美国希望发射一颗小型地球轨道卫星。克里姆林宫宣布也希望这样做。美国的计划集中在精密的三级火箭上，但在俄罗斯他们采取了更直接的方法。把四枚军用火箭绑在一起。苏联的行为似乎一夜之间消除了自13年前第一颗核弹爆炸以来，美国一直享有的无懈可击的感觉。立即的反应之一是在国防部内设立了高级研究计划局。它的任务是将最先进的技术应用于美国国防，并避免(再次)被敌人的技术进步吓到。在1958年10月美国国家航空航天局成立之前，它还被授予了美国卫星计划的临时控制权。</p><p>‌ARPA成为了美国国防努力的技术智囊团，直接雇佣了几百名顶级科学家，并拥有足够的预算将研究分包给美国其他顶级机构。尽管先进的计算技术将主导其工作，但ARPA最初的活动重点是空间、弹道导弹和核试验监测。即便如此，从一开始，ARPA就对它的操作基地和它的分包商之间的通信很感兴趣，最好是通过各种计算机之间的直接连接。</p><h3 id="1962年"><a href="#1962年" class="headerlink" title="1962年"></a>1962年</h3><p>1962年，ARPA启动了一个计算机研究项目，并任命麻省理工学院(MIT)的科学家约翰·利克利德(John Licklider)为负责人。利克里德刚刚发表了他关于“银河网络”概念的第一份备忘录<strong>……一个未来的愿景，电脑将联网，并将接近每个人。</strong>在ARPA内部，Leonard Klienrock已经在研究如何将信息分解成“数据包”，将它们分别发送到目的地，然后在另一端重新组装。这将比打开一行并通过该行发送信息更具灵活性。例如，系统将不依赖于单个路由，如果文件在传输前被破坏，将更难以被窃听……两者都有有用的安全优势。1965年，人们发现了电话网络在运行程序和传输数据方面的不足。当时，伯克利和麻省理工学院的计算机通过低速拨号电话线连接起来，成为有史以来第一个“广域网”(WAN)。</p><p>‌到1966/67年，研究工作已经发展到足以让计算机研究部的新主管伦纳德·罗伯茨(Leonard Roberts)发布了一个名为阿帕网(ARPANET)的计算机网络系统计划。当这些计划发表显然是彼此独立的,和无知的彼此的工作,团队在麻省理工学院,国家物理实验室(英国),兰德公司都致力于广泛的区域网络的可行性,及其最佳创意纳入阿帕网的设计。最后的要求是设计一个允许计算机发送和接收消息和数据的协议，称为接口消息处理器(IMPs)。这方面的工作在1968年完成。</p><h3 id="‌1969年"><a href="#‌1969年" class="headerlink" title="‌1969年"></a>‌1969年</h3><p>‌美军在ARPA（阿帕网，美国国防部研究计划署）制定的协定，该协定下将美国西南部的大学UCLA(加利福尼亚大学洛杉矶分校)、Stanford ResearchInstitute(斯坦福大学研究学院)、UCSB(加利福尼亚大学)和UniversityofUtah(犹他州大学)的四台主要计算机相连，形成了互联网最初的样子。</p><p><img src="https://www.let.leidenuniv.nl/history/ivh/arpanet.gif" alt="ARPANET(1969)"></p><h3 id="1971年"><a href="#1971年" class="headerlink" title="1971年"></a>1971年</h3><p>这个协定有剑桥大学的BBN和MA执行，在1969年12月开始联机。到1970年6月，MIT(麻省理工学院)、Harvard(哈佛大学)、BBN和SystemsDevelopmentCorpinSantaMonica(加州圣达莫尼卡系统发展公司)加入进来。到1972年1月，Stanford(斯坦福大学)、MIT’sLincolnLabs(麻省理工学院的林肯实验室)、Carnegie-Mellon(卡内基梅隆大学)和Case-WesternReserveU加入进来。紧接着的几个月内NASA/Ames(国家航空和宇宙航行局)、Mitre、Burroughs、RAND(兰德公司)和theUofIllinois(伊利诺利州大学)也加入进来。到1971年12月，阿帕网将23台主机相互连接起来。由此，<strong>ARPAnet成为现代计算机网络诞生的标志。</strong></p><p><img src="https://www.let.leidenuniv.nl/history/ivh/arpanet1.gif" alt="ARPANET(1971)"></p><p>自此第一个真正的计算机网络诞生。</p><p>‌</p><h3 id="参考连接："><a href="#参考连接：" class="headerlink" title="参考连接："></a>参考连接：</h3><p>‌[1] <a href="https://www.let.leidenuniv.nl/history/ivh/chap2.htm#The%20Creation%20of%20ARPANET">Chapter Two: From ARPANET to World Wide Web</a> , </p><p>[‌2] <a href="https://baijiahao.baidu.com/s?id=1639113082776464538&wfr=spider&for=pc">关于互联网的由来和发展简史</a></p><p>欢迎关注我的微信公众号，扫描下方二维码，就可以找到我，我会持续为你分享 IT 技术和珠宝知识。</p><p><img src="https://pic1.zhimg.com/80/v2-8ff04a9934840c3c552ed41497bc4748_720w.jpg" alt="欢迎关注我的微信公众号，扫描下方二维码，就可以找到我，我会持续为你分享 IT 技术和珠宝知识"></p><p>也可以关注我的个人博客</p><p><a href="https://dianwoshishi.github.io/">点我试试的个人博客</a></p>]]></content>
    
    
    <summary type="html">原文为知乎，现转移到个人博客。
知乎原文

原文为微信公众号原文，现转移到个人博客。
微信公众号原文

互联网发展简史(1)ARPANET的建立
目录
[TOC]

Internet发展简史（ARPANET的建立）

1955年
要了解互联网的起源，我们必须回到1957年。这一年大家都致力于收集有关高层大气在一个强烈的太阳活动时期的信息。1955年，艾森豪威尔宣布，作为活动的一部分，美国希望发射一颗小型地球轨道卫星。克里姆林宫宣布也希望这样做。美国的计划集中在精密的三级火箭上，但在俄罗斯他们采取了更直接的方法。把四枚军用火箭绑在一起。苏联的行为似乎一夜之间消除了自13年前第一颗核弹爆炸以来，美</summary>
    
    
    
    <category term="总结" scheme="http://dianwoshishi.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="互联网" scheme="http://dianwoshishi.github.io/tags/%E4%BA%92%E8%81%94%E7%BD%91/"/>
    
    <category term="历史" scheme="http://dianwoshishi.github.io/tags/%E5%8E%86%E5%8F%B2/"/>
    
  </entry>
  
  <entry>
    <title>基于netfilter的IP数据统计设计</title>
    <link href="http://dianwoshishi.github.io/2021/05/29/%E5%9F%BA%E4%BA%8Enetfilter%E7%9A%84IP%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E8%AE%BE%E8%AE%A1%E4%B8%8ELinux%E9%A9%B1%E5%8A%A8%E5%AE%9E%E7%8E%B0/"/>
    <id>http://dianwoshishi.github.io/2021/05/29/%E5%9F%BA%E4%BA%8Enetfilter%E7%9A%84IP%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E8%AE%BE%E8%AE%A1%E4%B8%8ELinux%E9%A9%B1%E5%8A%A8%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-05-28T16:00:00.000Z</published>
    <updated>2021-06-01T01:01:35.943Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h1><ol><li> <a href="#orgab76e7a">背景</a></li><li><a href="#org02ac451">IP信息统计</a><ol><li> <a href="#org62d4d73">统计信息设计</a></li><li> <a href="#org44f97b2">存储数据结构</a></li></ol></li><li><a href="#orgde188bf">Linux驱动</a><ol><li> <a href="#orgc0bb933">网络型驱动设备</a></li><li> <a href="#org9e48264">字符型设备</a></li><li> <a href="#org8ee7f64">用户代码</a></li></ol></li><li><a href="#org3f4753d">总结</a><ol><li> <a href="#org01bad05">Linux 驱动</a></li><li> <a href="#orgd1e6a5e">Linux内核</a></li><li> <a href="#org4c6ff33">其他</a></li></ol></li><li> <a href="#orgfe8069d">参考资料</a></li></ol><p><a id="orgab76e7a"></a></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>当今社会，没有都有自己的信息处理设备，如手机、计算机甚至可能是路由器。在使用这些设备的时候，我们想知道的一件事就是，我的电脑和那些设备有过通信，通信情况怎么样，以便在网络出现问题，如拥塞，或是自己主机被黑客控制出现异常数据的时候，能够通过上述统计信息快速定位问题所在。因此本文通过Linux驱动中的netfilter对IP数据报中的IP信息进行统计，通过字符型驱动实现用户态查看统计信息，达到了统计主机通信的目的，为进一步做好异常处理打下了基础。</p><p><a id="org02ac451"></a></p><h1 id="IP信息统计"><a href="#IP信息统计" class="headerlink" title="IP信息统计"></a>IP信息统计</h1><p><a id="org62d4d73"></a></p><h2 id="统计信息设计"><a href="#统计信息设计" class="headerlink" title="统计信息设计"></a>统计信息设计</h2><p>统计对象为源IP地址，信息内容目前设计为：IP出现频次，最后一个IP数据包出现时的时间戳。</p><pre><code>typedef struct IPData&#123;  int timestamp;  int count&#125;ipdata;</code></pre><p><a id="org44f97b2"></a></p><h2 id="存储数据结构"><a href="#存储数据结构" class="headerlink" title="存储数据结构"></a>存储数据结构</h2><p>由于在Linux Kernel中没有C++的set，map等数据结构，因此使用其提供的红黑树实现IP信息的快速存储和读取。其中红黑树节点的信息如下所示：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">   <span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">roc_node_s</span><span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">rb_node</span> node<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>ctx<span class="token punctuation">;</span>    <span class="token keyword">int</span> key<span class="token punctuation">;</span>    ipdata ipcount<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">roc_node_t</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>红黑树的实现使用Linux Kernel自带的rbtree数据结构，头文件为：</p><pre><code>#include &lt;linux/rbtree.h&gt;</code></pre><p>红黑树插入，删除等代码参考链接为：<a href="https://blog.csdn.net/chn475111/article/details/52594457">https://blog.csdn.net/chn475111/article/details/52594457</a>.</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/** * filename: my_rbtree.h * @author lijk@.infosec.com.cn * @version 0.0.1 * @date 2016-9-20 11:52:06 */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/string.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/rbtree.h></span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">IPData</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> timestamp<span class="token punctuation">;</span>  <span class="token keyword">int</span> count<span class="token punctuation">&#125;</span>ipdata<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">roc_node_s</span><span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">rb_node</span> node<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>ctx<span class="token punctuation">;</span>    <span class="token keyword">int</span> key<span class="token punctuation">;</span>    ipdata ipcount<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">roc_node_t</span><span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>roc_cb<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">roc_node_t</span><span class="token operator">*</span> <span class="token function">roc_search</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rb_root</span> <span class="token operator">*</span>root<span class="token punctuation">,</span> <span class="token keyword">int</span> key<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span>node <span class="token operator">=</span> root<span class="token operator">-></span>rb_node<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token class-name">roc_node_t</span> <span class="token operator">*</span>data <span class="token operator">=</span> <span class="token function">rb_entry</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> <span class="token class-name">roc_node_t</span><span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> result <span class="token operator">=</span> key <span class="token operator">-</span> data<span class="token operator">-></span>key<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            node <span class="token operator">=</span> node<span class="token operator">-></span>rb_left<span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>            node <span class="token operator">=</span> node<span class="token operator">-></span>rb_right<span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token keyword">return</span> data<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">roc_insert</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rb_root</span> <span class="token operator">*</span>root<span class="token punctuation">,</span> <span class="token class-name">roc_node_t</span> <span class="token operator">*</span>data<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span><span class="token operator">*</span>new <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span>root<span class="token operator">-></span>rb_node<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">*</span>parent <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">*</span>new<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token class-name">roc_node_t</span> <span class="token operator">*</span>this <span class="token operator">=</span> <span class="token function">rb_entry</span><span class="token punctuation">(</span><span class="token operator">*</span>new<span class="token punctuation">,</span> <span class="token class-name">roc_node_t</span><span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> result <span class="token operator">=</span> data<span class="token operator">-></span>key <span class="token operator">-</span> this<span class="token operator">-></span>key<span class="token punctuation">;</span>        parent <span class="token operator">=</span> <span class="token operator">*</span>new<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            new <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>new<span class="token punctuation">)</span><span class="token operator">-></span>rb_left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>            new <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>new<span class="token punctuation">)</span><span class="token operator">-></span>rb_right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">rb_link_node</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>data<span class="token operator">-></span>node<span class="token punctuation">,</span> parent<span class="token punctuation">,</span> new<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">rb_insert_color</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>data<span class="token operator">-></span>node<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">roc_erase</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rb_root</span> <span class="token operator">*</span>root<span class="token punctuation">,</span> <span class="token keyword">int</span> key<span class="token punctuation">,</span> roc_cb cb<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">roc_node_t</span> <span class="token operator">*</span>data <span class="token operator">=</span> <span class="token function">roc_search</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">rb_erase</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>data<span class="token operator">-></span>node<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">RB_CLEAR_NODE</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>data<span class="token operator">-></span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>cb<span class="token punctuation">)</span> <span class="token function">cb</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">roc_destroy</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rb_root</span> <span class="token operator">*</span>root<span class="token punctuation">,</span> roc_cb cb<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">roc_node_t</span> <span class="token operator">*</span>pos <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span>node <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>node <span class="token operator">=</span> <span class="token function">rb_first</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        pos <span class="token operator">=</span> <span class="token function">rb_entry</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> <span class="token class-name">roc_node_t</span><span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">_DEBUG</span></span>        <span class="token function">sprintf</span><span class="token punctuation">(</span>message<span class="token punctuation">,</span> <span class="token string">"key = %d\n"</span><span class="token punctuation">,</span> pos<span class="token operator">-></span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>        <span class="token function">rb_erase</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pos<span class="token operator">-></span>node<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">RB_CLEAR_NODE</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pos<span class="token operator">-></span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>cb<span class="token punctuation">)</span> <span class="token function">cb</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">roc_dump</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rb_root</span> <span class="token operator">*</span>root<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span>node <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> sip<span class="token punctuation">,</span> count<span class="token punctuation">,</span> timestamp<span class="token punctuation">;</span>  <span class="token comment">//printk("roc_dump");</span>    <span class="token function">memset</span><span class="token punctuation">(</span>message<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> MAX_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>node <span class="token operator">=</span> <span class="token function">rb_first</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">strlen</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span> <span class="token operator">&lt;</span> MAX_SIZE <span class="token operator">&amp;&amp;</span> node <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> node <span class="token operator">=</span> <span class="token function">rb_next</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  sip <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token function">rb_entry</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> <span class="token class-name">roc_node_t</span><span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token operator">-></span>key <span class="token punctuation">;</span>     count <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token function">rb_entry</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> <span class="token class-name">roc_node_t</span><span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token operator">-></span>ipcount<span class="token punctuation">.</span>count <span class="token punctuation">;</span>     timestamp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token function">rb_entry</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> <span class="token class-name">roc_node_t</span><span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token operator">-></span>ipcount<span class="token punctuation">.</span>timestamp <span class="token punctuation">;</span>    <span class="token function">sprintf</span><span class="token punctuation">(</span>message<span class="token punctuation">,</span> <span class="token string">"%s%d.%d.%d.%d|%d|%d,"</span><span class="token punctuation">,</span>message<span class="token punctuation">,</span> <span class="token function">NIPQUAD</span><span class="token punctuation">(</span> sip<span class="token punctuation">)</span><span class="token punctuation">,</span> count<span class="token punctuation">,</span> timestamp<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">//printk(message);</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">roc_free</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">roc_node_t</span> <span class="token operator">*</span>node <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">roc_node_t</span><span class="token operator">*</span><span class="token punctuation">)</span>ptr<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">-></span>ctx<span class="token punctuation">)</span> <span class="token function">kfree</span><span class="token punctuation">(</span>node<span class="token operator">-></span>ctx<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">kfree</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token keyword">const</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">rb_root</span> root <span class="token operator">=</span> RB_ROOT<span class="token punctuation">;</span>    <span class="token keyword">int</span> loop <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token class-name">roc_node_t</span> <span class="token operator">*</span>node <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>loop <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> loop <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> loop <span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        node <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">roc_node_t</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">kmalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token class-name">roc_node_t</span><span class="token punctuation">)</span><span class="token punctuation">,</span> GFP_KERNEL <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        node<span class="token operator">-></span>ctx <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        node<span class="token operator">-></span>key <span class="token operator">=</span> loop<span class="token punctuation">;</span>        <span class="token function">roc_insert</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>root<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token number">0</span></span></span>    <span class="token keyword">for</span><span class="token punctuation">(</span>loop <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> loop <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> loop <span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token function">roc_erase</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>root<span class="token punctuation">,</span> loop<span class="token punctuation">,</span> roc_free<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>    <span class="token function">roc_dump</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">roc_destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>root<span class="token punctuation">,</span> roc_free<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a id="orgde188bf"></a></p><h1 id="Linux驱动"><a href="#Linux驱动" class="headerlink" title="Linux驱动"></a>Linux驱动</h1><p>考虑在内核实现的原因是目前Linux相关设备非常多，可能具有一定的参考价值和移植性。<br>笔者的内核环境为：</p><pre><code>  uname -r4.15.0-142-generic</code></pre><p><a id="orgc0bb933"></a></p><h2 id="网络型驱动设备"><a href="#网络型驱动设备" class="headerlink" title="网络型驱动设备"></a>网络型驱动设备</h2><p>netfilter的相关参考资料为：Linnux5.0.0下，基于Netlink与NetFilter对本机数据包进行筛选监控,<a href="https://blog.csdn.net/qq_40758751/article/details/105117750">https://blog.csdn.net/qq_40758751/article/details/105117750</a> , netfilter数据包过滤, <a href="https://blog.csdn.net/specialsun/article/details/84695519">https://blog.csdn.net/specialsun/article/details/84695519</a><br>因为本文为源Ip数据包信息统计，所以netfilter hook的层级在NF<sub>INET</sub><sub>LOCAL</sub><sub>IN</sub>.<br>Hook 函数为filter<sub>http</sub>(忽略函数名，粘贴过来，不想改了).</p><p><a id="org9e48264"></a></p><h2 id="字符型设备"><a href="#字符型设备" class="headerlink" title="字符型设备"></a>字符型设备</h2><p>内核态数据在用户态访问需要通过字符型设备驱动进行。因此建立一个字符型设备/dev/IPDataSet 使得用户态能够访问内核 态的数据信息。<br>参考资料：ubuntu 添加字符设备驱动程序, <a href="https://blog.csdn.net/ARAFATms/article/details/79397800">https://blog.csdn.net/ARAFATms/article/details/79397800</a><br>因为上述驱动需要自己手动添加字符设备，所以通过以下方法自动添加设备节点。<br>参考资料：linux驱动：自动创建设备节点, <a href="https://blog.csdn.net/u012247418/article/details/83684029">https://blog.csdn.net/u012247418/article/details/83684029</a></p><pre><code>// filename: filter_ip.c#ifndef __KERNEL__#define __KERNEL__#endif  /* __KERNEL__ */#include &lt;linux/module.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/types.h&gt;#include &lt;linux/string.h&gt;//#include &lt;asm/uaccess.h&gt;#include &lt;linux/netdevice.h&gt;#include &lt;linux/netfilter_ipv4.h&gt;  // ip4 netfilter,ipv6则需引入相应 linux/netfilter_ipv6.h#include &lt;linux/ip.h&gt;#include &lt;linux/tcp.h&gt;#include &lt;linux/sched.h&gt;#include &quot;linux/kernel.h&quot;#include &quot;linux/fs.h&quot;#include &quot;linux/errno.h&quot;#include &quot;linux/uaccess.h&quot;#include &quot;linux/kdev_t.h&quot;#include &lt;linux/device.h&gt;#include &lt;linux/time.h&gt;#define NIPQUAD(addr) \  ((unsigned char *)&amp;addr)[0], \  ((unsigned char *)&amp;addr)[1], \  ((unsigned char *)&amp;addr)[2], \  ((unsigned char *)&amp;addr)[3]  #define MAX_SIZE 1024 * 1024 * 8char message[MAX_SIZE] = &quot;&quot;;  //打开设备时会显示的消息#include &quot;my_rbtree.h&quot;struct rb_root root = RB_ROOT;int insert(int key, int timestamp)&#123;  roc_node_t *node = NULL;  node = roc_search(&amp;root, key);  if(node != NULL) &#123;    node-&gt;ipcount.count++;    node-&gt;ipcount.timestamp = timestamp;    return 1;  &#125;  node = (roc_node_t*)kmalloc(sizeof(roc_node_t), GFP_KERNEL );  node-&gt;ctx = NULL;  node-&gt;key = key;  node-&gt;ipcount.count = 1;  node-&gt;ipcount.timestamp = timestamp;  return roc_insert(&amp;root, node);&#125;struct timeval time;// 过滤http数据包unsigned int filter_http(char *type,struct sk_buff *pskb)&#123;  __be32 sip,dip;  int retval = NF_ACCEPT;  int ret, ms;  struct sk_buff *skb = pskb;  struct iphdr *iph = ip_hdr(skb);  // 获取ip头  sip = iph-&gt;saddr;    dip = iph-&gt;daddr;    //printk(&quot;Packet for source address: %d.%d.%d.%d destination address: %d.%d.%d.%d\n&quot;, NIPQUAD(sip), NIPQUAD(dip));    //sprintf(message, &quot;Packet for source address: %d.%d.%d.%d destination address: %d.%d.%d.%d\n&quot;, NIPQUAD(sip), NIPQUAD(dip));  do_gettimeofday(&amp;time);  /*第一次去获取时间*/  ms = time.tv_sec * 1000 + time.tv_usec / 1000;  ret = insert(sip, ms);  //if(ret == 1)&#123;      roc_dump(&amp;root);  printk(message);  //&#125;  return retval;&#125;unsigned int NET_HookLocalIn(void *priv,     struct sk_buff *pskb,     const struct nf_hook_state *state)&#123;  return filter_http(&quot;in&quot;,pskb);&#125;unsigned int NET_HookLocalOut(void *priv,     struct sk_buff *pskb,     const struct nf_hook_state *state)&#123;  //return filter_http(&quot;out&quot;,pskb);  return NF_ACCEPT;&#125;unsigned int NET_HookPreRouting(void *priv,     struct sk_buff *pskb,     const struct nf_hook_state *state)&#123;  return NF_ACCEPT;&#125;unsigned int NET_HookPostRouting(void *priv,     struct sk_buff *pskb,     const struct nf_hook_state *state)&#123;  return NF_ACCEPT;&#125;unsigned int NET_HookForward(void *priv,     struct sk_buff *pskb,     const struct nf_hook_state *state)&#123;  return NF_ACCEPT;&#125;// 钩子数组static struct nf_hook_ops net_hooks[] = &#123;  &#123;    .hook         = NET_HookLocalIn,        // 发往本地数据包    .pf            = PF_INET,    .hooknum    =    NF_INET_LOCAL_IN,    .priority    = NF_IP_PRI_FILTER-1,  &#125;,  &#123;    .hook         = NET_HookLocalOut,        // 本地发出数据包    .pf            = PF_INET,    .hooknum    =    NF_INET_LOCAL_OUT,    .priority    = NF_IP_PRI_FILTER-1,  &#125;,  &#123;    .hook         = NET_HookForward,        // 转发的数据包    .pf            = PF_INET,    .hooknum    =    NF_INET_FORWARD,    .priority    = NF_IP_PRI_FILTER-1,  &#125;,  &#123;    .hook        = NET_HookPreRouting,    // 进入本机路由前        .pf            = PF_INET,                    .hooknum    = NF_INET_PRE_ROUTING,            .priority    = NF_IP_PRI_FILTER-1,          &#125;,  &#123;    .hook        = NET_HookPostRouting,    // 本机发出包经路由后        .pf            = PF_INET,                    .hooknum    = NF_INET_POST_ROUTING,            .priority    = NF_IP_PRI_FILTER-1,          &#125;,&#125;;int my_open(struct inode *inode, struct file *file);int my_release(struct inode *inode, struct file *file);ssize_t my_read(struct file *file, char __user *user, size_t t, loff_t *f);ssize_t my_write(struct file *file, const char __user *user, size_t t, loff_t *f);char* devName = &quot;IPDataSet&quot;;//设备名struct file_operations pStruct =&#123; open:my_open,      release:my_release,      read:my_read,      write:my_write, &#125;;//打开int my_open(struct inode *inode, struct file *file)&#123;  printk(&quot;open lgsDrive OK!\n&quot;);  try_module_get(THIS_MODULE);  return 0;&#125;//关闭int my_release(struct inode *inode, struct file *file)&#123;  printk(&quot;Device released!\n&quot;);  module_put(THIS_MODULE);  return 0;&#125;//读设备里的信息ssize_t my_read(struct file *file, char __user *user, size_t t, loff_t *f)&#123;  roc_dump(&amp;root);  if(copy_to_user(user,message,t))  &#123;    return -2;  &#125;  return sizeof(message);&#125;//向设备里写信息ssize_t my_write(struct file *file, const char __user *user, size_t t, loff_t *f)&#123;  if(copy_from_user(message,user,t))  &#123;    return -3;  &#125;  return sizeof(message);&#125;static struct class *drv_class = NULL;int major = 0;//设备号static int __init nf_init(void) &#123;  int ret = 0;  //char device  major = register_chrdev(0, &quot;ipdataset_drv&quot;, &amp;pStruct);  drv_class = class_create(THIS_MODULE, &quot;ipdataset_drv&quot;);  device_create(drv_class, NULL, MKDEV(major, 0), NULL, devName);  //    ret = register_chrdev(0, devName, &amp;pStruct);  //    if (ret &lt; 0)  //    &#123;  //        printk(&quot;failed to register_chrdev.\n&quot;);  //        return -1;  //    &#125;  //    else  //    &#123;  //        printk(&quot;the lgsDrive has been registered!\n&quot;);  //        printk(&quot;id: %d\n&quot;, ret);  //        device_num = ret;  //   //        return 0;  //    &#125;  //net device  ret = nf_register_net_hook(&amp;init_net, net_hooks);  //ret = nf_register_hooks(net_hooks,ARRAY_SIZE(net_hooks));    // 安装钩子  if(ret)  &#123;    printk(KERN_ERR &quot;register hook failed\n&quot;);    return -1;  &#125;  printk(&quot;Start...\n&quot;);  return 0;&#125;void close(void)&#123;  roc_destroy(&amp;root, roc_free);&#125;static void __exit nf_exit(void)&#123;  close();  unregister_chrdev(major, &quot;ipdataset_drv&quot;);  device_destroy(drv_class, MKDEV(major, 0));  class_destroy(drv_class);  //unregister_chrdev(device_num, devName);  nf_unregister_net_hook(&amp;init_net, net_hooks);  //nf_unregister_hooks(net_hooks,ARRAY_SIZE(net_hooks));    // 卸载钩子  printk(&quot;Exit...\n&quot;);&#125;module_init(nf_init);module_exit(nf_exit);MODULE_LICENSE(&quot;Dual BSD/GPL&quot;);MODULE_AUTHOR(&quot;dianwoshishi&quot;);MODULE_DESCRIPTION(&quot;Netfilter IP Statistic&quot;);MODULE_VERSION(&quot;1.0.1&quot;);MODULE_ALIAS(&quot;Netfilter 01&quot;);</code></pre><p><a id="org8ee7f64"></a></p><h2 id="用户代码"><a href="#用户代码" class="headerlink" title="用户代码"></a>用户代码</h2><p>上述字符型设备创建了一个字符节点为：/dev/IPDataSet， 在用户态程序中，我们通过Linux编程中提供的read函数对驱动中的数据message进行读取。<br>代码如下：</p><pre><code>   #include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#define MAX_SIZE 1024 char message[MAX_SIZE] ;  //打开设备时会显示的消息int main(int num, char *arg[])&#123;    if(2 != num)&#123;        printf(&quot;Usage: %s /dev/IPDataSet\n&quot;, arg[0]);        return -1;    &#125;    int fd = open(arg[1], O_RDWR);    if(0 &gt; fd)&#123;        perror(&quot;open&quot;);        return -1;    &#125;    int ret = read(fd, message, MAX_SIZE);    printf(&quot;read: ret = %d. %s\n&quot;, ret, message);    memset(message, 0, MAX_SIZE);    ret = write(fd, message, MAX_SIZE);    printf(&quot;write: ret = %d.\n&quot;, ret);    close(fd);    return 0;&#125;</code></pre><p><a id="org3f4753d"></a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><a id="org01bad05"></a></p><h2 id="Linux-驱动"><a href="#Linux-驱动" class="headerlink" title="Linux 驱动"></a>Linux 驱动</h2><p>熟悉Linux驱动的编写流程。 了解了Linux内核代码与用户代码的不同，比较明显的就是缺少了类似C++ STL类似的好用的库，只能使用类似红黑树（rbtree)这样的数据结构来做一些set的操作，需要对红黑树有一定的了解。<br>网络设备驱动和字符型设备驱动的编写结构都差不多，但是目前也是一知半解，尤其是一些简单操作之外的特性还不了解，例如加锁？多线程？不知道</p><p><a id="orgd1e6a5e"></a></p><h2 id="Linux内核"><a href="#Linux内核" class="headerlink" title="Linux内核"></a>Linux内核</h2><p>Linux内核的设计模式还是比较令人佩服的，虽然不懂全貌，但是也能从局部出发，贡献一些力量。再一次感受到了设计的魅力。</p><p><a id="org4c6ff33"></a></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>一定要在虚拟机中编写、测试驱动，不知道有什么错出现，你就要重启你的电脑，boring！</p><p><a id="orgfe8069d"></a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>linux驱动编写（总结篇）,<a href="https://blog.csdn.net/feixiaoxing/article/details/79913476?spm=1001.2014.3001.5506">https://blog.csdn.net/feixiaoxing/article/details/79913476?spm=1001.2014.3001.5506</a><br>智能路由器设备流量、网速统计及上下线提醒（基于netfilter编程）,<a href="https://blog.csdn.net/u012819339/article/details/50513387?spm=1001.2014.3001.5506">https://blog.csdn.net/u012819339/article/details/50513387?spm=1001.2014.3001.5506</a><br>利用Linux内核模块Netfilter hook UDP报文, <a href="https://blog.csdn.net/qq_41791640/article/details/104933006?spm=1001.2014.3001.5506">https://blog.csdn.net/qq_41791640/article/details/104933006?spm=1001.2014.3001.5506</a><br>Netfilter的使用和实现, <a href="https://blog.csdn.net/zhangskd/article/details/22678659?spm=1001.2014.3001.5506">https://blog.csdn.net/zhangskd/article/details/22678659?spm=1001.2014.3001.5506</a></p>]]></content>
    
    
    <summary type="html">Table of Contents
 1.  背景
 2. IP信息统计 1.  统计信息设计
     2.  存储数据结构
    
    
 3. Linux驱动 1.  网络型驱动设备
     2.  字符型设备
     3.  用户代码
    
    
 4. 总结 1.  Linux 驱动
     2.  Linux内核
     3.  其他
    
    
 5.  参考资料



背景
当今社会，没有都有自己的信息处理设备，如手机、计算机甚至可能是路由器。在使用这些设备的时候，我们想知道的一件事就是，我的电脑和那些设备有过通信，通信情况怎么样，以便在网络出现问</summary>
    
    
    
    <category term="开发" scheme="http://dianwoshishi.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Linux" scheme="http://dianwoshishi.github.io/tags/Linux/"/>
    
    <category term="netfilter" scheme="http://dianwoshishi.github.io/tags/netfilter/"/>
    
    <category term="内核" scheme="http://dianwoshishi.github.io/tags/%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>区块链中的密码学知识</title>
    <link href="http://dianwoshishi.github.io/2021/05/28/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%AD%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
    <id>http://dianwoshishi.github.io/2021/05/28/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%AD%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9F%A5%E8%AF%86/</id>
    <published>2021-05-27T16:00:00.000Z</published>
    <updated>2021-06-01T15:51:18.254Z</updated>
    
    <content type="html"><![CDATA[<p>原文为<a href="https://zhuanlan.zhihu.com/p/304725930">知乎</a>，现转移到个人博客。<br><a href="https://zhuanlan.zhihu.com/p/304725930" target="_blank" class="LinkCard">知乎原文</a><br>转发微信公众号<a href="https://mp.weixin.qq.com/s/NkAWmPokc86Jc6nWtz4-yA">文章</a><br><a href="https://mp.weixin.qq.com/s/NkAWmPokc86Jc6nWtz4-yA" target="_blank" class="LinkCard">微信公众号原文</a></p><h1 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h1><ol><li> <a href="#org63a3294">BitCoin是什么</a></li><li> <a href="#org1839db4">密码学是什么</a></li><li><a href="#org44c3a48">BitCoin中的密码学知识</a><pre><code> 1.  [哈希(Hash)](#org87067ef)     2.  [公钥密码体制](#orgb205e36)</code></pre></li><li> <a href="#org60092e2">总结</a></li><li> <a href="#orga6c2764">Reference</a></li></ol><p><a id="org63a3294"></a></p><h1 id="BitCoin是什么"><a href="#BitCoin是什么" class="headerlink" title="BitCoin是什么"></a>BitCoin是什么</h1><p>BitCoin，又称比特币，是2009年中本聪提出了一种点对点的数字现金系统，是一种分布式、点对点的货币,允许在线的交易不用经过中心化机构（如银行，支付宝）的情况下，在网络合作支持下，直接由一个用户发往另一个用户,并且可以提供防篡改，可验证的能力。<br>Bitcoin是最早实现“加密货币”这一概念的系统，该设想最早由戴伟（Dai Wei<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup>,音译）于1998年在cypherpunks函件用户组首次提出的:货币可以是任何东西或记录，只要它在一个国家或社会经济体系内被接受为商品服务的支付方式，或是债务偿还的方式。<br>比特币的设计核心思想是以密码学难题(cryptography puzzle)答案作为货币，其发行权独立于任何中央机构之外。</p><p>比特币使用了公开密钥系统<sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup>. 每一个钱币都包括了其拥有者的公开秘钥。当钱币从用户A支付给用户B时, A将B的公开秘钥添加到钱币中, 然后这个钱币又被A用私人密码匙来签名。B现在即拥有了这个钱币并且可以将来使用，而A就不可能再次使用这个钱币，因为以前的交易记录以被全体网络计算机记录。在每笔交易前，钱币的有效性都必须经过检验确认。</p><p><a id="org1839db4"></a></p><h1 id="密码学是什么"><a href="#密码学是什么" class="headerlink" title="密码学是什么"></a>密码学是什么</h1><p>密码学是一种使用先进的数学原理以特定的形式存储和传输数据的方法，以便只有它的目标用户能够读取和处理数据。密码学已经被人们用来在不被发现的情况下转发信息。随着互联网及信息技术的飞速发展，密码学被赋予了新的含义。密码哈希，电子签名等被广泛使用在防篡改，身份认证等场合。当前有三种广泛使用的加密形式：对称加密、非对称加密和哈希。</p><p><a id="org44c3a48"></a></p><h1 id="BitCoin中的密码学知识"><a href="#BitCoin中的密码学知识" class="headerlink" title="BitCoin中的密码学知识"></a>BitCoin中的密码学知识</h1><p>在中本聪的Bitcoin: A Peer-to-Peer Electronic Cash System一文中我们可以看见如下一段话，从这段话中我们可以看出密码学在BitCoin中的应用：</p><blockquote><p>We define an electronic coin as a chain of <strong><strong>digital signatures</strong></strong>. Each owner transfers the coin to the next by digitally <strong><strong>signing</strong></strong> a <strong><strong>hash</strong></strong> of the previous transaction and the <strong><strong>public key</strong></strong> of the next owner and adding these to the end of the coin. A payee can <strong><strong>verify the signatures</strong></strong> to verify the chain of ownership.——Bitcoin: A Peer-to-Peer Electronic Cash System[1]</p></blockquote><p>下面就主要从哈希和 公钥密码体制两个方面介绍BitCoin中的密码学知识。</p><p><a id="org87067ef"></a></p><h3 id="哈希-Hash"><a href="#哈希-Hash" class="headerlink" title="哈希(Hash)"></a>哈希(Hash)</h3><p>哈希（有时称“摘要”,密码散列,Hashing）是文本或数据文件的经过压缩的一种”指纹”。 Hash函数是把任意长度的输入通过散列函数或者说是hash函数转化为固定长度的输出的一种算法。这个输入区间可以无穷大，但输出区间是固定的。比如输入可以是任意的，输出是一个3位数。<br>这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来确定唯一的输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。</p><p>BitCoin中的hash函数主要有SHA-256，RIPEME-160，hash的一个主要应用是Merkle树,其中算法前缀“SHA”和”RIPEMD”表示基础算法，数字后缀”256”和”160”表示输出的固定长度。 </p><p>在比特币协议中，SHA256和RIPEMD160一起用于保护数字签名中使用的公钥。SHA256方法也用于比特币挖掘中的工作函数证明，并作为数字签名算法的一部分。</p><ol><li><p>SHA-256</p><p> SHA就是安全哈希算法（Secure Hash Algorithm）的简写。SHA-256为文本生成几乎唯一的256位（32字节）签名。<br> 另外，比特币挖矿（mining）的cryptograph puzzle也是通过计算满足一定条件的hash来完成的，例如计算的满足256bit位hash前缀满足60个0(由区块链中区块内部的nonce决定)的hash。</p></li><li><p>RIPEME-160</p><p> RIPEMD（RIPE Message Digest）是1992年（原始RIPEMD）和1996年（其他变体）开发的一系列密码哈希函数。 该系列有五个功能：RIPEMD，RIPEMD-128，RIPEMD-160，RIPEMD-256和RIPEMD-320，其中RIPEMD-160是最常见的,也是比特币中使用的Hash算法之一。</p><p> 之所以使用RIPEMD，是因为它产生了最短的哈希,用于生成比特币地址,这允许比特币地址更短。同时，其唯一性仍得到了充分保证。 </p></li><li><p>Merkle Tree</p><p> Merkle树是一种哈希树，其中叶节点是根据数据块计算的加密哈希，而非叶节点是其直接子节点的哈希。根散列也称为数据的“摘要”。</p><p> o<br> 要验证一个记录，它需要一个数据“证明”，其中包含根路径上的节点。递归地重新计算新的根散列，并使用先前保存的摘要检查相等性。</p><p> 如下图：例如L4被修改，那么hash1-1，hash1，top hash 都会被重新计算，最终显示为Top hash的变化，只需要对比Top hash 就能够知道节点中的数据有没有被篡改。</p><p> <img src="/2021/05/28/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%AD%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9F%A5%E8%AF%86/Hash_Tree.jpg" alt="img" title="Merkle树"></p><p> Merkle 树将根存储在比特币区块中，验证者只用验证根的hash是否变化，就可以判断Merkle 树中的子节点是否被篡改，而不用验证全部的节点，极大的减少了验证的复杂度。</p><p> <img src="/2021/05/28/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%AD%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9F%A5%E8%AF%86/Merkle-Tree-representation-of-a-Block.png" alt="img" title="Merkle树表示"></p></li></ol><p><a id="orgb205e36"></a></p><h3 id="公钥密码体制"><a href="#公钥密码体制" class="headerlink" title="公钥密码体制"></a>公钥密码体制</h3><p>公钥密码体制使用*不同的加密密钥与解密密钥*，是一种“由已知加密密钥推导出解密密钥在计算上是不可行的”密码体制。</p><p>公钥密码体制使用的密钥分为公钥和私钥，两种密钥成对使用。使用公钥加密和私钥解密；使用私钥加密和公钥解密。</p><p>现有最著名的公钥密码体制是*RSA* 体制，它基于数论中大数分解问题，由美国三位科学家 Rivest, Shamir 和 Adleman 于 1976 年提出并在 1978 年正式发表的。</p><p>公钥密码体制根据使用秘钥的不同，可以分为两类：发送者使用发送者的私钥处理数据，接受者使用发送者的公钥逆向处理，为签名；发送者使用接受者的公钥处理数据，接受者使用接受者的私钥处理数据，为加密。下面分别讨论这两种方式：</p><ol><li><p>非对称加密</p><p> 非对称密码学利用两个密钥（公共密钥和私有密钥）来加密和解密特定数据。例如：我发消息给你，用你的公钥进行加密，而你用自己的私钥进行解密，你的公钥可以公开，但是你的私钥只有自己知道.这样每个人都可以给你发信息，但只有你自己能通过私钥解密查看。</p><p> 下图为正常的加密、解密流程：</p><p> <img src="/2021/05/28/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%AD%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9F%A5%E8%AF%86/68637037-67713000-0538-11ea-85c9-177b3b26aa5a.png" alt="img" title="密码体制及应用"></p><p> 两种常用的非对称加密算法：Rivest-Shamir-Adleman算法又称为RSA，椭圆曲线密码（ECC）。</p></li><li><p>数字签名</p><p> 比特币本身是不加密的，那么比特币不加密怎么安全呢？</p><p> 如果我要交易，把我的比特币给你，那么我在交易上，用我的私钥进行签名，大家都可以用我的公钥进行验证，这样大家都能知道确实是我进行的交易，证明币是你的，这就涉及到了数字签名。</p><p> 如下图所示：发送者用自己的private key 处理message 和 经过hash的message digest，然后通过信道发送个接受者，接受者通过发送者的public key逆向处理消息，得到message 和 message disgest，通过验证hash(message)是否与messagedigest相等，可以验证是否是发送者发来的消息。</p><p> <img src="/2021/05/28/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%AD%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9F%A5%E8%AF%86/image002.jpg" alt="img" title="数字签名"></p></li></ol><p><a id="org60092e2"></a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>随着互联网和公钥密码体制的发展，人们越来越关注安全和隐私，密码学在日常生活中处处可见，掌握必要的密码学知识至关重要。</p><p>bitcoin通过一系列密码算法的组合，实现了一个分布式、点对点、可信、可验证、不可篡改的加密数字货币，比特币种的密码学知识主要有哈希，公钥密码体制，数字签名。</p><p><a id="orga6c2764"></a></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>[1] Wright, C. S. (2019). Bitcoin: A Peer-to-Peer Electronic Cash System. SSRN Electronic Journal, 1–9. <a href="https://doi.org/10.2139/ssrn.3440802">https://doi.org/10.2139/ssrn.3440802</a></p><h1 id="Footnotes"><a href="#Footnotes" class="headerlink" title="Footnotes"></a>Footnotes</h1><p><sup><a id="fn.1" href="#fnr.1">1</a></sup> <a href="https://en.bitcoin.it/wiki/Wei_Dai">https://en.bitcoin.it/wiki/Wei_Dai</a></p><p><sup><a id="fn.2" href="#fnr.2">2</a></sup> <a href="http://zh.wikipedia.org/wiki/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86">http://zh.wikipedia.org/wiki/公开密钥加密</a></p><p>欢迎关注我的微信公众号，扫描下方二维码，就可以找到我，我会持续为你分享 IT 技术和珠宝知识。</p><p><img src="https://pic1.zhimg.com/80/v2-8ff04a9934840c3c552ed41497bc4748_720w.jpg" alt="欢迎关注我的微信公众号，扫描下方二维码，就可以找到我，我会持续为你分享 IT 技术和珠宝知识"></p><p>也可以关注我的个人博客</p><p><a href="https://dianwoshishi.github.io/">点我试试的个人博客</a></p>]]></content>
    
    
    <summary type="html">原文为知乎，现转移到个人博客。
知乎原文
转发微信公众号文章
微信公众号原文

Table of Contents
 1.  BitCoin是什么
 2.  密码学是什么
 3. BitCoin中的密码学知识 1.  [哈希(Hash)](#org87067ef)
         2.  [公钥密码体制](#orgb205e36)
    
    
    
 4.  总结
 5.  Reference



BitCoin是什么
BitCoin，又称比特币，是2009年中本聪提出了一种点对点的数字现金系统，是一种分布式、点对点的货币,允许在线的交易不用经过中心化机构（如银行，支付宝）的情</summary>
    
    
    
    <category term="学习" scheme="http://dianwoshishi.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="比特币" scheme="http://dianwoshishi.github.io/tags/%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
    <category term="区块链" scheme="http://dianwoshishi.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="密码学" scheme="http://dianwoshishi.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>关于RFC文档有趣的事情</title>
    <link href="http://dianwoshishi.github.io/2021/05/27/%E5%85%B3%E4%BA%8ERFC%E6%96%87%E6%A1%A3%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8B%E6%83%85/"/>
    <id>http://dianwoshishi.github.io/2021/05/27/%E5%85%B3%E4%BA%8ERFC%E6%96%87%E6%A1%A3%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8B%E6%83%85/</id>
    <published>2021-05-26T16:00:00.000Z</published>
    <updated>2021-06-01T01:02:23.820Z</updated>
    
    <content type="html"><![CDATA[<p>原文为知乎<a href="https://zhuanlan.zhihu.com/p/337997798">文章</a>， 现转移到个人博客。</p><h1 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h1><ol><li> <a href="#org34ce3f0">事情的起源</a></li><li><a href="#orgbd0ef9b">研究经过</a><ol><li> <a href="#orgd742468">查询相关资料</a></li><li> <a href="#org7b36c8c">查询相关RFC</a></li><li><a href="#orge2e0fc8">一个想法</a><ol><li> <a href="#org3061772">第一个发现</a></li><li> <a href="#org4e04c37">第二个发现</a></li><li> <a href="#org2636b5a">第三个发现</a></li><li> <a href="#org9ff55be">第四个发现</a></li></ol></li></ol></li><li> <a href="#org9564d4b">总结</a></li></ol><p><a id="org34ce3f0"></a></p><h1 id="事情的起源"><a href="#事情的起源" class="headerlink" title="事情的起源"></a>事情的起源</h1><p>一次被问起，为何TLSv1.0(RFC2246),TLSv1.1(RFC4346),TLSv1.2(RFC5246),TLSv1.3(RFC8446)中的RFC编号都是以64结尾。印象中关于RFC编号都是递增的，因为RFC写好之后就不允许再修改了，如果有新的标准出来，只能在其后某个编号出现，并且引用之前的RFC。<br>但是上述这个问题，TLS四个版本均以64结尾，也太凑巧了，确实很让人疑惑。本着好奇，去研究了研究这事。</p><p>&lt;！–more–&gt;</p><p><a id="orgbd0ef9b"></a></p><h1 id="研究经过"><a href="#研究经过" class="headerlink" title="研究经过"></a>研究经过</h1><p><a id="orgd742468"></a></p><h2 id="查询相关资料"><a href="#查询相关资料" class="headerlink" title="查询相关资料"></a>查询相关资料</h2><p>首先在网上搜索为什么TLS均以64结尾，网上的回答基本上来自如下解释</p><blockquote><p>In the IETF, protocols are called RFCs. TLS 1.0 was RFC 2246, TLS 1.1 was RFC 4346, and TLS 1.2 was RFC 5246. Today, TLS 1.3 was published as RFC 8446. RFCs are generally published in order, keeping 46 as part of the RFC number is a nice touch<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup>.</p></blockquote><p>显然，并没有解决我们的问题。</p><p><a id="org7b36c8c"></a></p><h2 id="查询相关RFC"><a href="#查询相关RFC" class="headerlink" title="查询相关RFC"></a>查询相关RFC</h2><p>思考是否会有某个RFC对这事做了说明吗？查询未果。<br>但是在此过程中，我发现了在RFC文档中，有相邻两个递增编号文档，但是RFC时间并不递增的现象。举个例子</p><blockquote><p>1478 An Architecture for Inter-Domain Policy Routing. M. Steenstrup. June</p><ol><li> (Format: TXT, HTML) (Status: HISTORIC) (DOI: 10.17487/RFC1478)</li></ol><p>1479 Inter-Domain Policy Routing Protocol Specification: Version 1. M.<br>     Steenstrup. July 1993. (Format: TXT, HTML) (Status: HISTORIC) (DOI:<br>     10.17487/RFC1479) </p><p>1480 The US Domain. A. Cooper, J. Postel. June 1993. (Format: TXT, HTML)<br>     (Obsoletes RFC1386) (Status: INFORMATIONAL) (DOI: 10.17487/RFC1480) </p></blockquote><p>其中RFC1478的时间为1993年6月，RFC1479的时间为1993年7月，但是RFC1480的时间为1993年6月，出现了非递增的情况。</p><p>虽然又发现，但好像并没有什么卵用。但是自然会想到，有可能时间上有大的反复吗？有年的反复现象吗？</p><p><a id="orge2e0fc8"></a></p><h2 id="一个想法"><a href="#一个想法" class="headerlink" title="一个想法"></a>一个想法</h2><p><a id="org3061772"></a></p><h3 id="第一个发现"><a href="#第一个发现" class="headerlink" title="第一个发现"></a>第一个发现</h3><p>所以就想分析分析RFC文档的编号的时间问题。第一想法是爬虫，但是工作量太复杂。左搜索右搜索，找到了官网提供的XML版列表<sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup>.超级开心。然后写了个python脚本，自动进行了分析(忽略并不想改的变量名，来自一个豆瓣电影爬虫)。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#!/usr/bin/python3</span><span class="token keyword">import</span> calendar<span class="token keyword">from</span> xml<span class="token punctuation">.</span>dom<span class="token punctuation">.</span>minidom <span class="token keyword">import</span> parse<span class="token keyword">import</span> xml<span class="token punctuation">.</span>dom<span class="token punctuation">.</span>minidom<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt <span class="token comment"># 使用minidom解析器打开 XML 文档</span>DOMTree <span class="token operator">=</span> xml<span class="token punctuation">.</span>dom<span class="token punctuation">.</span>minidom<span class="token punctuation">.</span>parse<span class="token punctuation">(</span><span class="token string">"rfc-index.xml"</span><span class="token punctuation">)</span>collection <span class="token operator">=</span> DOMTree<span class="token punctuation">.</span>documentElement<span class="token keyword">if</span> collection<span class="token punctuation">.</span>hasAttribute<span class="token punctuation">(</span><span class="token string">"shelf"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>   <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">"Root element : %s"</span> <span class="token operator">%</span> collection<span class="token punctuation">.</span>getAttribute<span class="token punctuation">(</span><span class="token string">"shelf"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 在集合中获取所有电影</span>movies <span class="token operator">=</span> collection<span class="token punctuation">.</span>getElementsByTagName<span class="token punctuation">(</span><span class="token string">"rfc-entry"</span><span class="token punctuation">)</span><span class="token comment"># 打印每部电影的详细信息</span><span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">"*****Movie*****"</span><span class="token punctuation">)</span>x <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>years <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>months <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>total <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span> movie <span class="token keyword">in</span> movies<span class="token punctuation">:</span>   <span class="token builtin">type</span> <span class="token operator">=</span> movie<span class="token punctuation">.</span>getElementsByTagName<span class="token punctuation">(</span><span class="token string">'doc-id'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>childNodes<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>data   <span class="token builtin">id</span> <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token builtin">type</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   x<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token builtin">id</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">#    print ("doc-id: %d" % id)</span><span class="token comment">#    author = movie.getElementsByTagName('author')[0]</span><span class="token comment">#    print ("author: %s" % author.childNodes[1].data)</span>   date <span class="token operator">=</span> movie<span class="token punctuation">.</span>getElementsByTagName<span class="token punctuation">(</span><span class="token string">'date'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>   month <span class="token operator">=</span> date<span class="token punctuation">.</span>getElementsByTagName<span class="token punctuation">(</span><span class="token string">'month'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>childNodes<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">;</span>   int_month <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token builtin">list</span><span class="token punctuation">(</span>calendar<span class="token punctuation">.</span>month_name<span class="token punctuation">)</span><span class="token punctuation">.</span>index<span class="token punctuation">(</span>month<span class="token punctuation">)</span><span class="token punctuation">)</span>   months<span class="token punctuation">.</span>append<span class="token punctuation">(</span>int_month<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">#    print ("date month: %d" % int_month)</span>   year <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>date<span class="token punctuation">.</span>getElementsByTagName<span class="token punctuation">(</span><span class="token string">'year'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>childNodes<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">#    print ("date year: %d" % year)</span>   years<span class="token punctuation">.</span>append<span class="token punctuation">(</span>year<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">#    description = movie.getElementsByTagName('description')[0]</span><span class="token comment">#    print ("Description: %s" % description.childNodes[0].data)</span>   total<span class="token punctuation">.</span>append<span class="token punctuation">(</span>year <span class="token operator">+</span> <span class="token number">10</span>  <span class="token operator">+</span> int_month  <span class="token punctuation">)</span>plt<span class="token punctuation">.</span>rcParams<span class="token punctuation">[</span><span class="token string">'font.sans-serif'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'Arial Unicode MS'</span><span class="token punctuation">]</span>plt<span class="token punctuation">.</span>rcParams<span class="token punctuation">[</span><span class="token string">'axes.unicode_minus'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">False</span>   <span class="token comment"># 解决保存图像是负号'-'显示为方块的问题</span>plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">"Matplotlib"</span><span class="token punctuation">)</span> plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span><span class="token string">"RFC编号"</span><span class="token punctuation">)</span> plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span><span class="token string">"年份"</span><span class="token punctuation">)</span> plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x<span class="token punctuation">,</span>years<span class="token punctuation">,</span> label<span class="token operator">=</span><span class="token string">r'年'</span><span class="token punctuation">)</span> plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x<span class="token punctuation">,</span>total<span class="token punctuation">,</span> label<span class="token operator">=</span><span class="token string">r'年 + 月 + 10(向上平移10)'</span><span class="token punctuation">)</span> <span class="token comment"># plt.subplot(2,1,1)</span><span class="token comment"># plt.plot(x,years) </span><span class="token comment"># plt.subplot(2,1,2)</span><span class="token comment"># plt.plot(x,months) </span>plt<span class="token punctuation">.</span>legend<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>plt<span class="token punctuation">.</span>grid<span class="token punctuation">(</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>经过经过分析有了如下所示图：<br><img src="/2021/05/27/%E5%85%B3%E4%BA%8ERFC%E6%96%87%E6%A1%A3%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8B%E6%83%85/%E5%B9%B4%E4%BB%BD%E5%9B%BE.png" alt="img"><br>果然有问题！！！！上图横坐标为RFC编号，纵坐标为RFC编号对应的年份。可以看出RFC文档从一九六几年到今天一共发表8000余份。有意思的是，其中有一些凸起的部分，就是一些异常点。例如2000年前有一个极高的凸起，这代表这个编号的年份远远超出这个编号附近的年份，这与我们的常识不符。实际上，查看这个异常点，如下图所示：<br><img src="/2021/05/27/%E5%85%B3%E4%BA%8ERFC%E6%96%87%E6%A1%A3%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8B%E6%83%85/image-20201218225458777.png" alt="img"><br>其中RFC1849的年份为2010年，但其附近的RFC文档编号均为1995年，其中相差15年，造成第一幅图中的凸起。</p><p><a id="org4e04c37"></a></p><h3 id="第二个发现"><a href="#第二个发现" class="headerlink" title="第二个发现"></a>第二个发现</h3><p>同时，我们还会发现另一个有意思的现象。如下图所示：<br><img src="/2021/05/27/%E5%85%B3%E4%BA%8ERFC%E6%96%87%E6%A1%A3%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8B%E6%83%85/%E6%95%B4%E6%95%B0%E9%97%B4%E9%9A%94%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="整数间隔示意图"><br>其中编号为1299，1399，1499，1599，1699,&#x2026;等，均出现凸起现象。并且实际上1299，1399，1499，1599，1699，1799，1899，1999的年份均为1997年。存在明显的人为痕迹。</p><p><a id="org2636b5a"></a></p><h3 id="第三个发现"><a href="#第三个发现" class="headerlink" title="第三个发现"></a>第三个发现</h3><p>年份和月份基本满足递增，但是有波动。如下图所示：<br><img src="/2021/05/27/%E5%85%B3%E4%BA%8ERFC%E6%96%87%E6%A1%A3%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8B%E6%83%85/%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="img"><br>放大后：<br><img src="/2021/05/27/%E5%85%B3%E4%BA%8ERFC%E6%96%87%E6%A1%A3%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8B%E6%83%85/%E7%A4%BA%E6%84%8F%E5%9B%BE%E6%94%BE%E5%A4%A7.png" alt="img"><br>为方便对比，将其中月份显示为（年+月，再向上平移10个单位(年)）。</p><p><a id="org9ff55be"></a></p><h3 id="第四个发现"><a href="#第四个发现" class="headerlink" title="第四个发现"></a>第四个发现</h3><p>TLS的主要作者，目前是Eric Rescorla。对TLS四个版本作者做简单统计，如下图：<br><img src="/2021/05/27/%E5%85%B3%E4%BA%8ERFC%E6%96%87%E6%A1%A3%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8B%E6%83%85/image-20201218231640006.png" alt="img"><br>可以看出，最开始Tim Dierks逐渐从第二作者，向第一作者上升，此时带了个徒弟。慢慢Tim Dierks开始退居二线，Eric Rescorla开始独挡一面（纯属胡说八道）。</p><p><a id="org9564d4b"></a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>虽然并没有直接的证据来回答开头提出的问题，但是我们可以发现以下现象：</p><ul><li>  RFC的编号并非严格的时间递增，而是存在一些波动</li><li>  RFC的编号中存在一些，小概率发生的现象，例如等间隔凸起</li></ul><p>基于以上现象呢，我们可以大胆猜测（hu shuo ba dao）：</p><ul><li>  RFC编号的审批机构，会因为某些原因，保留一些编号</li><li>  RFC的编号其实并没有想象中的那么严格</li><li>  大佬在RFC编号中具有一定的发言权，可以”预定“一些编号。如TLSv1，2，3，4以64结尾</li></ul><h1 id="Footnotes"><a href="#Footnotes" class="headerlink" title="Footnotes"></a>Footnotes</h1><p><sup><a id="fn.1" href="#fnr.1">1</a></sup> <a href="https://blog.cloudflare.com/rfc-8446-aka-tls-1-3/">https://blog.cloudflare.com/rfc-8446-aka-tls-1-3/</a></p><p><sup><a id="fn.2" href="#fnr.2">2</a></sup> <a href="https://www.rfc-editor.org/rfc-index.xml">https://www.rfc-editor.org/rfc-index.xml</a></p>]]></content>
    
    
    <summary type="html">原文为知乎文章， 现转移到个人博客。

Table of Contents
 1.  事情的起源
 2. 研究经过 1.  查询相关资料
     2.  查询相关RFC
     3. 一个想法 1.  第一个发现
         2.  第二个发现
         3.  第三个发现
         4.  第四个发现
        
        
    
    
 3.  总结



事情的起源
一次被问起，为何TLSv1.0(RFC2246),TLSv1.1(RFC4346),TLSv1.2(RFC5246),TLSv1.3(RFC8446)中的RFC编号都是以64结尾</summary>
    
    
    
    <category term="研究" scheme="http://dianwoshishi.github.io/categories/%E7%A0%94%E7%A9%B6/"/>
    
    
    <category term="RFC" scheme="http://dianwoshishi.github.io/tags/RFC/"/>
    
    <category term="编号" scheme="http://dianwoshishi.github.io/tags/%E7%BC%96%E5%8F%B7/"/>
    
    <category term="python" scheme="http://dianwoshishi.github.io/tags/python/"/>
    
  </entry>
  
</feed>
