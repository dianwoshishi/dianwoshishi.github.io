<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://dianwoshishi.github.io/atom.xml" rel="self"/>
  
  <link href="http://dianwoshishi.github.io/"/>
  <updated>2022-02-27T11:13:42.916Z</updated>
  <id>http://dianwoshishi.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>docker中单容器开启多服务时systemctl引发的血案及破案过程</title>
    <link href="http://dianwoshishi.github.io/post/docker%E4%B8%AD%E5%8D%95%E5%AE%B9%E5%99%A8%E5%BC%80%E5%90%AF%E5%A4%9A%E6%9C%8D%E5%8A%A1%E6%97%B6systemctl%E5%BC%95%E5%8F%91%E7%9A%84%E8%A1%80%E6%A1%88%E5%8F%8A%E7%A0%B4%E6%A1%88%E8%BF%87%E7%A8%8B.html"/>
    <id>http://dianwoshishi.github.io/post/docker%E4%B8%AD%E5%8D%95%E5%AE%B9%E5%99%A8%E5%BC%80%E5%90%AF%E5%A4%9A%E6%9C%8D%E5%8A%A1%E6%97%B6systemctl%E5%BC%95%E5%8F%91%E7%9A%84%E8%A1%80%E6%A1%88%E5%8F%8A%E7%A0%B4%E6%A1%88%E8%BF%87%E7%A8%8B.html</id>
    <published>2022-02-27T11:09:52.000Z</published>
    <updated>2022-02-27T11:13:42.916Z</updated>
    
    <content type="html"><![CDATA[<h1 id="docker中单容器开启多服务时systemctl引发的血案及破案过程"><a href="#docker中单容器开启多服务时systemctl引发的血案及破案过程" class="headerlink" title="docker中单容器开启多服务时systemctl引发的血案及破案过程"></a>docker中单容器开启多服务时systemctl引发的血案及破案过程</h1><p>问题的起源来源于，想要将一个运行在centos7上的项目，移植到docker上，实现快速部署。原项目，我们暂且称之为<code>Myproject</code>， 提供了install_centos7.sh和Vagrant的构建文件。Vagrant 文件工作的很好，但是笔者是在虚拟机中完成的vagrant构建的验证，也遇见了不少问题，例如嵌套虚拟化的问题</p><p>但，虚拟机里面搞总感觉不得劲，又加上vagrant比较小众，我就盯上了Docker。本来想着这不是很简单吗，pull一个centos7的image，然后run一个container，bash install一下就完了呗。</p><p>没想到这就开始了，痛苦的采坑之旅。</p><h2 id="docker安装Myproject出现的的问题"><a href="#docker安装Myproject出现的的问题" class="headerlink" title="docker安装Myproject出现的的问题"></a>docker安装Myproject出现的的问题</h2><p>由于docker的设计原则是一个container只运行一个服务，所以像Myproject这样的需要多个服务的(redis, httpd, psql, mongo, rabbitmq等)，想要在一个容器中使用，存在很多限制。</p><p>问题包括，但不限于<a href="https://blog.csdn.net/henni_719/article/details/99689411">docker中执行systemctl命令问题记录和解决_WELTest的专栏-CSDN博客_docker systemctl</a></p><p><a href="https://stackoverflow.com/questions/39169403/not-able-to-use-systemd-on-ubuntu-docker-container">Not able to use systemd on ubuntu docker container - Stack Overflow</a></p><h3 id="问题有：Failed-to-get-D-Bus-connection-Operation-not-permitted"><a href="#问题有：Failed-to-get-D-Bus-connection-Operation-not-permitted" class="headerlink" title="问题有：Failed to get D-Bus connection: Operation not permitted"></a>问题有：Failed to get D-Bus connection: Operation not permitted</h3><p>解决这个问题的一个方法是使用<code>--privileged</code>和<code>/usr/sbin/init</code></p><ul><li><p>privileged的作用是使得docker的环境以管理员角色运行</p></li><li><p>&#x2F;usr&#x2F;sbin&#x2F;init是</p></li></ul><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>&#x2F;usr&#x2F;sbin&#x2F;init 启动容器之后可以使用systemctl方法<br>-privileged&#x3D;true 获取宿主机root权限（特殊权限-）</p><p><a href="https://www.cnblogs.com/lph970417/p/14754072.html">docker -privileged和&#x2F;usr&#x2F;sbin&#x2F;init - lvph - 博客园</a></p></blockquote><p>但是这个方法使用后出现了以下问题：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"> ~  docker run -itd --privileged --name centos7 centos:7 &#x2F;usr&#x2F;sbin&#x2F;inita2f71d42e0f4c5c13b06a607da719df40e428305188c1a3154889a1bc4991f6d ~  docker exec -it centos7 ps auxUSER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMANDroot         1  0.4  0.1  42716  3888 ?        Ss   10:44   0:00 &#x2F;usr&#x2F;sbin&#x2F;initroot         8  0.0  0.1  51748  3400 pts&#x2F;1    Rs+  10:44   0:00 ps aux ~  docker exec -it centos7 &#x2F;bin&#x2F;bash[root@a2f71d42e0f4 &#x2F;]# systemctlFailed to get D-Bus connection: No such file or directory<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还有一种方法是：run docker image with <code>docker run --privileged -v /sys/fs/cgroup:/sys/fs/cgroup:ro &lt;image&gt;</code> and <code>systemctl</code> works fine</p><p>经过试验，也解决不了我的问题</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"> ~  docker run --privileged -itd  -v &#x2F;sys&#x2F;fs&#x2F;cgroup:&#x2F;sys&#x2F;fs&#x2F;cgroup:ro --name centos7 centos:7 &#x2F;usr&#x2F;sbin&#x2F;init7ff1b85e7c9fecf17c889e0c2a25ab73203131ecdcb629180798fa1c07b4ee22 ~  docker exec -it centos7 ps auxUSER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMANDroot         1  1.0  0.1  42716  3944 ?        Ss   10:49   0:00 &#x2F;usr&#x2F;sbin&#x2F;initroot         8  0.0  0.1  51748  3456 pts&#x2F;1    Rs+  10:49   0:00 ps aux ~  docker exec -it centos7 &#x2F;bin&#x2F;bash[root@7ff1b85e7c9f &#x2F;]# systemctlFailed to get D-Bus connection: No such file or directory ~  docker run -it \    --volume &#x2F;sys&#x2F;fs&#x2F;cgroup:&#x2F;sys&#x2F;fs&#x2F;cgroup:ro \    --rm centos:7 &#x2F;bin&#x2F;bash[root@9c3b2edf75ff &#x2F;]# systemctlFailed to get D-Bus connection: Operation not permitted[root@9c3b2edf75ff &#x2F;]#<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Failed-to-connect-to-bus-No-such-file-or-directory"><a href="#Failed-to-connect-to-bus-No-such-file-or-directory" class="headerlink" title="Failed to connect to bus: No such file or directory"></a>Failed to connect to bus: No such file or directory</h3><p>在搜索资料的过程中发现了这篇文章， 对这个问题的解释比较到位：<a href="https://ehds.github.io/2021/01/21/docker_systemctl/">如何在Docker里面使用systemctl - Ehds</a></p><p><strong>容器里面是没有systemd进程的，而很多进程管理工具都需要和systemd通信，这里面就有我们这里的主角systemctl。docker只是提供了进程隔离，不是操作系统的虚拟。</strong></p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>That’s because “systemctl” talks to the systemd daemon by using the d-bus. In a container there is no systemd-daemon. Asking for a start will probably not quite do what you expect - the dev-mapping need to be a bit longer.<br>This is by design. Docker should be running a process in the foreground in your container and it will be spawned as PID 1 within the container’s pid namespace. Docker is designed for process isolation, not for OS virtualization, so there are no other OS processes and daemons running inside the container (like systemd, cron, syslog, etc), only your entrypoint or command you run.<br>If they included systemd commands, you’d find a lot of things not working since your entrypoint replaces init. Systemd also makes use to cgroups which docker restricts inside of containers since the ability to change cgroups could allow a process to escape the container’s isolation. Without systemd running as init inside your container, there’s no daemon to process your start and stop commands.</p></blockquote><p>给出解决方案，确实能work</p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>  解决方案</p><ol><li><p>我们可以在启动容器的时候将在启动参数加上 &#x2F;sbin&#x2F;init 来让其生效。<br>以centos为例：<br><code>docker run -d -v /sys/fs/cgroup/:/sys/fs/cgroup:ro --cap-add SYS_ADMIN --name systemd_websrv centos /sbin/init</code><br>就可以正常使用systemd了<br>但是如果容器重启，那么就可能导致失效。</p></li><li><p>替换systemctl<br>使用 <a href="https://github.com/gdraheim/docker-systemctl-replacement">docker-systemctl-replacement</a>替换容器中的systemctl。<br>以ubuntu镜像为例：<br>1). 安装python2<br><code>sudo apt install python</code><br>2). 替换systemcl (注意路径，可以使用<code>whereis systemctl</code>查看当前默认路径)<br><code>wget https://raw.githubusercontent.com/gdraheim/docker-systemctl-replacement/master/files/docker/systemctl.py -O /bin/systemctl</code><br>3). 给定权限<br><code>sudo chmod a+x /bin/systemctl</code><br>这样接可以使用非systemd的systemctl，但是因为是非官方的systemcl所以可能存在一些未知问题。</p></li></ol><p>最好还是建议将docker作为进程隔离环境，<code>single app single container</code>， 但是遇到非常特殊的情况下，可以上述两个解决方案，如果有更好的方案，欢迎提出。</p></blockquote><p>上面这些在单容器单服务下都工作的很好，但是在笔者的场景下呢？情况不是太好</p><h3 id="事情还没有完"><a href="#事情还没有完" class="headerlink" title="事情还没有完"></a>事情还没有完</h3><p>当我们想要像在虚拟机上一样，在一个容器中运行多个container，比如一般网站的配置，redis，httpd，mongo，rabbitmq等等，这该怎么搞？不要问我为什么不把容器拆分，要问就是配置起来太麻烦了。</p><p>笔者遇到一个问题就是，按照上述copy的方法对container中所有服务安装完毕之后，一切非常正常，但问题发生在，重启container，systemctl就再也启动不起来某些服务，例如httpd，psql等。</p><p>经过一番周折，以及和systemctl.py的作者进行沟通，最后发现：其实这个问题的根源还是在<code>systemctl</code>上.</p><p>在centos系统中，systemctl需要使用d-bus来与systemd通信，完成服务的启动。但是在docker的容器中并没有systemd-daemon的守护进程，所以上述通信是不会完成的。这就导致了前面所说的两个问题:D-Bus connection: Operation not permitted以及No such file or directory的问题</p><p>下面举个例子</p><p>一般我们启动容器的过程一般使用<code>docker run -t -i centos:7 /bin/bash</code>, 那么容器中一号进程就是<code>/bin/bash</code>, 而不是我们熟悉的systemd。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"> ~  docker pull centos:77: Pulling from library&#x2F;centos2d473b07cdd5: Downloading7: Pulling from library&#x2F;centos2d473b07cdd5: Pull completeDigest: sha256:c73f515d06b0fa07bb18d8202035e739a494ce760aa73129f60f4bf2bd22b407Status: Downloaded newer image for centos:7docker.io&#x2F;library&#x2F;centos:7 ~  docker run -itd --name centos7 centos:7c625bedacd894f9db6ca065839e413bb02e46cf6b602822f26baebfab745982a ~  docker exec -it centos7 ps auxUSER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMANDroot         1  0.4  0.1  11844  2944 pts&#x2F;0    Ss+  10:41   0:00 &#x2F;bin&#x2F;bashroot        14  0.0  0.1  51748  3448 pts&#x2F;1    Rs+  10:41   0:00 ps aux<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对象都没有了，所以暴d-bus的错误，就很容易解释了。</p><p>上述描述是对这个问题的通俗解释，想要了解关于这个问题的根本原因可以看下面两个链接，进一步了解，基本都是在解释一号进程的问题</p><p><a href="https://stackoverflow.com/questions/49285658/how-to-solve-docker-issue-failed-to-connect-to-bus-no-such-file-or-directory">linux - how to solve Docker issue Failed to connect to bus: No such file or directory - Stack Overflow</a></p><p><a href="https://stackoverflow.com/questions/39169403/not-able-to-use-systemd-on-ubuntu-docker-container">Not able to use systemd on ubuntu docker container - Stack Overflow</a></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>问题的根源找到了，解决这个问题的思路就非常的清晰了，就是使服务的管理不依赖于systemd。</p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>Do not rely on systemd as a process manager but have the docker container run your desired application in the foreground.</p></blockquote><p>有一款工具，就能够实现执行systemctl而不依赖于systemd，他就是<a href="https://github.com/gdraheim/docker-systemctl-replacement">GitHub - gdraheim&#x2F;docker-systemctl-replacement: docker systemctl replacement - allows to deploy to systemd-controlled containers without starting an actual systemd daemon (e.g. centos7, ubuntu16)</a>， 这个github仓库专门在处理这个问题。同时，如果你不想写一些dockerfile来实现上述过程，你也可以使用该作者的另一个仓库，<a href="https://github.com/gdraheim/docker-systemctl-images/blob/master/centos-httpd.dockerfile">docker-systemctl-images&#x2F;centos-httpd.dockerfile at master · gdraheim&#x2F;docker-systemctl-images · GitHub</a></p><p>在这里，作者给出了很多版本的可以使用systemctl的镜像，非常的有用。</p><h3 id="在使用systemctl的过程中，其实也踩了很多坑"><a href="#在使用systemctl的过程中，其实也踩了很多坑" class="headerlink" title="在使用systemctl的过程中，其实也踩了很多坑"></a>在使用systemctl的过程中，其实也踩了很多坑</h3><p><strong>第一个问题是，什么时候拷贝的问题？</strong></p><p>最最朴素的想法是，拷贝一次就行了呗，当初我也是这样想的，结果，水很深。</p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>Most os packages with a systemd service have declared a dependency on systemd. When you install an os package it updates systemd which overwrites &#x2F;usr&#x2F;bin&#x2F;systemctl which in turn kills the replacement functionality. The next “systemctl” is again executed by systemd which does not work in a container easily as you know. So after a os package install it helps to just drop-in the replacement script again.</p><p><a href="https://github.com/gdraheim/docker-systemctl-replacement/issues/137#issuecomment-1052164317">can not start the service when reboot? · Issue #137 · gdraheim&#x2F;docker-systemctl-replacement · GitHub</a></p></blockquote><p>这是与作者沟通时候，作者的解释，很容易懂，大致就是，安装软件时会更新systemctl，那么我们之前一次的拷贝不就失效了嘛。所以安装了软件之后，就拷贝一下吧！！！</p><p>时机：</p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>After “yum install” and before the next “systemctl” execution.</p><p><a href="https://github.com/gdraheim/docker-systemctl-replacement/issues/137#issuecomment-1052200067">can not start the service when reboot? · Issue #137 · gdraheim&#x2F;docker-systemctl-replacement · GitHub</a></p></blockquote><p><strong>第二个问题是，启动点设为systemctl还是&#x2F;bin&#x2F;bash&#x2F;还是&#x2F;usr&#x2F;sbin&#x2F;init.</strong></p><p>首先给出答案，需要设置成systemctl，因为它负责移除对systemd的依赖，所以要让它成为一号进程。</p><p>这个可以看看作者给出的dockerfile</p><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">FROM centos:7.7.1908LABEL __copyright__&#x3D;&quot;(C) Guido Draheim, licensed under the EUPL&quot; \      __version__&#x3D;&quot;1.4.4147&quot;EXPOSE 80COPY files&#x2F;docker&#x2F;systemctl.py &#x2F;usr&#x2F;bin&#x2F;systemctlRUN yum install -y httpd httpd-toolsCOPY files&#x2F;docker&#x2F;systemctl.py &#x2F;usr&#x2F;bin&#x2F;systemctlRUN echo TEST_OK &gt; &#x2F;var&#x2F;www&#x2F;html&#x2F;index.htmlRUN systemctl enable httpdCMD &#x2F;usr&#x2F;bin&#x2F;systemctl<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>**问题的根源在<code>systemctl</code>,它需要像docker容器中的systemd通信，但是却没有对象</li><li>解决问题的方法在于，解除systemctl与systemd的依赖关系，这里我们用到了一个systemctl.py的工具</li><li>使用systemctl.py需要注意拷贝的时机，以及设置systemctl作为容器一号进程</li></ul><h2 id="参考资料及备注"><a href="#参考资料及备注" class="headerlink" title="参考资料及备注"></a>参考资料及备注</h2><h3 id="一号进程有什么作用？"><a href="#一号进程有什么作用？" class="headerlink" title="一号进程有什么作用？"></a>一号进程有什么作用？</h3><p>Docker 的 stop 和 kill 命令都是用来向容器发送信号的。注意，只有容器中的 1 号进程能够收到信号，这一点非常关键！究竟谁是 1 号进程则主要由 EntryPoint, CMD, RUN 等指令的写法决定，所以这些指令的使用是很有讲究的。<a href="https://www.cnblogs.com/sparkdev/p/7598590.html">在 docker 容器中捕获信号 - sparkdev - 博客园</a></p><p>CMD 和 ENTRYPOINT 指令都支持 exec 模式和 shell 模式的写法，所以要理解 CMD 和 ENTRYPOINT 指令的用法，就得先区分 exec 模式和 shell 模式。这两种模式主要用来指定容器中的不同进程为 1 号进程。</p><p>使用 exec 模式时，容器中的任务进程就是容器内的 1 号进程，exec 模式是建议的使用模式</p><p>使用 shell 模式时，docker 会以 &#x2F;bin&#x2F;sh -c “task command” 的方式执行任务命令。也就是说容器中的 1 号进程不是任务进程而是 bash 进程</p><p>CMD 指令的目的是：为容器提供默认的执行命令。<br>CMD 指令有三种使用方式，其中的一种是为 ENTRYPOINT 提供默认的参数：<br><strong>CMD [“param1”,”param2”]</strong><br>另外两种使用方式分别是 exec 模式和 shell 模式：<br><strong>CMD [“executable”,”param1”,”param2”]</strong>    &#x2F;&#x2F; 这是 exec 模式的写法，注意需要使用双引号。<br><strong>CMD command param1 param2</strong>                  &#x2F;&#x2F; 这是 shell 模式的写法。</p><p>注意命令行参数可以覆盖 CMD 指令的设置，但是只能是重写，却不能给 CMD 中的命令通过命令行传递参数。</p><p>ENTRYPOINT 指令的目的也是为容器指定默认执行的任务。<br>ENTRYPOINT 指令有两种使用方式，就是我们前面介绍的 exec 模式和 shell 模式：<br><strong>ENTRYPOINT [“executable”, “param1”, “param2”]</strong>   &#x2F;&#x2F; 这是 exec 模式的写法，注意需要使用双引号。<br><strong>ENTRYPOINT command param1 param2</strong>                   &#x2F;&#x2F; 这是 shell 模式的写法。</p><p><strong>指定 ENTRYPOINT  指令为 exec 模式时，命令行上指定的参数会作为参数添加到 ENTRYPOINT 指定命令的参数列表中</strong></p><p>命令行参数被 ENTRYPOINT  指令的 shell 模式忽略了。</p><p><img src="https://images2018.cnblogs.com/blog/952033/201802/952033-20180223131745112-1674454515.png"></p><p><a href="https://www.ctl.io/developers/blog/post/dockerfile-entrypoint-vs-cmd/">https://www.ctl.io/developers/blog/post/dockerfile-entrypoint-vs-cmd/</a></p><h3 id="其他参考资料"><a href="#其他参考资料" class="headerlink" title="其他参考资料"></a>其他参考资料</h3><p><a href="https://stackoverflow.com/questions/39169403/not-able-to-use-systemd-on-ubuntu-docker-container">Not able to use systemd on ubuntu docker container - Stack Overflow</a></p>]]></content>
    
    
    <summary type="html">docker中单容器开启多服务时systemctl引发的血案及破案过程
问题的起源来源于，想要将一个运行在centos7上的项目，移植到docker上，实现快速部署。原项目，我们暂且称之为Myproject， 提供了install_centos7.sh和Vagrant的构建文件。Vagrant 文件工作的很好，但是笔者是在虚拟机中完成的vagrant构建的验证，也遇见了不少问题，例如嵌套虚拟化的问题

但，虚拟机里面搞总感觉不得劲，又加上vagrant比较小众，我就盯上了Docker。本来想着这不是很简单吗，pull一个centos7的image，然后run一个container，bash i</summary>
    
    
    
    <category term="编程开发" scheme="http://dianwoshishi.github.io/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
    <category term="运维管理" scheme="http://dianwoshishi.github.io/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/%E8%BF%90%E7%BB%B4%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="docker" scheme="http://dianwoshishi.github.io/tags/docker/"/>
    
    <category term="systemd" scheme="http://dianwoshishi.github.io/tags/systemd/"/>
    
    <category term="systemctl" scheme="http://dianwoshishi.github.io/tags/systemctl/"/>
    
  </entry>
  
  <entry>
    <title>Markdown相关语法学习记录</title>
    <link href="http://dianwoshishi.github.io/post/Markdown%E7%9B%B8%E5%85%B3%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.html"/>
    <id>http://dianwoshishi.github.io/post/Markdown%E7%9B%B8%E5%85%B3%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.html</id>
    <published>2022-02-27T04:15:30.000Z</published>
    <updated>2022-02-27T04:29:58.116Z</updated>
    
    <content type="html"><![CDATA[<h1 id="markdown-中流程图详解"><a href="#markdown-中流程图详解" class="headerlink" title="markdown 中流程图详解"></a>markdown 中流程图详解</h1><p><a href="https://blog.csdn.net/suoxd123/article/details/84992282">https://blog.csdn.net/suoxd123/article/details/84992282</a></p><pre class="line-numbers language-mermaid" data-language="mermaid"><code class="language-mermaid">graph TBA[Apple]--&gt;B&#123;Boy&#125;A---C(Cat)B.-&gt;D((Dog))C&#x3D;&#x3D;喵&#x3D;&#x3D;&gt;Dstyle A fill:#2ff,fill-opacity:0.1,stroke:#faa,stroke-width:4pxstyle D stroke:#000,stroke-width:8px;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-mermaid" data-language="mermaid"><code class="language-mermaid">sequenceDiagramparticipant 张 as 张三participant 李 as 李四participant 王 as  王五   张 -&gt;&gt; +李: 你好！李四, 最近怎么样?李--&gt;&gt; 王: 你最近怎么样，王五？李--x -张: 我很好，谢谢!activate 王李-x 王: 我很好，谢谢!   Note over 李,王: 李四想了很长时间, 文字太长了&lt;br&#x2F;&gt;不适合放在一行.deactivate 王loop 李四再想想李--&gt;&gt;王: 我还要想想王--&gt;&gt;李: 想想吧end李--&gt;&gt;张: 打量着王五...张-&gt;&gt;王: 很好... 王五, 你怎么样?<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实测，在本博客系统中不支持流程图特性，不过typora支持，这。。。反正不影响。先这么用着吧</p>]]></content>
    
    
    <summary type="html">markdown 中流程图详解
https://blog.csdn.net/suoxd123/article/details/84992282

graph TB
A[Apple]--&gt;B{Boy}
A---C(Cat)
B.-&gt;D((Dog))
C==喵==&gt;D
style A fill:#2ff,fill-opacity:0.1,stroke:#faa,stroke-width:4px
style D stroke:#000,stroke-width:8px;


sequenceDiagram
participant 张 as 张三
participant 李 as 李四
partici</summary>
    
    
    
    <category term="编程语言" scheme="http://dianwoshishi.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="笔记记录" scheme="http://dianwoshishi.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E7%AC%94%E8%AE%B0%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="markdown" scheme="http://dianwoshishi.github.io/tags/markdown/"/>
    
    <category term="流程图" scheme="http://dianwoshishi.github.io/tags/%E6%B5%81%E7%A8%8B%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>从hello world开始，拆解函数栈结构</title>
    <link href="http://dianwoshishi.github.io/post/%E4%BB%8Ehello%20world%E5%BC%80%E5%A7%8B%EF%BC%8C%E6%8B%86%E8%A7%A3%E5%87%BD%E6%95%B0%E6%A0%88%E7%BB%93%E6%9E%84.html"/>
    <id>http://dianwoshishi.github.io/post/%E4%BB%8Ehello%20world%E5%BC%80%E5%A7%8B%EF%BC%8C%E6%8B%86%E8%A7%A3%E5%87%BD%E6%95%B0%E6%A0%88%E7%BB%93%E6%9E%84.html</id>
    <published>2022-02-27T03:25:34.000Z</published>
    <updated>2022-02-27T03:26:09.983Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从hello-world开始，拆解函数栈结构"><a href="#从hello-world开始，拆解函数栈结构" class="headerlink" title="从hello world开始，拆解函数栈结构"></a>从hello world开始，拆解函数栈结构</h1><h2 id="第一个程序helloworld"><a href="#第一个程序helloworld" class="headerlink" title="第一个程序helloworld"></a>第一个程序helloworld</h2><h3 id="编写程序"><a href="#编写程序" class="headerlink" title="编写程序"></a>编写程序</h3><p>首先我们有如下程序：<code>main.c</code></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//main.c</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">test_stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">25</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">puts</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">test_stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述程序实现的功能很简单，就是从<code>scanf</code>输入一个字符串，赋值到<code>name</code>，并且通过<code>puts</code>打印。</p><p>是不是很简单！</p><h3 id="程序编译makefile"><a href="#程序编译makefile" class="headerlink" title="程序编译makefile"></a>程序编译makefile</h3><p>为了便于说明，我们使用makefile文件进行编译。创建文件名为<code>makefile</code>的文件，内容如下：</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token comment"># makefile</span>OBJ<span class="token operator">=</span>stack<span class="token symbol"><span class="token variable">$</span>(OBJ)</span><span class="token punctuation">:</span>gcc main.c -o <span class="token variable">$@</span><span class="token symbol">clean</span><span class="token punctuation">:</span>-rm -rf <span class="token variable">$</span><span class="token punctuation">(</span>OBJ<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们生成的文件名为<code>stack</code>，这里你可以改为你喜欢的任意名称。</p><p>使用<code>make</code>命令进行编译，会生成最终文件。运行后就可以看见输出。</p><h2 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h2><p>C语言中函数栈是如何组织的呢？都有哪些元素呢？</p><h2 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h2><p>首先，我们通过汇编代码，理解上述C语言代码，我们能更加清晰的看出一个<code>test_stack</code>函数到底干了什么。相关内容我们在其后直接进行了注释。</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm"># objdump -d .&#x2F;stack.&#x2F;stack:     file format elf64-x86-6400000000004005f6 &lt;test_stack&gt;:  4005f6:55                   push   %rbp  4005f7:48 89 e5             mov    %rsp,%rbp  4005fa:48 83 ec 30          sub    $0x30,%rsp #栈上开辟了0x30&#x3D;48的空间，注意我们的局部变量只需要25的空间  4005fe:64 48 8b 04 25 28 00 mov    %fs:0x28,%rax # 从%fs:0x28取了一个值，放在了栈底之上，这就是canary，一种栈溢出的保护措施  400605:00 00   400607:48 89 45 f8          mov    %rax,-0x8(%rbp)  40060b:31 c0                xor    %eax,%eax  40060d:48 c7 45 d0 00 00 00 movq   $0x0,-0x30(%rbp) #char name[25] &#x3D; &#123;0&#125;;  400614:00   400615:48 c7 45 d8 00 00 00 movq   $0x0,-0x28(%rbp)  40061c:00   40061d:48 c7 45 e0 00 00 00 movq   $0x0,-0x20(%rbp)  400624:00   400625:c6 45 e8 00          movb   $0x0,-0x18(%rbp)  400629:48 8d 45 d0          lea    -0x30(%rbp),%rax  40062d:48 89 c6             mov    %rax,%rsi  400630:bf 04 07 40 00       mov    $0x400704,%edi #’%s&#39;  400635:b8 00 00 00 00       mov    $0x0,%eax  40063a:e8 a1 fe ff ff       callq  4004e0 &lt;__isoc99_scanf@plt&gt;  40063f:48 8d 45 d0          lea    -0x30(%rbp),%rax  400643:48 89 c7             mov    %rax,%rdi  400646:e8 65 fe ff ff       callq  4004b0 &lt;puts@plt&gt;  40064b:b8 00 00 00 00       mov    $0x0,%eax  400650:48 8b 55 f8          mov    -0x8(%rbp),%rdx  400654:64 48 33 14 25 28 00 xor    %fs:0x28,%rdx #检查canary  40065b:00 00   40065d:74 05                je     400664 &lt;test_stack+0x6e&gt;  40065f:e8 5c fe ff ff       callq  4004c0 &lt;__stack_chk_fail@plt&gt;  400664:c9                   leaveq   400665:c3                   retq   0000000000400666 &lt;main&gt;:  400666:55                   push   %rbp  400667:48 89 e5             mov    %rsp,%rbp  40066a:b8 00 00 00 00       mov    $0x0,%eax  40066f:e8 82 ff ff ff       callq  4005f6 &lt;test_stack&gt;  400674:b8 00 00 00 00       mov    $0x0,%eax  400679:5d                   pop    %rbp  40067a:c3                   retq     40067b:0f 1f 44 00 00       nopl   0x0(%rax,%rax,1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主要进行了以下操作：</p><ul><li><strong>callq操作。</strong>我们需要注意一个隐含操作，就是上述第40行<code>callq  4005f6 &lt;test_stack&gt;</code>,这个操作隐含将下一条指令地址压栈，即0x400674</li><li><strong>开辟栈空间。</strong>开辟了大小为48的栈空间，这里注意，我们的局部变量name只需要25大小的空间</li><li><strong>canary值。</strong>从%fs:0x28取了一个值，放在了栈底之上，这就是canary，一种栈溢出的保护措施，最后对其检查</li><li><strong>初试化操作。</strong>使用3个<code>movq</code>和1个<code>movb</code>对name变量进行了初始化。name变量的起始地址为<code>$rbp-0x30$</code>即<code>$rsp$</code>栈顶</li><li><strong>赋值。</strong>使用<code>scanf</code>函数，对name变量进行了赋值</li></ul><p>其中，初始化，赋值通过汇编代码都很容易看出。下面我们通过gdb主要来看看栈结构吧。</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>使用gdb+pwngdb插件进行解释，如不清楚，可私信我或加我公众号。</p><h3 id="callq操作"><a href="#callq操作" class="headerlink" title="callq操作"></a>callq操作</h3><p>![image-20210721000901757](从hello world开始，拆解函数栈结构&#x2F;image-20210721000901757.png)</p><p>在进行callq操作之前，rbp和rsp为同一地址，说明栈空间大小为0.</p><p>![image-20210721001254187](从hello world开始，拆解函数栈结构&#x2F;image-20210721001254187.png)</p><p>注意箭头部分，当我们进入<code>test_stack</code>函数时，callq操作，进行了隐含操作，callq的下一条指令地址压栈，在这里我们可以看出，其内容为<code>0x400674</code>，与我们静态分析汇编代码一致。验证了callq操作对栈的影响。</p><h3 id="开辟栈空间"><a href="#开辟栈空间" class="headerlink" title="开辟栈空间"></a>开辟栈空间</h3><p>此操作中，注意rsp和rbp的变化。</p><ul><li>push指令，将栈底压栈。</li></ul><p>![image-20210721001715969](从hello world开始，拆解函数栈结构&#x2F;image-20210721001715969.png)</p><ul><li>将栈底和栈顶地址设为相同（可通过栈底的上一条内容01：0008，恢复上一个栈底）。</li></ul><p>![image-20210721001827503](从hello world开始，拆解函数栈结构&#x2F;image-20210721001827503.png)</p><ul><li>开辟栈空间，大小为0x30&#x3D;48。</li></ul><p>![image-20210721002102212](从hello world开始，拆解函数栈结构&#x2F;image-20210721002102212.png)</p><p>红框中<code>[00:0000-06:0030)</code>之间，为当前<code>test_stack</code>栈帧中的结构，大小为0x30&#x3D;48字节。中间的数据为一些初始化函数执行过程中残留的栈数据，暂时不用管它。(s + buffer + canary)</p><p>rbp为test_stack函数的第一个push rbp的操作压入的栈底（saved ebp)</p><p>07:0038为test_stack函数执行完毕后的返回地址。(return address)</p><p>示意图如下：</p><p><img src="https://manybutfinite.com/img/stack/bufferCanary.png" alt="See the source image"></p><h3 id="canary值"><a href="#canary值" class="headerlink" title="canary值"></a>canary值</h3><p>如下图，我们继续执行两步，该函数在<code>fs:[0x28]</code>处取了一个值，然后放入了rbp-8的位置，即图中画线的位置，值为：0x92cb97cb6f51ae00，这个数就是我们所谓的canary，金丝雀。主要用来检测栈溢出。</p><p>![image-20210721003510355](从hello world开始，拆解函数栈结构&#x2F;image-20210721003510355.png)</p><p>然后我们查看栈顶开始的48个字节，即栈的内容</p><p>![image-20210721004153415](从hello world开始，拆解函数栈结构&#x2F;image-20210721004153415.png)</p><p>s: 0x7fffffffddd0:    （0x00000000    0x00000000    0x00000000    0x00000000<br>0x7fffffffdde0:    0x00000000    0x00000000    0x00）s表示我们局部变量填充的空间         </p><p>buffer: (000000    0x00000000<br>0x7fffffffddf0:    0x00400680    0x00000000)buffer    代表补齐8字节所占用的空间</p><p>canary: (0x6f51ae00    0x92cb97cb)canary 代表栈溢出检测指标。</p><p><img src="https://manybutfinite.com/img/stack/bufferCanary.png" alt="See the source image"></p><p>通过IDA pro验证我们的想法：</p><p>![image-20210721010044515](从hello world开始，拆解函数栈结构&#x2F;image-20210721010044515.png)</p><h2 id="缓冲区溢出分析"><a href="#缓冲区溢出分析" class="headerlink" title="缓冲区溢出分析"></a>缓冲区溢出分析</h2><p>实际上我们花了大量的篇幅去讲栈的结构，其实目的就是这么一张图</p><p><img src="https://manybutfinite.com/img/stack/bufferCanary.png" alt="See the source image"></p><p>栈溢出其实就是使得字符串长度达到return address的位置，使得在函数执行完毕retn时，return address的地址弹出给rip寄存器，从而使得CPU按照rip寄存的内容执行下一条指令。这里面要非常清楚的就是栈的结构，栈空间的计算真正要做到”一字不差“！</p><p>当然了，这里的canary对栈进行了保护，是一个随机生成的数。当然还有很多办法来绕过甚至是猜出canary，实现栈溢出，这不在本篇文章的范畴之内，留给下一次机会吧。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对通过一个最简单的程序对栈的结构进行了静态和动态的分析，得出了一张刻画栈帧空间的图。对于栈的计算要十分的仔细，这样在pwn题中才能做到心中有数，一招制敌。</p>]]></content>
    
    
    <summary type="html">从hello world开始，拆解函数栈结构
第一个程序helloworld
编写程序
首先我们有如下程序：main.c

//main.c
#include&lt;stdio.h&gt;
int test_stack(){
	char name[25] = {0};
	scanf(&quot;%s&quot;, name);
	puts(name);
	return 0;
}
int main(){
	test_stack();
	return 0;
}

上述程序实现的功能很简单，就是从scanf输入一个字符串，赋值到name，并且通过puts打印。

是不是很简单！

程序编译makefile
为了便于说明，我们使用m</summary>
    
    
    
    
    <category term="C语言" scheme="http://dianwoshishi.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="汇编" scheme="http://dianwoshishi.github.io/tags/%E6%B1%87%E7%BC%96/"/>
    
    <category term="Linux" scheme="http://dianwoshishi.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>在你的hexo博客中使用nodeppt，一款迄今为止最好的网页版演示库</title>
    <link href="http://dianwoshishi.github.io/post/NODEPPT%E8%BF%99%E5%8F%AF%E8%83%BD%E6%98%AF%E8%BF%84%E4%BB%8A%E4%B8%BA%E6%AD%A2%E6%9C%80%E5%A5%BD%E7%9A%84%E7%BD%91%E9%A1%B5%E7%89%88%E6%BC%94%E7%A4%BA%E5%BA%93.html"/>
    <id>http://dianwoshishi.github.io/post/NODEPPT%E8%BF%99%E5%8F%AF%E8%83%BD%E6%98%AF%E8%BF%84%E4%BB%8A%E4%B8%BA%E6%AD%A2%E6%9C%80%E5%A5%BD%E7%9A%84%E7%BD%91%E9%A1%B5%E7%89%88%E6%BC%94%E7%A4%BA%E5%BA%93.html</id>
    <published>2022-02-26T09:25:15.461Z</published>
    <updated>2022-02-26T12:16:28.949Z</updated>
    
    <content type="html"><![CDATA[<p>大家好，我是明说网络的小明同学。</p><p>今天我和大家分享一个非常酷的网页PPT工具，NODEPPT</p><h1 id="NODEPPT这可能是迄今为止最好的网页版演示库"><a href="#NODEPPT这可能是迄今为止最好的网页版演示库" class="headerlink" title="NODEPPT这可能是迄今为止最好的网页版演示库"></a>NODEPPT这可能是迄今为止最好的网页版演示库</h1><p>一开始看到这个库的时候，我就喜欢上了。因为他效果非常的棒，而且能够非常好的和hexo结合。这样我们能够一次生成，到哪都可以演示PPT，还能配上相应的技术文档，是不是很酷啊！</p><h2 id="NODEPPT-Demo"><a href="#NODEPPT-Demo" class="headerlink" title="NODEPPT Demo"></a>NODEPPT Demo</h2><p>项目的演示网址在这：<a href="https://nodeppt.js.org/#slide=1">https://nodeppt.js.org/#slide=1</a></p><p><img src="/post/NODEPPT%E8%BF%99%E5%8F%AF%E8%83%BD%E6%98%AF%E8%BF%84%E4%BB%8A%E4%B8%BA%E6%AD%A2%E6%9C%80%E5%A5%BD%E7%9A%84%E7%BD%91%E9%A1%B5%E7%89%88%E6%BC%94%E7%A4%BA%E5%BA%93/image-20220226172518524.png" alt="image-20220226172518524"></p><p>主要说明了这个库包含什么样的功能</p><h2 id="NODE-PPT-Github"><a href="#NODE-PPT-Github" class="headerlink" title="NODE PPT Github"></a>NODE PPT Github</h2><p>官网地址：<a href="https://github.com/ksky521/nodeppt">https://github.com/ksky521/nodeppt</a></p><h1 id="Hexo中使用PPT-Demo"><a href="#Hexo中使用PPT-Demo" class="headerlink" title="Hexo中使用PPT Demo"></a>Hexo中使用PPT Demo</h1><p>以下是我使用官网的<a href="https://raw.githubusercontent.com/ksky521/nodeppt/master/site/index.md">demo</a>制作的一个PPT，注意它是嵌入在我这个网页中的，以下网页你可以左右滑动。</p><iframe src="../nodeppt/slides.html" width="100%" height="500" name="topFrame" scrolling="yes" noresize="noresize" frameborder="0" id="topFrame"></iframe><p>如果你觉得这个功能很酷，想要添加到你的站点里面去，那么就和我一起往下走吧。</p><h2 id="如何在Hexo中添加Nodeppt"><a href="#如何在Hexo中添加Nodeppt" class="headerlink" title="如何在Hexo中添加Nodeppt"></a>如何在Hexo中添加Nodeppt</h2><p>前提，确保你的noteppt能够正常使用。这是前提，至于怎么熟练的玩好nodeppt，额…… 还是去官网吧，这里不误导人了。</p><p>整体的思路是，两步走：</p><ul><li>第一步先使用nodeppt在相应的public目录生成相应的文件,如html,js,img等等</li><li>在post中引用相应的文件</li></ul><h3 id="首先熟悉nodeppt的build方法"><a href="#首先熟悉nodeppt的build方法" class="headerlink" title="首先熟悉nodeppt的build方法"></a>首先熟悉nodeppt的build方法</h3><p>输入<code>nodeppt build --help</code></p><pre class="line-numbers language-none"><code class="language-none">Usage: nodeppt build [options] [entry]build html fileOptions:  -m, --map         Release sourcemap  -d, --dest &lt;dir&gt;  output directory  -h, --help        output usage information  Examples:    nodeppt build slide.md<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们需要使用的就是这个<code>-d</code>参数。目的是将生成的文件放入网站的public目录下</p><h3 id="源文件目录说明"><a href="#源文件目录说明" class="headerlink" title="源文件目录说明"></a>源文件目录说明</h3><p>存放源文件的目录结构如下所示</p><pre class="line-numbers language-none"><code class="language-none">root&#x2F;public├──nodepptroot&#x2F;source├── slideshare│   ├── another.md│   ├── build.sh│   ├── buildlist.txt│   ├── makefile│   └── slides.md<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>buildlist.txt 代表等待生成的ppt文件列表</li></ul><pre class="line-numbers language-none"><code class="language-none">slides.mdanother.md%<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><p>build.sh </p><p>在slideshare目录下运行本文件，作用是使用nodeppt按上面文件内容的顺序构建，输出目录为<code>public/nodeppt</code></p></li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">NODEPPT&#x3D;&#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;node&#x2F;17.5.0&#x2F;bin&#x2F;nodepptDestination&#x3D;..&#x2F;..&#x2F;public&#x2F;nodeppt&#x2F;build_files&#x3D;$(cat buildlist.txt | xargs)for file in $build_filesdo    # echo $file    $NODEPPT build .&#x2F;$file -d $Destinationdone<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>makefile 本文件主要用于使用一个脚本完成所有的工作</li></ul><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token symbol">all</span><span class="token punctuation">:</span>        bash build.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>至此，你使用在当前目录<code>make</code>就能将生成好的PPT网页放入public目录的noteppt目录中。</p><h3 id="那么怎么使用呢？"><a href="#那么怎么使用呢？" class="headerlink" title="那么怎么使用呢？"></a>那么怎么使用呢？</h3><p>在上一步中，我们生成了ppt文件，放在了<code>public/nodeppt/</code>中，假设文件名为<code>slides.html</code></p><p>那么我们可以在hexo的post中简单的使用如下命令，就可以引用我们的PPT</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>iframe</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>../nodeppt/slides.html<span class="token punctuation">"</span></span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>100%<span class="token punctuation">"</span></span> <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>500<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>topFrame<span class="token punctuation">"</span></span> <span class="token attr-name">scrolling</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>yes<span class="token punctuation">"</span></span> <span class="token attr-name">noresize</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>noresize<span class="token punctuation">"</span></span> <span class="token attr-name">frameborder</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>topFrame<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>iframe</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>需要修改的部分就是iframe中的src部分。</p><p>最后放下一个一键上线部署的脚本</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token symbol">all</span><span class="token punctuation">:</span>make nodeppthexo g hexo d <span class="token symbol">nodeppt</span><span class="token punctuation">:</span><span class="token variable">$</span><span class="token punctuation">(</span>MAKE<span class="token punctuation">)</span> -C source/slideshare/<span class="token symbol">test</span><span class="token punctuation">:</span>make nodeppthexo ghexo s<span class="token symbol">deploy</span><span class="token punctuation">:</span>make nodeppthexo g hexo d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="最后附上本次示例的PPT"><a href="#最后附上本次示例的PPT" class="headerlink" title="最后附上本次示例的PPT"></a>最后附上本次示例的PPT</h2><p>试试看左右滑动</p><iframe src="../nodeppt/use-nodeppt-in-hexo-demo.html" width="100%" height="500" name="topFrame" scrolling="yes" noresize="noresize" frameborder="0" id="topFrame"></iframe><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><h2 id="静态压缩"><a href="#静态压缩" class="headerlink" title="静态压缩"></a>静态压缩</h2><p><a href="https://hasaik.com/posts/495d0b23.html">https://hasaik.com/posts/495d0b23.html</a></p><p>使用Hexo-Neat成功<a href="https://github.com/rozbo/hexo-neat">https://github.com/rozbo/hexo-neat</a></p><p>Hexo静态资源压缩<a href="https://www.jianshu.com/p/5e48e532ae58">https://www.jianshu.com/p/5e48e532ae58</a></p><p><a href="https://rye-catcher.github.io/2019/10/21/Nodeppt-%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97/">https://rye-catcher.github.io/2019/10/21/Nodeppt-%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97/</a></p><p>给博客文章嵌入 PPT 演示<a href="https://hexo.fluid-dev.com/posts/hexo-nodeppt/">https://hexo.fluid-dev.com/posts/hexo-nodeppt/</a></p><h3 id="添加自定义网页"><a href="#添加自定义网页" class="headerlink" title="添加自定义网页"></a>添加自定义网页</h3><p><a href="https://www.jianshu.com/p/524b073f9b37">https://www.jianshu.com/p/524b073f9b37</a></p>]]></content>
    
    
    <summary type="html">大家好，我是明说网络的小明同学。

今天我和大家分享一个非常酷的网页PPT工具，NODEPPT

NODEPPT这可能是迄今为止最好的网页版演示库
一开始看到这个库的时候，我就喜欢上了。因为他效果非常的棒，而且能够非常好的和hexo结合。这样我们能够一次生成，到哪都可以演示PPT，还能配上相应的技术文档，是不是很酷啊！

NODEPPT Demo
项目的演示网址在这：https://nodeppt.js.org/#slide=1



主要说明了这个库包含什么样的功能

NODE PPT Github
官网地址：https://github.com/ksky521/nodeppt

Hexo中</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>VSCode Markdown Snippet插件的使用问题备注</title>
    <link href="http://dianwoshishi.github.io/post/VSCode%20Markdown%20Snippet%E6%8F%92%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E5%A4%87%E6%B3%A8.html"/>
    <id>http://dianwoshishi.github.io/post/VSCode%20Markdown%20Snippet%E6%8F%92%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E5%A4%87%E6%B3%A8.html</id>
    <published>2022-02-26T09:22:13.000Z</published>
    <updated>2022-02-26T09:20:42.785Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VSCode-Markdown-Snippet插件的使用问题备注"><a href="#VSCode-Markdown-Snippet插件的使用问题备注" class="headerlink" title="VSCode Markdown Snippet插件的使用问题备注"></a>VSCode Markdown Snippet插件的使用问题备注</h1><h2 id="官方给出的使用帮助"><a href="#官方给出的使用帮助" class="headerlink" title="官方给出的使用帮助"></a>官方给出的使用帮助</h2><p><a href="https://code.visualstudio.com/docs/editor/userdefinedsnippets">https://code.visualstudio.com/docs/editor/userdefinedsnippets</a></p><h2 id="一个简短的示例"><a href="#一个简短的示例" class="headerlink" title="一个简短的示例"></a>一个简短的示例</h2><p><a href="https://www.jianshu.com/p/a87e9ca2d208">https://www.jianshu.com/p/a87e9ca2d208</a></p><p>记得在配置文件中添加相应的配置，不仅仅是相关语言的配置哦，setting中也记得</p><p><a href="https://blog.csdn.net/serryuer/article/details/89393760">https://blog.csdn.net/serryuer/article/details/89393760</a></p><h2 id="代码备注"><a href="#代码备注" class="headerlink" title="代码备注"></a>代码备注</h2><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token property">"hexo title"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token property">"prefix"</span><span class="token operator">:</span> <span class="token string">"hexo"</span><span class="token punctuation">,</span><span class="token property">"body"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"---"</span><span class="token punctuation">,</span><span class="token string">"title: $CLIPBOARD"</span><span class="token punctuation">,</span><span class="token string">"date: $&#123;3:$CURRENT_YEAR&#125;-$&#123;4:$CURRENT_MONTH&#125;-$&#123;5:$CURRENT_DATE&#125; $&#123;6:$CURRENT_HOUR&#125;:$&#123;7:$CURRENT_MINUTE&#125;:$&#123;8:$CURRENT_SECOND&#125;"</span><span class="token punctuation">,</span><span class="token comment">// "categories: $&#123;9|咨询, 编程开发, 网络空间, 学习笔记, 科普|&#125;",</span><span class="token comment">// "tags: [$&#123;10:tags&#125;]",</span><span class="token string">"---"</span><span class="token punctuation">,</span><span class="token string">"$11"</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token property">"description"</span><span class="token operator">:</span> <span class="token string">"Front-Matter"</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>效果如下所示：</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">---title: 大家好，我是明说网络的小明同学date: 2022-02-26 17:20:22---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
    <summary type="html">VSCode Markdown Snippet插件的使用问题备注
官方给出的使用帮助
https://code.visualstudio.com/docs/editor/userdefinedsnippets

一个简短的示例
https://www.jianshu.com/p/a87e9ca2d208

记得在配置文件中添加相应的配置，不仅仅是相关语言的配置哦，setting中也记得

https://blog.csdn.net/serryuer/article/details/89393760

代码备注
&quot;hexo title&quot;: {
		&quot;prefix&quot;: &quot;hexo&quot;,
		&quot;bod</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>一个github快速建站主题推荐GitHub+Hexo+AURORA</title>
    <link href="http://dianwoshishi.github.io/post/%E4%B8%80%E4%B8%AAgithub%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%99%E4%B8%BB%E9%A2%98%E6%8E%A8%E8%8D%90.html"/>
    <id>http://dianwoshishi.github.io/post/%E4%B8%80%E4%B8%AAgithub%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%99%E4%B8%BB%E9%A2%98%E6%8E%A8%E8%8D%90.html</id>
    <published>2022-02-26T07:22:13.000Z</published>
    <updated>2022-02-26T09:23:50.522Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title: 大家好，我是明说网络的小明同学<br>date: 2022-02-26 17:20:22</p><hr><p>大家好，我是明说网络的小明同学</p><p>今天给大家推荐一块非常快速的建站工具Github + AURORA</p><h1 id="Github建站"><a href="#Github建站" class="headerlink" title="Github建站"></a>Github建站</h1><p>github免费建站就不说了，网上有很多教程。</p><h1 id="Hexo快速生成可以用Markdown协作写作的网站"><a href="#Hexo快速生成可以用Markdown协作写作的网站" class="headerlink" title="Hexo快速生成可以用Markdown协作写作的网站"></a>Hexo快速生成可以用Markdown协作写作的网站</h1><p>如果你还没有使用过Hexo，那么从官方文档里可以快速学会使用。<a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a></p><p>Hexo一个比较吸引我的功能就是，能够以极少的代价，完成网站主题的切换。</p><p>必备评论插件GitTalk，可以看这篇文章</p><p><a href="https://blog.csdn.net/qq_33384402/article/details/107200465">https://blog.csdn.net/qq_33384402/article/details/107200465</a></p><h1 id="推荐一块比较好的主题AURORA"><a href="#推荐一块比较好的主题AURORA" class="headerlink" title="推荐一块比较好的主题AURORA"></a>推荐一块比较好的主题AURORA</h1><p>插件主题长这个样子</p><p><img src="/post/%E4%B8%80%E4%B8%AAgithub%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%99%E4%B8%BB%E9%A2%98%E6%8E%A8%E8%8D%90/image-20220226162421002.png" alt="image-20220226162421002"></p><p>插件具有详细的说明文档 <a href="https://aurora.tridiamond.tech/zh/guide/">https://aurora.tridiamond.tech/zh/guide/</a></p><p>该主题的网址：<a href="https://github.com/auroral-ui/hexo-theme-aurora">https://github.com/auroral-ui/hexo-theme-aurora</a></p><h1 id="关于图片显示的问题"><a href="#关于图片显示的问题" class="headerlink" title="关于图片显示的问题"></a>关于图片显示的问题</h1><p>关于图片显示，建议看这篇文章，<a href="https://moeci.com/posts/hexo-typora/">https://moeci.com/posts/hexo-typora/</a></p><p>描述了，怎么结合hexo和typora来实现markdown无缝衔接，并且还能深入了解图片出错到底是什么原因</p><p>不过该博主的插件最终也没有让我成功，还是hexo-asset-image救了我<a href="https://github.com/xcodebuild/hexo-asset-image">https://github.com/xcodebuild/hexo-asset-image</a></p><h1 id="最后给自己打个广告吧"><a href="#最后给自己打个广告吧" class="headerlink" title="最后给自己打个广告吧"></a>最后给自己打个广告吧</h1><p>发现大家都好牛啊！</p><p><img src="/post/%E4%B8%80%E4%B8%AAgithub%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%99%E4%B8%BB%E9%A2%98%E6%8E%A8%E8%8D%90/image-20220226163311302.png" alt="image-20220226163311302"></p><p>大家可以通过主页的相关链接在你喜欢的平台找到我！</p>]]></content>
    
    
    <summary type="html">title: 大家好，我是明说网络的小明同学
date: 2022-02-26 17:20:22




大家好，我是明说网络的小明同学

今天给大家推荐一块非常快速的建站工具Github + AURORA

Github建站
github免费建站就不说了，网上有很多教程。

Hexo快速生成可以用Markdown协作写作的网站
如果你还没有使用过Hexo，那么从官方文档里可以快速学会使用。https://hexo.io/zh-cn/docs/

Hexo一个比较吸引我的功能就是，能够以极少的代价，完成网站主题的切换。

必备评论插件GitTalk，可以看这篇文章

https://blog.</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>从一个hello world说起</title>
    <link href="http://dianwoshishi.github.io/post/%E4%BB%8E%E4%B8%80%E4%B8%AAhello%20world%E8%AF%B4%E8%B5%B7.html"/>
    <id>http://dianwoshishi.github.io/post/%E4%BB%8E%E4%B8%80%E4%B8%AAhello%20world%E8%AF%B4%E8%B5%B7.html</id>
    <published>2022-02-26T06:14:18.000Z</published>
    <updated>2022-02-26T06:14:24.236Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从一个hello-world说起"><a href="#从一个hello-world说起" class="headerlink" title="从一个hello world说起"></a>从一个hello world说起</h1><p>大家好，我是明说网络的小明同学。今天我们从C语言的Hello World说起，和大家一起温习一下C语言中一个Hello World怎么运行起来的，以及C语言如何组织栈缓冲区等。本文不适用于C语言初学者，需要具备有一定的汇编基础。好了下面，我们开始吧。</p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>本文的工具为：</p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">操作系统：Ubuntu16.04， 4.15.0-142-generic编译器：gcc version 5.4.0 20160609 (Ubuntu 5.4.0-6ubuntu1~16.04.12)make工具GNU Make 4.1反汇编查看器：objdumpelf文件查看器：readelfgdb，pwngdb<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="C语言介绍"><a href="#C语言介绍" class="headerlink" title="C语言介绍"></a>C语言介绍</h2><p>C 语言是一种通用的高级语言，最初是由丹尼斯·里奇在贝尔实验室为开发 UNIX 操作系统而设计的。UNIX 操作系统，C编译器，和几乎所有的 UNIX 应用程序都是用 C 语言编写的。由于各种原因，C 语言现在已经成为一种广泛使用的专业语言。</p><p>同时，C语言是一门大学期间基本上都会开设的课程。作为一门入门编程课程，C语言有着独特的魅力和不可替代的作用。虽然当前python火热，C语言好像显得不那么重要了，“python难道不香吗”的疑问开始出现。但是我的观点是：每种语言有每种语言的优势，python永远也取代不了C语言。像我独爱指针，能够带来自由的感觉。</p><p>下面就开始我们的探索之旅吧。</p><h2 id="第一个程序helloworld"><a href="#第一个程序helloworld" class="headerlink" title="第一个程序helloworld"></a>第一个程序helloworld</h2><h3 id="编写程序"><a href="#编写程序" class="headerlink" title="编写程序"></a>编写程序</h3><p>首先我们有如下程序：<code>main.c</code></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//main.c</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hello world! %s\n"</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"I'm a string"</span><span class="token punctuation">;</span><span class="token function">display</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述程序实现的功能很简单，就是输出一句话<code>hello world! I&#39;m a string</code>，为了便于说明，其中故意使用了一个函数调用<code>int display(char *)</code>。</p><p>函数的逻辑为，main函数–&gt; display()函数(一个参数)–&gt;printf函数(两个参数)。</p><p>是不是很简单！</p><h3 id="程序编译makefile"><a href="#程序编译makefile" class="headerlink" title="程序编译makefile"></a>程序编译makefile</h3><p>为了便于说明，我们使用makefile文件进行编译。创建文件名为<code>makefile</code>的文件，内容如下：</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token comment"># makefile</span>OBJ<span class="token operator">=</span>printf.main<span class="token symbol"><span class="token variable">$</span>(OBJ)</span><span class="token punctuation">:</span>gcc main.c -o <span class="token variable">$@</span><span class="token symbol">clean</span><span class="token punctuation">:</span>-rm <span class="token variable">$</span><span class="token punctuation">(</span>OBJ<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们生成的文件名为<code>printf.main</code>，这里你可以改为你喜欢的任意名称。</p><p>使用<code>make</code>命令进行编译，会生成最终文件。运行后就可以看见<code>hello world! I&#39;m a string</code></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>到这里我们就完成了一个helloworld程序的编写和编译，并且运行。是不是很简单。对于初学者，其实到这里就完了，姑且可以认为main函数就是一个程序的开始和结束（我曾经就一直这么认为）。但是对于有过一定经验的人来说，就知道：main函数并不是一个程序的开始，也不是一个程序的结束。</p><p>咦，这么神奇的吗？就让我们来看看吧。</p><h2 id="Hello-world-的背后"><a href="#Hello-world-的背后" class="headerlink" title="Hello world 的背后"></a>Hello world 的背后</h2><p>首先让我们来认识一下我们生成的<code>printf.main。</code></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">file .&#x2F;printf.main .&#x2F;printf.main: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter &#x2F;lib64&#x2F;ld-linux-x86-64.so.2, for GNU&#x2F;Linux 2.6.32, BuildID[sha1]&#x3D;5c389a402866aaa012b8b8ab992fed778eb989b0, not stripped<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>ELF是执行和链接格式（Execurable and Linking Format）的缩略词。它是UNIX系统的几种可执行文件格式中的一种。</p><p>使用命令<code>readelf -h ./printf.main &gt; elf_head.txt</code></p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">ELF Header:  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00   Class:                             ELF64  Data:                              2&#39;s complement, little endian  Version:                           1 (current)  OS&#x2F;ABI:                            UNIX - System V  ABI Version:                       0  Type:                              EXEC (Executable file)  Machine:                           Advanced Micro Devices X86-64  Version:                           0x1  Entry point address:               0x4004a0 &#x2F;&#x2F;注意这一行  Start of program headers:          64 (bytes into file)  Start of section headers:          6712 (bytes into file)  Flags:                             0x0  Size of this header:               64 (bytes)  Size of program headers:           56 (bytes)  Number of program headers:         9  Size of section headers:           64 (bytes)  Number of section headers:         31  Section header string table index: 28<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里面，我们注意第11行，<code>Entry point address:               0x4004a0</code>,显示，入口点地址为address，说明操作系统在运行这个<code>printf.main</code>程序时，首先从这个地址开始运行。那么我们看看这个地址到底是什么吧</p><h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><p>使用命令<code>objdump -d printf.main &gt; objdump.txt</code>将程序的汇编代码提取出来（删除了一些当前没有必要说明的内容），如下所示：</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">printf.main:     file format elf64-x86-64Disassembly of section .init:0000000000400428 &lt;_init&gt;:  400428:48 83 ec 08          sub    $0x8,%rsp  40042c:48 8b 05 c5 0b 20 00 mov    0x200bc5(%rip),%rax        # 600ff8 &lt;_DYNAMIC+0x1d0&gt;  400433:48 85 c0             test   %rax,%rax  400436:74 05                je     40043d &lt;_init+0x15&gt;  400438:e8 53 00 00 00       callq  400490 &lt;__libc_start_main@plt+0x10&gt;  40043d:48 83 c4 08          add    $0x8,%rsp  400441:c3                   retq   Disassembly of section .plt:0000000000400470 &lt;printf@plt&gt;:  400470:ff 25 aa 0b 20 00    jmpq   *0x200baa(%rip)        # 601020 &lt;_GLOBAL_OFFSET_TABLE_+0x20&gt;  400476:68 01 00 00 00       pushq  $0x1  40047b:e9 d0 ff ff ff       jmpq   400450 &lt;_init+0x28&gt;0000000000400480 &lt;__libc_start_main@plt&gt;:  400480:ff 25 a2 0b 20 00    jmpq   *0x200ba2(%rip)        # 601028 &lt;_GLOBAL_OFFSET_TABLE_+0x28&gt;  400486:68 02 00 00 00       pushq  $0x2  40048b:e9 c0 ff ff ff       jmpq   400450 &lt;_init+0x28&gt;Disassembly of section .plt.got:0000000000400490 &lt;.plt.got&gt;:  400490:ff 25 62 0b 20 00    jmpq   *0x200b62(%rip)        # 600ff8 &lt;_DYNAMIC+0x1d0&gt;  400496:66 90                xchg   %ax,%axDisassembly of section .text:00000000004004a0 &lt;_start&gt;:  4004a0:31 ed                xor    %ebp,%ebp  4004a2:49 89 d1             mov    %rdx,%r9  4004a5:5e                   pop    %rsi  4004a6:48 89 e2             mov    %rsp,%rdx  4004a9:48 83 e4 f0          and    $0xfffffffffffffff0,%rsp  4004ad:50                   push   %rax  4004ae:54                   push   %rsp  4004af:49 c7 c0 b0 06 40 00 mov    $0x4006b0,%r8 &#x2F;&#x2F;00000000004006b0 &lt;__libc_csu_fini&gt;:  4004b6:48 c7 c1 40 06 40 00 mov    $0x400640,%rcx &#x2F;&#x2F;0000000000400640 &lt;__libc_csu_init&gt;:  4004bd:48 c7 c7 bb 05 40 00 mov    $0x4005bb,%rdi &#x2F;&#x2F;00000000004005bb &lt;main&gt;:  4004c4:e8 b7 ff ff ff       callq  400480 &lt;__libc_start_main@plt&gt;  4004c9:f4                   hlt      4004ca:66 0f 1f 44 00 00    nopw   0x0(%rax,%rax,1)0000000000400596 &lt;display&gt;:  400596:55                   push   %rbp  400597:48 89 e5             mov    %rsp,%rbp  40059a:48 83 ec 10          sub    $0x10,%rsp  40059e:48 89 7d f8          mov    %rdi,-0x8(%rbp)  4005a2:48 8b 45 f8          mov    -0x8(%rbp),%rax  4005a6:48 89 c6             mov    %rax,%rsi  4005a9:bf c4 06 40 00       mov    $0x4006c4,%edi  4005ae:b8 00 00 00 00       mov    $0x0,%eax  4005b3:e8 b8 fe ff ff       callq  400470 &lt;printf@plt&gt;  4005b8:90                   nop  4005b9:c9                   leaveq   4005ba:c3                   retq   00000000004005bb &lt;main&gt;:  4005bb:55                   push   %rbp  4005bc:48 89 e5             mov    %rsp,%rbp  4005bf:48 81 ec 10 01 00 00 sub    $0x110,%rsp  4005c6:64 48 8b 04 25 28 00 mov    %fs:0x28,%rax  4005cd:00 00   4005cf:48 89 45 f8          mov    %rax,-0x8(%rbp)  4005d3:31 c0                xor    %eax,%eax  4005d5:48 b8 49 27 6d 20 61 movabs $0x74732061206d2749,%rax  4005dc:20 73 74   4005df:48 89 85 f0 fe ff ff mov    %rax,-0x110(%rbp)  4005e6:48 c7 85 f8 fe ff ff movq   $0x676e6972,-0x108(%rbp)  4005ed:72 69 6e 67   4005f1:48 8d 95 00 ff ff ff lea    -0x100(%rbp),%rdx  4005f8:b8 00 00 00 00       mov    $0x0,%eax  4005fd:b9 1e 00 00 00       mov    $0x1e,%ecx  400602:48 89 d7             mov    %rdx,%rdi  400605:f3 48 ab             rep stos %rax,%es:(%rdi)  400608:48 8d 85 f0 fe ff ff lea    -0x110(%rbp),%rax  40060f:48 89 c7             mov    %rax,%rdi  400612:e8 7f ff ff ff       callq  400596 &lt;display&gt;  400617:b8 00 00 00 00       mov    $0x0,%eax  40061c:48 8b 75 f8          mov    -0x8(%rbp),%rsi  400620:64 48 33 34 25 28 00 xor    %fs:0x28,%rsi  400627:00 00   400629:74 05                je     400630 &lt;main+0x75&gt;  40062b:e8 30 fe ff ff       callq  400460 &lt;__stack_chk_fail@plt&gt;  400630:c9                   leaveq   400631:c3                   retq     400632:66 2e 0f 1f 84 00 00 nopw   %cs:0x0(%rax,%rax,1)  400639:00 00 00   40063c:0f 1f 40 00          nopl   0x0(%rax)0000000000400640 &lt;__libc_csu_init&gt;:  400640:41 57                push   %r15  400642:41 56                push   %r14  400644:41 89 ff             mov    %edi,%r15d  400647:41 55                push   %r13  400649:41 54                push   %r12  40064b:4c 8d 25 be 07 20 00 lea    0x2007be(%rip),%r12        # 600e10 &lt;__frame_dummy_init_array_entry&gt;  400652:55                   push   %rbp  400653:48 8d 2d be 07 20 00 lea    0x2007be(%rip),%rbp        # 600e18 &lt;__init_array_end&gt;  40065a:53                   push   %rbx  40065b:49 89 f6             mov    %rsi,%r14  40065e:49 89 d5             mov    %rdx,%r13  400661:4c 29 e5             sub    %r12,%rbp  400664:48 83 ec 08          sub    $0x8,%rsp  400668:48 c1 fd 03          sar    $0x3,%rbp  40066c:e8 b7 fd ff ff       callq  400428 &lt;_init&gt;  400671:48 85 ed             test   %rbp,%rbp  400674:74 20                je     400696 &lt;__libc_csu_init+0x56&gt;  400676:31 db                xor    %ebx,%ebx  400678:0f 1f 84 00 00 00 00 nopl   0x0(%rax,%rax,1)  40067f:00   400680:4c 89 ea             mov    %r13,%rdx  400683:4c 89 f6             mov    %r14,%rsi  400686:44 89 ff             mov    %r15d,%edi  400689:41 ff 14 dc          callq  *(%r12,%rbx,8)  40068d:48 83 c3 01          add    $0x1,%rbx  400691:48 39 eb             cmp    %rbp,%rbx  400694:75 ea                jne    400680 &lt;__libc_csu_init+0x40&gt;  400696:48 83 c4 08          add    $0x8,%rsp  40069a:5b                   pop    %rbx  40069b:5d                   pop    %rbp  40069c:41 5c                pop    %r12  40069e:41 5d                pop    %r13  4006a0:41 5e                pop    %r14  4006a2:41 5f                pop    %r15  4006a4:c3                   retq     4006a5:90                   nop  4006a6:66 2e 0f 1f 84 00 00 nopw   %cs:0x0(%rax,%rax,1)  4006ad:00 00 00 00000000004006b0 &lt;__libc_csu_fini&gt;:  4006b0:f3 c3                repz retq Disassembly of section .fini:00000000004006b4 &lt;_fini&gt;:  4006b4:48 83 ec 08          sub    $0x8,%rsp  4006b8:48 83 c4 08          add    $0x8,%rsp  4006bc:c3                   retq   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里我们注意第45，46，47，48行，注意其中</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">4004af:49 c7 c0 b0 06 40 00 mov    $0x4006b0,%r8 &#x2F;&#x2F;00000000004006b0 &lt;__libc_csu_fini&gt;:4004b6:48 c7 c1 40 06 40 00 mov    $0x400640,%rcx &#x2F;&#x2F;0000000000400640 &lt;__libc_csu_init&gt;:4004bd:48 c7 c7 bb 05 40 00 mov    $0x4005bb,%rdi &#x2F;&#x2F;00000000004005bb &lt;main&gt;:4004c4:e8 b7 ff ff ff       callq  400480 &lt;__libc_start_main@plt&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>__libc_start_main@plt</code>包含了三个参数，<code>__libc_csu_fini</code>,<code>__libc_csu_init</code>,<code>main</code>显然，从名称上就可以看出这四个函数的作用。</p><p>__libc_start_main是libc.so.6中的一个函数。它的原型是这样的：</p><pre class="line-numbers language-none"><code class="language-none">extern int BP_SYM (__libc_start_main) (int (*main) (int, char **, char **),int argc,char *__unbounded *__unbounded ubp_av,void (*init) (void),void (*fini) (void),void (*rtld_fini) (void),void *__unbounded stack_end)__attribute__ ((noreturn));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个函数需要做的是建立&#x2F;初始化一些数据结构&#x2F;环境然后调用我们的main()。</p><p>程序启动的过程应该：<code>_start -&gt; __libc_start_main -&gt; __libc_csu_init -&gt; _init -&gt; main -&gt; _fini</code>.</p><p>这篇文章有详细的说明：<a href="https://blog.csdn.net/gary_ygl/article/details/8506007">linux编程之main()函数启动过程</a></p><h3 id="栈缓冲区及结构"><a href="#栈缓冲区及结构" class="headerlink" title="栈缓冲区及结构"></a>栈缓冲区及结构</h3><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><h3 id="汇编基础"><a href="#汇编基础" class="headerlink" title="汇编基础"></a>汇编基础</h3><p>x86_64有16个64位寄存器，分别是：</p><p>%rax，%rbx，%rcx，%rdx，%esi，%edi，%rbp，%rsp，%r8，%r9，%r10，%r11，%r12，%r13，%r14，%r15。</p><p>其中：</p><p>%rax 作为函数返回值使用。<br>%rsp 栈指针寄存器，指向栈顶<br>%rdi，%rsi，%rdx，%rcx，%r8，%r9 用作函数参数，依次对应第1参数，第2参数<br>%rbx，%rbp，%r12，%r13，%14，%15 用作数据存储，遵循被调用者使用规则，简单说就是随便用，调用子函数之前要备份它，以防他被修改<br>%r10，%r11 用作数据存储，遵循调用者使用规则，简单说就是使用之前要先保存原值</p><p>64位与32位的不同在于64位不用压栈来存储下一个函数参数，而是放在了%rdi，%rsi，%rdx，%rcx，%r8，%r9六个寄存器中，超出部分再压栈。</p><p><img src="https://pic1.zhimg.com/v2-8c6f52a7fabfb4f31464e51c3aa0e8a4_r.jpg" alt="preview"></p><p><img src="https://pic2.zhimg.com/v2-03edf3d060b91b58698db2a58bfb3be5_r.jpg" alt="preview"></p><p><img src="https://pic4.zhimg.com/80/v2-0cbd2ee34a6a173804028b19fe0a9167_720w.jpg" alt="img"></p></blockquote><p>首先，我们将<code>main.c</code>文件进行汇编，使用命令<code>gcc -S main.c</code>，在当前目录下回生成<code>main.s</code>的汇编文件，内容如下：</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">.file&quot;main.c&quot;.section.rodata.LC0:.string&quot;hello world! %s\n&quot;.text.globldisplay.typedisplay, @functiondisplay:.LFB0:.cfi_startprocpushq%rbp.cfi_def_cfa_offset 16.cfi_offset 6, -16movq%rsp, %rbp.cfi_def_cfa_register 6subq$16, %rspmovq%rdi, -8(%rbp)movq-8(%rbp), %raxmovq%rax, %rsimovl$.LC0, %edimovl$0, %eaxcallprintfnopleave.cfi_def_cfa 7, 8ret.cfi_endproc.LFE0:.sizedisplay, .-display.globlmain.typemain, @functionmain:.LFB1:.cfi_startprocpushq%rbp.cfi_def_cfa_offset 16.cfi_offset 6, -16movq%rsp, %rbp.cfi_def_cfa_register 6subq$272, %rspmovq%fs:40, %raxmovq%rax, -8(%rbp)xorl%eax, %eaxmovabsq$8391086132249306953, %rax &#x2F;&#x2F;0x74732061206d2749 (&quot;I&#39;m a st&quot;)movq%rax, -272(%rbp)movq$1735289202, -264(%rbp)leaq-256(%rbp), %rdxmovl$0, %eaxmovl$30, %ecxmovq%rdx, %rdirep stosqleaq-272(%rbp), %raxmovq%rax, %rdi &#x2F;&#x2F;使用%rdi寄存器压入参数calldisplay &#x2F;&#x2F;调用函数movl$0, %eaxmovq-8(%rbp), %rsixorq%fs:40, %rsije.L4call__stack_chk_fail.L4:leave.cfi_def_cfa 7, 8ret.cfi_endproc.LFE1:.sizemain, .-main.ident&quot;GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.12) 5.4.0 20160609&quot;.section.note.GNU-stack,&quot;&quot;,@progbits<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h4><p>在53，54行，使用<code>rdi</code>压入了一个参数，参数的地址在<code>-272(%rbp)（即rdi）</code>, 可以看出正好是字符串”I’m a string”的地址。如下所示：![image-20210719112214862](从一个hello world说起&#x2F;image-20210719112214862.png)</p><p>其中，函数调用栈缓冲区<code>backtrace</code>显示当前栈缓冲区为main，再上一层为__libc_start_main，再次印证了上一节的说法。</p><h4 id="display函数"><a href="#display函数" class="headerlink" title="display函数"></a>display函数</h4><p>下面我们进入display函数，可以看出printf的两个参数分别放在<code>rdi,rsi</code>两个寄存器当中。</p><p>![image-20210719112513484](从一个hello world说起&#x2F;image-20210719112513484.png)其中，函数调用栈缓冲区<code>backtrace</code>显示当前栈缓冲区为display，再上一层为main，__libc_start_main，再次印证了上一节的说法。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>通过对main函数中display函数的参数，display函数中的printf函数的参数进行实验，说明了C语言在函数调用时的栈缓冲区的组织。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>对于一个普普通通的C语言程序，其实其背后是一堆复杂的操作系统预备好的操作，执行完毕之后，就开始执行我们的main函数。main函数并不是程序执行的第一个函数，当然也不是最后一个。我们编写的程序的main函数，仅仅是操作系统在加载elf文件时候调用的函数而已，仅仅是函数而已。</p><p>栈缓冲区的组织，一定要动手自己调一调，理解栈缓冲区，有助于理解pwn题中的栈缓冲的利用。</p><p>这就是我喜欢C语言的原因，因为他能让我更加清晰的看到程序运行的背后，而像python这类语言，我也使用，因为真的方便，但是对于理解计算机、理解背后的故事非常的不利。</p><p>关注我，学习更多系统的知识！</p>]]></content>
    
    
    <summary type="html">从一个hello world说起
大家好，我是明说网络的小明同学。今天我们从C语言的Hello World说起，和大家一起温习一下C语言中一个Hello World怎么运行起来的，以及C语言如何组织栈缓冲区等。本文不适用于C语言初学者，需要具备有一定的汇编基础。好了下面，我们开始吧。

工具
本文的工具为：

操作系统：Ubuntu16.04， 4.15.0-142-generic

编译器：gcc version 5.4.0 20160609 (Ubuntu 5.4.0-6ubuntu1~16.04.12)

make工具GNU Make 4.1

反汇编查看器：objdump

elf文件</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>IT、制造业和医疗卫生部门成为网络攻击的重点目标</title>
    <link href="http://dianwoshishi.github.io/post/IT%E3%80%81%E5%88%B6%E9%80%A0%E4%B8%9A%E5%92%8C%E5%8C%BB%E7%96%97%E5%8D%AB%E7%94%9F%E9%83%A8%E9%97%A8%E6%88%90%E4%B8%BA%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E7%9A%84%E9%87%8D%E7%82%B9%E7%9B%AE%E6%A0%87.html"/>
    <id>http://dianwoshishi.github.io/post/IT%E3%80%81%E5%88%B6%E9%80%A0%E4%B8%9A%E5%92%8C%E5%8C%BB%E7%96%97%E5%8D%AB%E7%94%9F%E9%83%A8%E9%97%A8%E6%88%90%E4%B8%BA%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E7%9A%84%E9%87%8D%E7%82%B9%E7%9B%AE%E6%A0%87.html</id>
    <published>2022-02-26T06:11:30.000Z</published>
    <updated>2022-02-26T06:12:56.758Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IT、制造业和医疗卫生部门成为网络攻击的重点目标"><a href="#IT、制造业和医疗卫生部门成为网络攻击的重点目标" class="headerlink" title="IT、制造业和医疗卫生部门成为网络攻击的重点目标"></a>IT、制造业和医疗卫生部门成为网络攻击的重点目标</h1><p><img src="https://cyware-ent.s3.amazonaws.com/image_bank/shutterstock_178125287.jpg" alt="IT, Manufacturing, and Healthcare Sectors Need to Stay Away from Cyberattacks"></p><p>医疗保健和制造业受到主动的网络攻击，这已经不是什么秘密。威胁形势已经发生了巨大的变化，而且事情正在变得越来越糟糕。除了这两个行业，IT行业也已成为网络攻击的最主要目标之一。</p><h2 id="一些统计数字"><a href="#一些统计数字" class="headerlink" title="一些统计数字"></a>一些统计数字</h2><p>Avanan公司最近的一份报告对今年上半年的网络攻击趋势作了说明。</p><ul><li>IT行业的公司见证了9000多封钓鱼邮件，其次是医疗保健和制造业，每10,000名用户每30天大约有6000封钓鱼邮件。</li><li>在所有网络钓鱼攻击中，凭证收集占54%，BEC攻击占20.7%，敲诈占2.2%。</li><li>黑客已经开始瞄准非行政人员，而不是C级行政人员，占据了77%的份额。</li></ul><h2 id="为什么这很重要？"><a href="#为什么这很重要？" class="headerlink" title="为什么这很重要？"></a>为什么这很重要？</h2><p>当医疗机构受到勒索软件攻击者的攻击，制造业公司不断遭受供应链中断的影响时，黑客已经诉诸于最基本的战术–钓鱼邮件来进行未经授权的访问。这些行业非常容易受到网络攻击，因为它们管理着有价值的信息，而这些信息在暗网市场上需求很大。此外，设施设备仍然使用过时的技术，再加上缺乏适当的员工培训和基本的网络安全防护知识，使这些部门被攻击者盯上。</p><h2 id="底线"><a href="#底线" class="headerlink" title="底线"></a>底线</h2><p>现在，我们已经意识到网络犯罪分子为实现其邪恶的意图会不惜一切代价。诸如网络钓鱼和社会工程等经久不衰的方法，以及诸如供应链攻击等独特而复杂的方法，都被用来获得对未受保护或保护不力的系统的访问。如果没有适当的防御措施，这些部门将继续成为网络攻击的目标。</p>]]></content>
    
    
    <summary type="html">IT、制造业和医疗卫生部门成为网络攻击的重点目标


医疗保健和制造业受到主动的网络攻击，这已经不是什么秘密。威胁形势已经发生了巨大的变化，而且事情正在变得越来越糟糕。除了这两个行业，IT行业也已成为网络攻击的最主要目标之一。

一些统计数字
Avanan公司最近的一份报告对今年上半年的网络攻击趋势作了说明。

 * IT行业的公司见证了9000多封钓鱼邮件，其次是医疗保健和制造业，每10,000名用户每30天大约有6000封钓鱼邮件。
 * 在所有网络钓鱼攻击中，凭证收集占54%，BEC攻击占20.7%，敲诈占2.2%。
 * 黑客已经开始瞄准非行政人员，而不是C级行政人员，占据了77%的份</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>favicon 图标被黑客用来加载后门程序</title>
    <link href="http://dianwoshishi.github.io/post/favicon%20%E5%9B%BE%E6%A0%87%E8%A2%AB%E9%BB%91%E5%AE%A2%E7%94%A8%E6%9D%A5%E5%8A%A0%E8%BD%BD%E5%90%8E%E9%97%A8%E7%A8%8B%E5%BA%8F.html"/>
    <id>http://dianwoshishi.github.io/post/favicon%20%E5%9B%BE%E6%A0%87%E8%A2%AB%E9%BB%91%E5%AE%A2%E7%94%A8%E6%9D%A5%E5%8A%A0%E8%BD%BD%E5%90%8E%E9%97%A8%E7%A8%8B%E5%BA%8F.html</id>
    <published>2022-02-26T06:11:22.000Z</published>
    <updated>2022-02-26T06:11:22.649Z</updated>
    
    <content type="html"><![CDATA[<h1 id="favicon-图标被黑客用来加载后门程序"><a href="#favicon-图标被黑客用来加载后门程序" class="headerlink" title="favicon 图标被黑客用来加载后门程序"></a>favicon 图标被黑客用来加载后门程序</h1><p><img src="https://www.cybersafe.news/wp-content/uploads/2021/05/magecart-640x400.jpg" alt="img"></p><p>网络犯罪分子正在分发伪装成favicon的恶意PHP web shells，以实现对被攻击服务器的远程访问，并将JavaScript skimmers注入在线购物平台，目的是窃取用户的财务信息。</p><p>Malwarebytes Jérôme Segura表示，这些被称为Smilodon或Megalodon的Web shells被用来通过服务器端请求动态加载JavaScript skimming代码到在线商店。这种技术很有趣，因为大多数客户端的安全工具将无法检测或阻挡盗取者。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Magecart，针对在线购物网站的黑客组织使用在电子商务网站上注入网络盗取器(web skimmers)的技术来窃取信用卡的详细信息。盗取器(skimmers )也被称为形式劫持攻击，盗取器采取JavaScript代码的形式，操作者秘密插入电子商务网站，通常是在支付页面，目的是实时捕捉客户的银行卡信息，并将其传输到远程服务器。</p><p>注入式盗刷器的工作原理是，当客户访问网店时，向托管在攻击者控制的域名上的外部JavaScript资源发出客户端请求。然而，最新的攻击有点不同，因为盗取代码是在服务器端动态引入商家网站的。</p><p>基于PHP的网络外壳恶意软件伪装成favicon（”Magento.png”），通过篡改HTML代码中的快捷图标标签指向假的PNG图像文件，将恶意软件插入到被攻击的网站。这个网络shell又被配置为从外部主机-获取下一阶段的有效载荷:一个信用卡盗刷器。</p><h2 id="恶意活动关联"><a href="#恶意活动关联" class="headerlink" title="恶意活动关联"></a>恶意活动关联</h2><p>基于TTPs( tactics, techniques, and procedures)的重叠，最新的活动被归结为Magecart Group 12。Malwarebytes补充说，他们发现的最新域名（zolo[.]pw）恰好与recaptcha-in[.]pw和google-statik[.]pw托管在同一个IP地址（217.12.204[.]185），这两个域名之前与Magecart Group 12有关。</p><p>在过去的几个月里，Magecart的行为者使用了几种攻击技术来避免被发现和渗出数据。</p>]]></content>
    
    
    <summary type="html">favicon 图标被黑客用来加载后门程序


网络犯罪分子正在分发伪装成favicon的恶意PHP web shells，以实现对被攻击服务器的远程访问，并将JavaScript skimmers注入在线购物平台，目的是窃取用户的财务信息。

Malwarebytes Jérôme Segura表示，这些被称为Smilodon或Megalodon的Web shells被用来通过服务器端请求动态加载JavaScript skimming代码到在线商店。这种技术很有趣，因为大多数客户端的安全工具将无法检测或阻挡盗取者。

原理
Magecart，针对在线购物网站的黑客组织使用在电子商务网站上注入</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>网络电子身份标识(eID) -你的网络空间身份证</title>
    <link href="http://dianwoshishi.github.io/post/eID%20%E6%95%B0%E5%AD%97%E8%BA%AB%E4%BB%BD%E4%BD%93%E7%B3%BB.html"/>
    <id>http://dianwoshishi.github.io/post/eID%20%E6%95%B0%E5%AD%97%E8%BA%AB%E4%BB%BD%E4%BD%93%E7%B3%BB.html</id>
    <published>2022-02-26T06:11:14.000Z</published>
    <updated>2022-02-26T06:11:15.517Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络电子身份标识-eID-你的网络空间身份证"><a href="#网络电子身份标识-eID-你的网络空间身份证" class="headerlink" title="网络电子身份标识(eID) -你的网络空间身份证"></a>网络电子身份标识(eID) -你的网络空间身份证</h1><p>在现实世界中，你的唯一身份由身份证标识。那么网络空间中呢？一起来看看吧</p><h2 id="什么是身份标识"><a href="#什么是身份标识" class="headerlink" title="什么是身份标识"></a>什么是身份标识</h2><p>在物理世界中，《居民身份证法》的规定 ，“公民身份号码是每个公民唯一的、终身不变的身份代 码，由公安机关按照公民身份号码国家标准编制。”</p><h2 id="什么是网络电子身份标识eID"><a href="#什么是网络电子身份标识eID" class="headerlink" title="什么是网络电子身份标识eID"></a>什么是网络电子身份标识eID</h2><p>数字身份是实体社会中的自然人身份在数字空间的映射。在网络空间，数字身份同样具有唯一性特征，其作用是要在一定范围内识别某 一主体，使之与其他主体区分开来。</p><p>国际上，eID通常是由政府颁发给公民用于线上和线下识别身份的证件。欧盟多个国家已经颁发了eID来替代传统的身份证件，使eID既具备了线下身份识别的功能，又具备了网络远程身份识别功能。目前已经发行eID的国家有德国、法国、西班牙、意大利、俄罗斯、比利时、爱沙尼亚、奥地利、丹麦、芬兰、葡萄牙、斯洛文尼亚、立陶宛、马耳他、卢森堡、荷兰、瑞典、冰岛、阿联酋以及我国香港特别行政区等。其中，德国、西班牙、意大利、比利时、爱沙尼亚和奥地利已经普及，广泛用于电子政务、电子商务、社交网络等各个领域。</p><p><img src="https://eid.cn/images/whatiseid/6.png"></p><h2 id="为什么需要数字身份证"><a href="#为什么需要数字身份证" class="headerlink" title="为什么需要数字身份证"></a>为什么需要数字身份证</h2><p>我国网络发展至今，一直延用了物理空间的公民身份号码作为线上公民数字身 份的区分职能。但是存在诸多问题</p><ul><li>容易造成个人信息泄露。</li></ul><p>，由于公民身份号码隐含了个人户籍所在地、出生日期、性别 等个人信息，在开放的互联网上直接使用公民身份号码，无疑会对个人信息安全带 来极大的隐患和危害。多年来的实践反复证明，仅仅使用姓名＋公民身份号码代表公民的线 上身份，造成了大量的个人信息泄露。</p><ul><li>个人信息比对正确并不能代表本人真实意愿，无法防范个人身份被冒用或盗用的风险</li></ul><p>与线下环 境身份认证方式（身份证要求本人出示，由核验方查实证件真伪及判断是否“人证 合一”）不同的是，在线上填写公民身份号码既无法验证身份的真伪、也难以证明 是出自本人意愿。</p><p>作为个人信息的重要代表，公民身份号 码不宜直接作为数字身份来使用：它只起到了唯一区分的作用，而无法对个人信息 进行保护。因此，结合我国现有身份管理的成就以及网络社会个人信息保护的现实 需求，有必要以公民身份号码为根（唯一性），建设既能保护个人信息安全又能适 应网络社会数据开放和流通需求的统一数字身份体系。</p><p><strong>公安部第三研究所于十二五期间承担了国家863计划“网域空间身份管理”等信息安全重大专项，研发了“网络电子身份标识（elD）”技术并形成了相关标准体系。</strong></p><h2 id="eID-数字身份基本概念"><a href="#eID-数字身份基本概念" class="headerlink" title="eID 数字身份基本概念"></a>eID 数字身份基本概念</h2><h3 id="eID-数字身份"><a href="#eID-数字身份" class="headerlink" title="eID 数字身份"></a>eID 数字身份</h3><p>eID 数字身份是以公民身份号码为根，由“公民网络身份识别系统”基于密码算法(国密sm2，公钥密码体制)统一为中国公民生成的数字标记。 eID 数字身份既可以保证签发给每个公民的数字标记的唯一识别性，又可以减 少公民身份明文信息在互联网上的传播，又可以实现不同应用中公民 eID 数字身份 有条件的互通。</p><h2 id="eID-数字身份特性"><a href="#eID-数字身份特性" class="headerlink" title="eID 数字身份特性"></a>eID 数字身份特性</h2><p>eID依据《居民身份证法》《电子签名法》和《网络安全法》等相关法律要求，既可以解决数字空间由于数据的虚拟性、易复制性、易重构性等特性所带来的主体识别、数据确权授权、行为抗抵赖和隐私保护等难题，也可以在物理空间解决传统离线证件难以有效挂失的缺陷，具备便捷、安全、唯一、规范和跨域的特点。</p><ul><li><p>便捷性：分钟级空中开通、秒级认证，兼具线上身份认证和线下身份证明功能；</p></li><li><p>安全性：基于国密算法、智能安全芯片，借助现场活体人脸检测和身份证内置照片识别保证人证同一；</p></li><li><p>唯一性：一人同时只能有一个eID，可有效挂失或注销；</p></li><li><p>规范性：相关格式、载体、机具和验证等国家标准已于2019年5月起正式实施；</p></li><li><p>跨域性：可实现跨应用、跨行业、跨地区的无差别使用。</p></li></ul><h2 id="eID-数字身份特点"><a href="#eID-数字身份特点" class="headerlink" title="eID 数字身份特点"></a>eID 数字身份特点</h2><p>eID 数字身份有以下特点： </p><ul><li><p>eID 数字身份以公民身份号码为根生成；</p></li><li><p>eID 数字身份基于密码算法产生，从 eID 数字身份无法逆推出公民身份号码原文； </p></li><li><p>eID 数字身份采用碎片化方法生成：对于不同的 CSP，同一注册用户的 eID 数字身份并不相同；对于同一 CSP 的不同 RP，同一注册用户的 eID 数字 身份也不相同；</p></li><li><p>eID 数字身份由“公民网络身份识别系统”统一管理，碎片化处理后的 eID 数字身份在“公民网络身份识别系统”内可实现与公民身份号码的关联。</p></li><li></li></ul><h2 id="eID功能"><a href="#eID功能" class="headerlink" title="eID功能"></a>eID功能</h2><p>eID具有</p><ul><li>在线身份认证</li><li>签名验签</li><li>线下身份认证</li></ul><p>等功能，能够在保护公民个人信息安全的前提下准确识别自然人主体身份，可以运用在网上签约授权、交易支付、航旅服务、酒店住宿等多种场景。</p><h2 id="数字身份的认证"><a href="#数字身份的认证" class="headerlink" title="数字身份的认证"></a>数字身份的认证</h2><p>如何认证数字身份，既是一个技术问题也是一个法律问题。技术上，目前通用 的数字身份认证技术有许多，例如，基于口令的认证方式，OTP（One Time Password） 和银行 U 盾的认证技术等。世界各国基于各自的电子签名相关法律推广可靠的数字身份认证，大多采用基于 PKI 的数字签名技术。</p><h3 id="eID的技术原理"><a href="#eID的技术原理" class="headerlink" title="eID的技术原理"></a>eID的技术原理</h3><p>eID以智能安全芯片为载体，芯片内部拥有独立的处理器、安全存储单元和密码运算协处理器，只能运行专用安全芯片操作系统，其内建芯片安全机制可以抵抗各种物理和逻辑攻击，确保芯片内部数据无法被非法读取、篡改或使用。</p><p>用户开通eID时，智能安全芯片内部会采用非对称密钥算法(国密SM2)生成一组公私钥对，这组公私钥对可用于电子签名，基本原理是：用户可以使用自己的eID私钥对信息进行电子签名后发送给其他人，其他人可以使用用户的eID公钥对签名信息进行验签。</p><p>用户使用eID私钥签名的功能受eID签名密码保护，在开通eID时需要用户本人设置eID签名密码，连续输错多次eID签名密码eID功能将被锁定，确保了使用eID完成的电子签名不可抵赖。</p><p>用户使用eID通过网络向应用方自证身份时，应用方会向连接“公民网络身份识别系统”的服务机构发出请求，以核实用户网络身份的真实性和有效性。一旦用户网络身份通过验证，应用方得到用户在当前应用上的网络身份应用标识。由于用户在不同的线上应用上所使用的网络身份应用标识编码不同，可以避免用户在不同线上应用中的行为数据被汇聚、分析和追踪。</p><h3 id="eID数字身份模型"><a href="#eID数字身份模型" class="headerlink" title="eID数字身份模型"></a>eID数字身份模型</h3><p>![eID数字身份模型](eID 数字身份体系&#x2F;image-20210622194227808.png)</p><h2 id="申领与开通"><a href="#申领与开通" class="headerlink" title="申领与开通"></a>申领与开通</h2><p>公安部第三研究所与智能手机厂家开展合作，将eID载入手机安全芯片。目前已支持直接申领eID的智能手机品牌及型号如下：</p><p>![image-20210622193305876](eID 数字身份体系&#x2F;image-20210622193305876.png)</p><h2 id="eID数字身份体系特点"><a href="#eID数字身份体系特点" class="headerlink" title="eID数字身份体系特点"></a>eID数字身份体系特点</h2><ul><li><p>● 以个人信息保护为首要原则，将公民身份信息转化成去身份化和碎片化的个人标记，防止公民个人信息泄露和大数据精准画像，保障公民的生活安宁、财产和人身安全；</p></li><li><p>● 在全面研究分析我国主流身份认证技术及应用的基础上，通过引入eID数字身份构建全国统一数字身份体系，包容各种数字身份认证技术并实现认证互通；</p></li><li><p>● 分别对eID数字身份颁发过程和eID数字身份认证过程的安全可靠程度分级，构建eID数字身份体系框架；</p></li><li><p>● 旨在推动我国数据的开放和流通，促进我国数字政府、数字经济发展，建设网络强国。</p></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://eid.cn/knoweid/whatiseid.html">https://eid.cn/knoweid/whatiseid.html</a></p><p><a href="https://eid.cn/eid2018.pdf">https://eid.cn/eid2018.pdf</a></p>]]></content>
    
    
    <summary type="html">网络电子身份标识(eID) -你的网络空间身份证
在现实世界中，你的唯一身份由身份证标识。那么网络空间中呢？一起来看看吧

什么是身份标识
在物理世界中，《居民身份证法》的规定 ，“公民身份号码是每个公民唯一的、终身不变的身份代 码，由公安机关按照公民身份号码国家标准编制。”

什么是网络电子身份标识eID
数字身份是实体社会中的自然人身份在数字空间的映射。在网络空间，数字身份同样具有唯一性特征，其作用是要在一定范围内识别某 一主体，使之与其他主体区分开来。

国际上，eID通常是由政府颁发给公民用于线上和线下识别身份的证件。欧盟多个国家已经颁发了eID来替代传统的身份证件，使eID既具备了线</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>中国研究人员发现微软0Day漏洞</title>
    <link href="http://dianwoshishi.github.io/post/%E4%B8%AD%E5%9B%BD%E7%A0%94%E7%A9%B6%E4%BA%BA%E5%91%98%E5%8F%91%E7%8E%B0%E5%BE%AE%E8%BD%AF0Day%E6%BC%8F%E6%B4%9E.html"/>
    <id>http://dianwoshishi.github.io/post/%E4%B8%AD%E5%9B%BD%E7%A0%94%E7%A9%B6%E4%BA%BA%E5%91%98%E5%8F%91%E7%8E%B0%E5%BE%AE%E8%BD%AF0Day%E6%BC%8F%E6%B4%9E.html</id>
    <published>2022-02-26T06:10:58.000Z</published>
    <updated>2022-02-26T06:10:59.201Z</updated>
    
    <content type="html"><![CDATA[<h1 id="中国研究人员发现微软0Day漏洞"><a href="#中国研究人员发现微软0Day漏洞" class="headerlink" title="中国研究人员发现微软0Day漏洞"></a>中国研究人员发现微软0Day漏洞</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>中国的安全研究人员披露了一个关键的Windows零日漏洞，使得域控制器服务器尤其面临风险。专家建议尽可能严格限制对这些服务器的网络访问，或是直接关闭这些服务。</p><p><img src="https://www.cybersafe.news/wp-content/uploads/2021/07/zeroday-800x400.png" alt="img"></p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>中国的安全研究人员披露了一个关键的Windows零日漏洞，该漏洞被命名为PrintNightmare。</p><p>总部设在深圳的桑福(Sangfor )科技公司披露技术细节和概念验证（PoC）漏洞，该漏洞目前在Windows中没有补丁，允许远程代码执行。</p><p>此前，微软在6月修补了一个高严重度的特权提升漏洞CVE-2021-1675。但在上周一，在分析了它可以实现远程代码执行（RCE）后，它把这个漏洞重新归类为关键性的。</p><p>Print Spooler的零日漏洞，使得域控制器服务器尤其面临风险。威胁者可以利用这些的远程控制访问企业网络。即使强加认证，但鉴于暗网中RDP和其他系统的证书被攻破的数量，这对攻击者来说是很容易突破。</p><h2 id="措施"><a href="#措施" class="headerlink" title="措施"></a>措施</h2><p>Sophos首席研究科学家Paul Ducklin说，微软可能会在7月的补丁星期二之前发布一个带外更新来解决这个问题。</p><p>那些有让Print Spooler运行的服务器用户，建议尽可能严格限制对这些服务器的网络访问。另外，如果有的服务器没有必要运行Print Spooler，即使有了补丁，也应该关闭它。</p>]]></content>
    
    
    <summary type="html">中国研究人员发现微软0Day漏洞
摘要
中国的安全研究人员披露了一个关键的Windows零日漏洞，使得域控制器服务器尤其面临风险。专家建议尽可能严格限制对这些服务器的网络访问，或是直接关闭这些服务。



正文
中国的安全研究人员披露了一个关键的Windows零日漏洞，该漏洞被命名为PrintNightmare。

总部设在深圳的桑福(Sangfor )科技公司披露技术细节和概念验证（PoC）漏洞，该漏洞目前在Windows中没有补丁，允许远程代码执行。

此前，微软在6月修补了一个高严重度的特权提升漏洞CVE-2021-1675。但在上周一，在分析了它可以实现远程代码执行（RCE）后，它把这</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>这款木马的传播者已被逮捕</title>
    <link href="http://dianwoshishi.github.io/post/%E8%BF%99%E6%AC%BE%E6%9C%A8%E9%A9%AC%E7%9A%84%E4%BC%A0%E6%92%AD%E8%80%85%E5%B7%B2%E8%A2%AB%E9%80%AE%E6%8D%95.html"/>
    <id>http://dianwoshishi.github.io/post/%E8%BF%99%E6%AC%BE%E6%9C%A8%E9%A9%AC%E7%9A%84%E4%BC%A0%E6%92%AD%E8%80%85%E5%B7%B2%E8%A2%AB%E9%80%AE%E6%8D%95.html</id>
    <published>2022-02-26T06:10:40.000Z</published>
    <updated>2022-02-26T06:10:41.051Z</updated>
    
    <content type="html"><![CDATA[<h1 id="这款木马的传播者已被逮捕"><a href="#这款木马的传播者已被逮捕" class="headerlink" title="这款木马的传播者已被逮捕"></a>这款木马的传播者已被逮捕</h1><p><img src="https://www.cybersafe.news/wp-content/uploads/2021/07/trojan-780x400.jpg" alt="img"></p><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>哥伦比亚的执法部门已经逮捕了一名涉嫌传播Gozi木马的网络犯罪分子。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>这位罗马尼亚国民Mihai Ionut Paunescu，也被称为 “病毒”，是2007年至2012年期间，影响超过一百万台个人电脑的三名主要嫌疑人之一。</p><p>他在波哥大埃尔多拉多国际机场被捕，并因被指控经营防弹托管服务(bulletproof hosting service)而面临被引渡到美国。Paunescu在纽约南区法院面临计算机入侵和金融欺诈的指控。此前，Paunescu于2012年在其本国被捕，但他之前能够避免引渡。</p><h2 id="防弹托管"><a href="#防弹托管" class="headerlink" title="防弹托管"></a>防弹托管</h2><p>防弹托管(bulletproof hosting service)通常被网络犯罪分子用于后台基础设施，用于传播垃圾邮件、恶意软件、漏洞工具包，以及托管被盗数据。这些在线服务对其客户的违法活动视而不见。威胁者以每周500美元的价格出租恶意软件及其基础设施，这被认为是当今恶意软件即服务（MaaS）犯罪设置的早期形式。</p><h2 id="Gozi木马"><a href="#Gozi木马" class="headerlink" title="Gozi木马"></a>Gozi木马</h2><p>2007年首次发现的Gozi银行木马是通过附在电子邮件中的武器化PDF文件传播的。下载后，该恶意软件会潜伏在后台，收集银行账户信息和账户细节，然后发送到木马的命令和控制（C2）服务器，供操作者用于访问账户和进行欺诈性交易。</p><p>Gozi的源代码在2010年被泄露，许多变种被创造出来，目前仍在使用中。</p><p>2016年，Gozi的俄罗斯创造者Nikita “76” Kuzmin在承认各种计算机入侵和欺诈指控后在美国法院被判刑。</p><p>据估计，该恶意软件给受害者造成的损失高达数千万美元。</p>]]></content>
    
    
    <summary type="html">这款木马的传播者已被逮捕


摘要
哥伦比亚的执法部门已经逮捕了一名涉嫌传播Gozi木马的网络犯罪分子。

正文
这位罗马尼亚国民Mihai Ionut Paunescu，也被称为 “病毒”，是2007年至2012年期间，影响超过一百万台个人电脑的三名主要嫌疑人之一。

他在波哥大埃尔多拉多国际机场被捕，并因被指控经营防弹托管服务(bulletproof hosting service)而面临被引渡到美国。Paunescu在纽约南区法院面临计算机入侵和金融欺诈的指控。此前，Paunescu于2012年在其本国被捕，但他之前能够避免引渡。

防弹托管
防弹托管(bulletproof hosti</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>又一勒索软件组织回来了！逮捕只针对洗钱部分，核心成员没被逮捕</title>
    <link href="http://dianwoshishi.github.io/post/%E5%8F%88%E4%B8%80%E5%8B%92%E7%B4%A2%E8%BD%AF%E4%BB%B6%E7%BB%84%E7%BB%87%E5%9B%9E%E6%9D%A5%E4%BA%86%EF%BC%81%E9%80%AE%E6%8D%95%E5%8F%AA%E9%92%88%E5%AF%B9%E6%B4%97%E9%92%B1%E9%83%A8%E5%88%86%EF%BC%8C%E6%A0%B8%E5%BF%83%E6%88%90%E5%91%98%E6%B2%A1%E8%A2%AB%E9%80%AE%E6%8D%95.html"/>
    <id>http://dianwoshishi.github.io/post/%E5%8F%88%E4%B8%80%E5%8B%92%E7%B4%A2%E8%BD%AF%E4%BB%B6%E7%BB%84%E7%BB%87%E5%9B%9E%E6%9D%A5%E4%BA%86%EF%BC%81%E9%80%AE%E6%8D%95%E5%8F%AA%E9%92%88%E5%AF%B9%E6%B4%97%E9%92%B1%E9%83%A8%E5%88%86%EF%BC%8C%E6%A0%B8%E5%BF%83%E6%88%90%E5%91%98%E6%B2%A1%E8%A2%AB%E9%80%AE%E6%8D%95.html</id>
    <published>2022-02-26T06:10:33.000Z</published>
    <updated>2022-02-26T06:10:34.085Z</updated>
    
    <content type="html"><![CDATA[<h1 id="又一勒索软件组织回来了！逮捕只针对洗钱部分，核心成员没被逮捕"><a href="#又一勒索软件组织回来了！逮捕只针对洗钱部分，核心成员没被逮捕" class="headerlink" title="又一勒索软件组织回来了！逮捕只针对洗钱部分，核心成员没被逮捕"></a>又一勒索软件组织回来了！逮捕只针对洗钱部分，核心成员没被逮捕</h1><p><img src="https://cyware-ent.s3.amazonaws.com/image_bank/df67_shutterstock_129133820.jpg" alt="Recent Arrests Probably Weren’t Able to Stop Cl0p Ransomware"></p><p>Cl0p是最著名的勒索软件集团之一，在联邦机构最近的一次打击行动中被发现再次活跃。虽然它的行动保持了大约一周的安静，但它最近在其数据泄露网站上列出了新的受害者。</p><h2 id="发生了什么？"><a href="#发生了什么？" class="headerlink" title="发生了什么？"></a>发生了什么？</h2><p>Cl0p团伙回来了，因为它在其勒索软件数据泄露网站上泄露了两名新受害者的数据。<br>运营商公布了一批新的机密数据，声称是从新的受害者那里偷来的。<br>这些数据属于两个受害者，一个是农场设备零售商，而另一个是建筑师的办公室。</p><h2 id="快速回归"><a href="#快速回归" class="headerlink" title="快速回归"></a>快速回归</h2><p>Cl0p勒索软件组自2019年3月以来一直很活跃，当时它用CryptoMix勒索软件针对一家企业。据乌克兰警方称，Clop的总损失估计为5亿美元。上周，一次<a href="https://www.bleepingcomputer.com/news/security/ukraine-arrests-clop-ransomware-gang-members-seizes-servers/">执法行动</a>导致Cl0p勒索软件团伙成员被捕。<br>执法部门已经关闭了恶意软件的基础设施，并阻断了对非法获得的加密货币进行洗钱的渠道。<br>然而，最新的活动表明，联邦机构的逮捕只针对行动中的洗钱部分，核心成员没有被逮捕。<br>预计逮捕对Cl0p行动的整体影响不大，因为在一周内，新的活动又开始萌芽。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>最近在乌克兰的逮捕行动对Cl0p行动的打击并不大，因为核心组成员没有受到影响。可以说，阻止勒索软件的斗争远未结束，预计将进一步继续。因此，企业应该积极主动地采取足够的安全措施，以保持保护。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://cyware.com/news/recent-arrests-probably-werent-able-to-stop-cl0p-ransomware-0fdec2cd">https://cyware.com/news/recent-arrests-probably-werent-able-to-stop-cl0p-ransomware-0fdec2cd</a></p>]]></content>
    
    
    <summary type="html">又一勒索软件组织回来了！逮捕只针对洗钱部分，核心成员没被逮捕


Cl0p是最著名的勒索软件集团之一，在联邦机构最近的一次打击行动中被发现再次活跃。虽然它的行动保持了大约一周的安静，但它最近在其数据泄露网站上列出了新的受害者。

发生了什么？
Cl0p团伙回来了，因为它在其勒索软件数据泄露网站上泄露了两名新受害者的数据。
运营商公布了一批新的机密数据，声称是从新的受害者那里偷来的。
这些数据属于两个受害者，一个是农场设备零售商，而另一个是建筑师的办公室。

快速回归
Cl0p勒索软件组自2019年3月以来一直很活跃，当时它用CryptoMix勒索软件针对一家企业。据乌克兰警方称，Clop的总损</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>由SolarWinds提供的Serv-U管理的文件传输服务中的一个RCE漏洞被人利用</title>
    <link href="http://dianwoshishi.github.io/post/%E7%94%B1SolarWinds%E6%8F%90%E4%BE%9B%E7%9A%84Serv-U%E7%AE%A1%E7%90%86%E7%9A%84%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E6%9C%8D%E5%8A%A1%E4%B8%AD%E7%9A%84%E4%B8%80%E4%B8%AARCE%E6%BC%8F%E6%B4%9E%E8%A2%AB%E4%BA%BA%E5%88%A9%E7%94%A8.html"/>
    <id>http://dianwoshishi.github.io/post/%E7%94%B1SolarWinds%E6%8F%90%E4%BE%9B%E7%9A%84Serv-U%E7%AE%A1%E7%90%86%E7%9A%84%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E6%9C%8D%E5%8A%A1%E4%B8%AD%E7%9A%84%E4%B8%80%E4%B8%AARCE%E6%BC%8F%E6%B4%9E%E8%A2%AB%E4%BA%BA%E5%88%A9%E7%94%A8.html</id>
    <published>2022-02-26T06:10:26.000Z</published>
    <updated>2022-02-26T06:10:26.552Z</updated>
    
    <content type="html"><![CDATA[<h1 id="由SolarWinds提供的Serv-U管理的文件传输服务中的一个RCE漏洞被人利用"><a href="#由SolarWinds提供的Serv-U管理的文件传输服务中的一个RCE漏洞被人利用" class="headerlink" title="由SolarWinds提供的Serv-U管理的文件传输服务中的一个RCE漏洞被人利用"></a>由SolarWinds提供的Serv-U管理的文件传输服务中的一个RCE漏洞被人利用</h1><p><img src="https://cyware-ent.s3.amazonaws.com/image_bank/08ab_shutterstock_1092298922.jpg" alt="SolarWinds Zero-Day Vulnerability Under Active Attack"></p><p>由SolarWinds提供的Serv-U管理的文件传输服务中的一个RCE漏洞被人利用。SolarWinds公司早些时候通过供应链攻击成为目标，该公司已发布补丁以修复该漏洞。</p><h2 id="发生了什么？"><a href="#发生了什么？" class="headerlink" title="发生了什么？"></a>发生了什么？</h2><p>微软已经提出了有限的和目标客户受到被追踪为CVE-2021-35211的零日漏洞影响的证据。然而，SolarWinds 並沒有准确估计有多少客戶可能受到该漏洞的影响。<br>该漏洞影响到Serv-U 15.2.3 HF1及之前的版本。成功利用该漏洞后，攻击者可在受感染的系统上运行任意代码。<br>此外，该漏洞使攻击者能够安装恶意程序并查看、更改或删除重要数据。然而，该漏洞在Serv-U 15.2.3版热修复（HF）2中得到解决。<br>该公司要求管理员注意任何通过SSH从IP地址98[.]176[.]196[.]89和68[.]235[.]178[.]32或208[.]113[.]35[.]58通过TCP 443的潜在可疑连接。<br>SolarWinds在其最近的公告中表示，发现的零日与SUNBURST供应链攻击没有任何关系。此外，它不影响任何其他产品，特别是Orion平台。</p><h2 id="最近的供应链攻击"><a href="#最近的供应链攻击" class="headerlink" title="最近的供应链攻击"></a>最近的供应链攻击</h2><p>有几起事件被曝光，其中有供应链攻击。<br>最近，卡西亚在一次供应链攻击中被REvil勒索软件盯上，目标是其虚拟系统管理员解决方案中的关键安全漏洞（CVE-2021-30116&#x2F;19&#x2F;20）。<br>6月，对航空业的一次巨大的供应链攻击与中国国家行为者APT41有关。<br>5月，加拿大邮政遭遇数据泄露事件，影响到其95万名客户。该安全漏洞是由于基于恶意软件的供应链攻击而发生的。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>最近的供应链攻击突出了现代网络和供应链的脆弱性。攻击者越来越多地发现广泛使用的软件链中的漏洞，以部署恶意软件。因此，建议企业遵循安全机构提供的建议，并定期审查其网络安全态势。</p>]]></content>
    
    
    <summary type="html">由SolarWinds提供的Serv-U管理的文件传输服务中的一个RCE漏洞被人利用


由SolarWinds提供的Serv-U管理的文件传输服务中的一个RCE漏洞被人利用。SolarWinds公司早些时候通过供应链攻击成为目标，该公司已发布补丁以修复该漏洞。

发生了什么？
微软已经提出了有限的和目标客户受到被追踪为CVE-2021-35211的零日漏洞影响的证据。然而，SolarWinds 並沒有准确估计有多少客戶可能受到该漏洞的影响。
该漏洞影响到Serv-U 15.2.3 HF1及之前的版本。成功利用该漏洞后，攻击者可在受感染的系统上运行任意代码。
此外，该漏洞使攻击者能够安装恶意程</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>应用商店下载量达580万的应用程序竟然盗取用户的密码</title>
    <link href="http://dianwoshishi.github.io/post/%E5%BA%94%E7%94%A8%E5%95%86%E5%BA%97%E4%B8%8B%E8%BD%BD%E9%87%8F%E8%BE%BE580%E4%B8%87%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%AB%9F%E7%84%B6%E7%9B%97%E5%8F%96%E7%94%A8%E6%88%B7%E7%9A%84%E5%AF%86%E7%A0%81.html"/>
    <id>http://dianwoshishi.github.io/post/%E5%BA%94%E7%94%A8%E5%95%86%E5%BA%97%E4%B8%8B%E8%BD%BD%E9%87%8F%E8%BE%BE580%E4%B8%87%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%AB%9F%E7%84%B6%E7%9B%97%E5%8F%96%E7%94%A8%E6%88%B7%E7%9A%84%E5%AF%86%E7%A0%81.html</id>
    <published>2022-02-26T06:10:19.000Z</published>
    <updated>2022-02-26T06:10:19.809Z</updated>
    
    <content type="html"><![CDATA[<h1 id="应用商店下载量达580万的应用程序竟然盗取用户的密码"><a href="#应用商店下载量达580万的应用程序竟然盗取用户的密码" class="headerlink" title="应用商店下载量达580万的应用程序竟然盗取用户的密码"></a>应用商店下载量达580万的应用程序竟然盗取用户的密码</h1><p><img src="https://techviral.net/wp-content/uploads/2017/11/OMG-Google-Detects-New-Android-Malware-That-Can-Spy-On-Users.jpg" alt="查看源图像"></p><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>研究人员发现了谷歌商店(Google Play)中9个盗取凭证的应用程序，这些应用能够偷取用户的Facebook登录凭证。</p><p><img src="https://cdn.arstechnica.net/wp-content/uploads/2021/07/google-play-800x532.jpeg" alt="Apps with 5.8 million Google Play downloads stole users’ Facebook passwords"></p><h2 id="盗取用户名密码"><a href="#盗取用户名密码" class="headerlink" title="盗取用户名密码"></a>盗取用户名密码</h2><p>据安全公司Dr.Web发表的一篇文章称，为了赢得用户的信任并降低他们的警惕性，这些应用程序提供了功能齐全的照片编辑和取景、运动和训练、星座和删除安卓设备上的垃圾文件等服务。所有被确认的应用程序都为用户提供了一个选项，即通过登录他们的Facebook账户来禁用应用内广告。选择该选项的用户看到一个真正的Facebook登录框，其中包含输入用户名和密码的字段。</p><p><img src="https://cdn.wccftech.com/wp-content/uploads/2016/10/malware-android.jpg" alt="img"></p><h2 id="来自同一木马变体"><a href="#来自同一木马变体" class="headerlink" title="来自同一木马变体"></a>来自同一木马变体</h2><p>研究人员确定了藏在应用程序中的五个恶意软件变体。其中三个是原生安卓应用，其余两个使用谷歌的Flutter框架，该框架是为跨平台兼容而设计。Dr.Web说，它把所有这些都归类为同一个木马，因为它们使用相同的配置文件格式和相同的JavaScript代码来窃取用户数据。</p><h2 id="受影响的应用清单"><a href="#受影响的应用清单" class="headerlink" title="受影响的应用清单"></a>受影响的应用清单</h2><p>大部分的下载是针对一个名为PIP Photo的应用程序，其访问量超过580万次。覆盖面次之的应用程序是Processing Photo，下载量超过50万次。其余的应用是</p><p>Rubbish Cleaner，垃圾清理器：超过10万次下载<br>Inwell Fitness，英威健身：超过10万次下载<br>Horoscope Daily，星座日报：超过100,000次下载<br>App Lock Keep：超过50,000次下载<br>Lockit Master：超过5,000次下载<br>Horoscope Pi，星座Pi：超过5,000次下载 1,000次下载<br>App Lock Manager：10次下载</p><h2 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h2><p>在Google Play搜索显示，所有的应用程序都已从Play中删除。谷歌发言人表示，该公司还禁止所有9个应用程序的开发者进入商店，这意味着他们将不被允许提交新的应用程序。谷歌这样做是对的，但这对开发者来说无所谓，因为他们可以用不同的名字注册一个新的开发者账户，只需一次性支付25美元即可。</p><p>任何下载了上述应用程序的人都应该彻底检查他们的设备和他们的Facebook账户，看看是否有任何被破坏的迹象。从已知的安全公司下载一个免费的安卓防病毒应用程序，并扫描其他恶意应用程序。</p>]]></content>
    
    
    <summary type="html">应用商店下载量达580万的应用程序竟然盗取用户的密码


摘要
研究人员发现了谷歌商店(Google Play)中9个盗取凭证的应用程序，这些应用能够偷取用户的Facebook登录凭证。



盗取用户名密码
据安全公司Dr.Web发表的一篇文章称，为了赢得用户的信任并降低他们的警惕性，这些应用程序提供了功能齐全的照片编辑和取景、运动和训练、星座和删除安卓设备上的垃圾文件等服务。所有被确认的应用程序都为用户提供了一个选项，即通过登录他们的Facebook账户来禁用应用内广告。选择该选项的用户看到一个真正的Facebook登录框，其中包含输入用户名和密码的字段。



来自同一木马变体
研究人员</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每天感染1000台设备，这款恶意软件专为挖矿而来、超过9000个XMR币被开采出来</title>
    <link href="http://dianwoshishi.github.io/post/%E4%B8%80%E6%AC%BE%E5%90%8D%E4%B8%BACrackonosh%E7%9A%84%E5%8A%A0%E5%AF%86%E8%B4%A7%E5%B8%81%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E8%A2%AB%E5%8F%91%E7%8E%B0.html"/>
    <id>http://dianwoshishi.github.io/post/%E4%B8%80%E6%AC%BE%E5%90%8D%E4%B8%BACrackonosh%E7%9A%84%E5%8A%A0%E5%AF%86%E8%B4%A7%E5%B8%81%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E8%A2%AB%E5%8F%91%E7%8E%B0.html</id>
    <published>2022-02-26T06:10:07.000Z</published>
    <updated>2022-02-26T06:13:06.151Z</updated>
    
    <content type="html"><![CDATA[<h1 id="每天感染1000台设备，这款恶意软件专为挖矿而来、超过9000个XMR币被开采出来"><a href="#每天感染1000台设备，这款恶意软件专为挖矿而来、超过9000个XMR币被开采出来" class="headerlink" title="每天感染1000台设备，这款恶意软件专为挖矿而来、超过9000个XMR币被开采出来"></a>每天感染1000台设备，这款恶意软件专为挖矿而来、超过9000个XMR币被开采出来</h1><p><img src="https://www.cybersafe.news/wp-content/uploads/2021/06/monero-800x400.png" alt="img"></p><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>一款在攻击过程中利用Windows安全模式的加密货币挖矿恶意软件被发现，每天约有1,000台设备被攻击，全球已有超过22.2万台机器被感染。该恶意软件至少从2018年6月就开始蔓延，最新版本于2020年11月发布。研究人员表示，只要人们还下载破解的软件，恶意软件就会一直蔓延下去</p><h2 id="名为Crackonosh的恶意软件"><a href="#名为Crackonosh的恶意软件" class="headerlink" title="名为Crackonosh的恶意软件"></a>名为Crackonosh的恶意软件</h2><p>一款在攻击过程中滥用Windows安全模式的加密货币挖矿恶意软件被发现，它通过盗版和破解软件传播，并经常出现在torrents, forums, 和 “warez “网站中。</p><p>Avast的研究人员将这种恶意软件称为Crackonosh。研究人员指出，该恶意软件至少从2018年6月就开始蔓延，第一个受害者是运行伪装成合法软件的破解版软件而被攻击。</p><p>每天约有1,000台设备被攻击，全球已有超过22.2万台机器被感染。</p><p>主要利用系统算力和资源来挖掘<a href="https://www.xmr-zh.com/">门罗币</a>（XMR）（一种加密货币）。Crackonosh总共产生了至少200万美元的门罗币，有超过9000个XMR币被开采出来。</p><p><img src="https://img.jinse.com/281169_image3.png" alt="查看源图像"></p><p><img src="https://www.getmonero.us/upload/attach/202009/1_UB57RFD5QRG5WYD.jpg" alt="查看源图像"></p><p>到目前为止，该恶意软件的30个变种已被确认，最新版本于2020年11月发布。</p><h2 id="感染流程"><a href="#感染流程" class="headerlink" title="感染流程"></a>感染流程</h2><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>感染链从一个安装程序和一个修改Windows注册表的脚本开始，允许主要的恶意软件可执行文件在安全模式下运行。被感染的系统被设置为在下次启动时以安全模式启动。</p><h3 id="抗杀软"><a href="#抗杀软" class="headerlink" title="抗杀软"></a>抗杀软</h3><p>研究人员说，当Windows系统处于安全模式时，杀毒软件就不会工作。这使得恶意的Serviceinstaller.exe能够轻易地禁用和删除Windows Defender。它还使用WQL查询所有安装的杀毒软件<code> SELECT * FROM AntiVirusProduct</code>.</p><p>Crackonosh将检查防病毒程序的存在，如Avast、Kaspersky、McAfee的扫描器、Norton和Bitdefender - 并尝试禁用或删除它们。然后擦除日志系统文件以掩盖其痕迹。</p><h3 id="阻止Windows更新"><a href="#阻止Windows更新" class="headerlink" title="阻止Windows更新"></a>阻止Windows更新</h3><p>Crackonosh还将试图停止Windows更新，并将用一个假的绿色勾选托盘图标取代Windows安全。</p><h3 id="挖矿"><a href="#挖矿" class="headerlink" title="挖矿"></a>挖矿</h3><p>最后，部署了一个XMRig，这是一个加密货币矿工，利用系统算力和资源来挖掘<a href="https://www.xmr-zh.com/">门罗币</a>（XMR）（一种加密货币）。</p><p>Avast研究人员表示，只要人们还下载破解的软件，恶意软件就会一直蔓延下去</p>]]></content>
    
    
    <summary type="html">每天感染1000台设备，这款恶意软件专为挖矿而来、超过9000个XMR币被开采出来


摘要
一款在攻击过程中利用Windows安全模式的加密货币挖矿恶意软件被发现，每天约有1,000台设备被攻击，全球已有超过22.2万台机器被感染。该恶意软件至少从2018年6月就开始蔓延，最新版本于2020年11月发布。研究人员表示，只要人们还下载破解的软件，恶意软件就会一直蔓延下去

名为Crackonosh的恶意软件
一款在攻击过程中滥用Windows安全模式的加密货币挖矿恶意软件被发现，它通过盗版和破解软件传播，并经常出现在torrents, forums, 和 “warez “网站中。

Avast</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>一个用Go编程语言编写的新木马被用于勒索攻击</title>
    <link href="http://dianwoshishi.github.io/post/%E6%96%B0%E7%9A%84GoLang%E6%9C%A8%E9%A9%AC.html"/>
    <id>http://dianwoshishi.github.io/post/%E6%96%B0%E7%9A%84GoLang%E6%9C%A8%E9%A9%AC.html</id>
    <published>2022-02-26T06:09:59.000Z</published>
    <updated>2022-02-26T06:09:59.962Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一个用Go编程语言编写的新木马被用于勒索攻击"><a href="#一个用Go编程语言编写的新木马被用于勒索攻击" class="headerlink" title="一个用Go编程语言编写的新木马被用于勒索攻击"></a>一个用Go编程语言编写的新木马被用于勒索攻击</h1><p><img src="https://cystory-images.s3.amazonaws.com/GoLang_Malware.png" alt="img"></p><p>被称为ChaChi的恶意软件，在2020年上半年被发现，远程访问木马（RAT）的原始变体已经与针对法国地方政府当局的网络攻击有关，但现在，一个更为复杂的变体已经出现。现有的最新样本已与针对美国大型学校和教育机构发起的攻击有关。</p><h2 id="Go语言开发的恶意软件"><a href="#Go语言开发的恶意软件" class="headerlink" title="Go语言开发的恶意软件"></a>Go语言开发的恶意软件</h2><p>ChaChi是用GoLang（Go）编写的，这种编程语言由于其通用性和跨平台代码编译的便利性，现在被攻击者使用。 </p><p><img src="https://www.cybersafe.news/wp-content/uploads/2021/06/Golang-800x400.png" alt="img"></p><p>据Intezer称，在过去几年中，基于Go的恶意软件样本大约增加了2000%。据黑莓威胁研究和情报部门的研究团队称，由于这是一个新现象，许多核心分析工具仍在开发。这可能使分析Go的恶意软件更具挑战性。</p><p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2019/07/golang-hacker.jpg" alt="img"></p><h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><p>ChaChi之所以这样命名，是因为Chashell和Chisel是恶意软件在攻击过程中使用的两个现成的工具。Chashell是一个通过DNS提供的反向外壳，而Chisel是一个端口转发系统。</p><h2 id="能力"><a href="#能力" class="headerlink" title="能力"></a>能力</h2><p>与ChaChi的第一个变种相比，该恶意软件具有较差的混淆和低级别的攻击能力，现在能够执行典型的RAT活动，包括创建后门和数据渗透，以及通过Windows本地安全授权子系统服务（LSASS）进行证书转储、网络枚举、DNS隧道、SOCKS代理功能、服务创建和跨网络横向移动。该恶意软件使用一个可开源的GoLang工具gobfuscate进行混淆。</p><h2 id="黑客组织PYSA"><a href="#黑客组织PYSA" class="headerlink" title="黑客组织PYSA"></a>黑客组织PYSA</h2><p>黑莓研究人员认为，该木马是PYSA&#x2F;Mespinoza的作品，该威胁组织以发起勒索软件活动和使用扩展名而闻名。当受害者的文件被加密时，PYSA代表 “保护你的系统Amigo”。</p><p>通常PYSA专注于 “猎杀大型游戏”( “big game hunting” )，并挑选那些能够支付大笔赎金的目标。这些攻击是有针对性的，由人类操作员控制，而不是自动化执行。</p>]]></content>
    
    
    <summary type="html">一个用Go编程语言编写的新木马被用于勒索攻击


被称为ChaChi的恶意软件，在2020年上半年被发现，远程访问木马（RAT）的原始变体已经与针对法国地方政府当局的网络攻击有关，但现在，一个更为复杂的变体已经出现。现有的最新样本已与针对美国大型学校和教育机构发起的攻击有关。

Go语言开发的恶意软件
ChaChi是用GoLang（Go）编写的，这种编程语言由于其通用性和跨平台代码编译的便利性，现在被攻击者使用。 



据Intezer称，在过去几年中，基于Go的恶意软件样本大约增加了2000%。据黑莓威胁研究和情报部门的研究团队称，由于这是一个新现象，许多核心分析工具仍在开发。这可能使分析</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>小心! 网络犯罪分子正在对加密货币用户进行攻击</title>
    <link href="http://dianwoshishi.github.io/post/%E5%B0%8F%E5%BF%83!%20%E7%BD%91%E7%BB%9C%E7%8A%AF%E7%BD%AA%E5%88%86%E5%AD%90%E6%AD%A3%E5%9C%A8%E5%AF%B9%E5%8A%A0%E5%AF%86%E8%B4%A7%E5%B8%81%E7%94%A8%E6%88%B7%E8%BF%9B%E8%A1%8C%E6%94%BB%E5%87%BB.html"/>
    <id>http://dianwoshishi.github.io/post/%E5%B0%8F%E5%BF%83!%20%E7%BD%91%E7%BB%9C%E7%8A%AF%E7%BD%AA%E5%88%86%E5%AD%90%E6%AD%A3%E5%9C%A8%E5%AF%B9%E5%8A%A0%E5%AF%86%E8%B4%A7%E5%B8%81%E7%94%A8%E6%88%B7%E8%BF%9B%E8%A1%8C%E6%94%BB%E5%87%BB.html</id>
    <published>2022-02-26T06:09:50.000Z</published>
    <updated>2022-02-26T06:09:50.820Z</updated>
    
    <content type="html"><![CDATA[<h1 id="小心-网络犯罪分子正在对加密货币用户进行攻击"><a href="#小心-网络犯罪分子正在对加密货币用户进行攻击" class="headerlink" title="小心! 网络犯罪分子正在对加密货币用户进行攻击"></a>小心! 网络犯罪分子正在对加密货币用户进行攻击</h1><p><img src="https://cyware-ent.s3.amazonaws.com/image_bank/f464_shutterstock_1076473562.jpg" alt="Watch Out! Cybercriminals are Hitting Hard at Cryptocurrency Users"></p><p>随着网络犯罪分子不断发展他们的攻击技术和恶意软件，非法的加密挖矿活动正在飞速增长。上升的主要原因之一是快速增长的加密货币汇率。</p><p>此外，新数字货币的引入和加密货币的正式交易，使人们对加密货币滥用和加密货币诈骗带来的新威胁产生了怀疑。根据Akamai最近的报告，在2020年3月至2021年5月期间，虚假的加密货币交易所钓鱼网址激增超过500%。这些钓鱼网址最终使攻击者能够秘密地盗取钱财。然而，攻击者正在将重点从URL转移到恶意应用程序，以欺骗用户并赚取更多利润。</p><h2 id="BitScam和CloudScam"><a href="#BitScam和CloudScam" class="headerlink" title="BitScam和CloudScam"></a>BitScam和CloudScam</h2><p>最近，Lookout威胁实验室的安全研究人员发现了170多个安卓应用，这些应用欺骗对加密货币感兴趣的人。<br>根据研究人员的发现，这些应用程序被归类为BitScam和CloudScam。这些应用程序承诺帮助受害者进行云采矿，而不需要额外的商品或服务。<br>这两个版本都提供了加密采矿的订阅和服务，用户可以通过Google Play的应用内付费系统来启用。<br>BitScam与CloudScam的唯一区别是在支付选项中增加了比特币和以太坊。<br>然而，受害者并不知道，攻击者正在眼皮下利用他们。据悉，攻击者至少骗取了35万美元的加密货币资金。</p><h2 id="更深层次-的攻击"><a href="#更深层次-的攻击" class="headerlink" title="更深层次 的攻击"></a>更深层次 的攻击</h2><p>联邦调查局发布了一份关于正在进行的针对加密货币所有者和第三方平台的攻击的警告。<br>该警告显示，攻击者正在使用几种战术来控制目标的加密货币交易所账户并窃取数字货币。<br>冒充支付平台和利用SIM卡交换攻击是攻击者用来发动攻击的一些战术。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>随着加密货币变得更加重要，看到它在越来越多的受到攻击将不足为奇，例如DDoS勒索和勒索软件攻击。鉴于与加密货币相关的攻击对消费者和企业的潜在影响，强烈建议建立主动的安全监测和控制。</p>]]></content>
    
    
    <summary type="html">小心! 网络犯罪分子正在对加密货币用户进行攻击


随着网络犯罪分子不断发展他们的攻击技术和恶意软件，非法的加密挖矿活动正在飞速增长。上升的主要原因之一是快速增长的加密货币汇率。

此外，新数字货币的引入和加密货币的正式交易，使人们对加密货币滥用和加密货币诈骗带来的新威胁产生了怀疑。根据Akamai最近的报告，在2020年3月至2021年5月期间，虚假的加密货币交易所钓鱼网址激增超过500%。这些钓鱼网址最终使攻击者能够秘密地盗取钱财。然而，攻击者正在将重点从URL转移到恶意应用程序，以欺骗用户并赚取更多利润。

BitScam和CloudScam
最近，Lookout威胁实验室的安全研究人员</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>“太空网络”支持宇航员在太空视频聊天</title>
    <link href="http://dianwoshishi.github.io/post/%E5%8D%AB%E6%98%9F%E4%BA%92%E8%81%94%E7%BD%91.html"/>
    <id>http://dianwoshishi.github.io/post/%E5%8D%AB%E6%98%9F%E4%BA%92%E8%81%94%E7%BD%91.html</id>
    <published>2022-02-26T06:09:41.000Z</published>
    <updated>2022-02-26T06:09:42.320Z</updated>
    
    <content type="html"><![CDATA[<h1 id="“太空网络”支持宇航员在太空视频聊天"><a href="#“太空网络”支持宇航员在太空视频聊天" class="headerlink" title="“太空网络”支持宇航员在太空视频聊天"></a>“太空网络”支持宇航员在太空视频聊天</h1><p><img src="/post/%E5%8D%AB%E6%98%9F%E4%BA%92%E8%81%94%E7%BD%91/image-20210624215411991.png"></p><p>2021 年 6 月 23 日上午，在距离地球约 400 公里的中国天河空间站核心舱上，三名宇航员在北京控制中心接到了地面的第一个视频通话，高分辨率图像给许多人留下了深刻的印象。语音，以及几乎零延迟的地面空间连接。是什么让连接如此顺畅？答案是卫星互联网。</p><p>由中国航天科技集团公司和中国航天科技集团公司共同主办的《中国航天报》称，由三颗国产天链卫星组成的“太空网络”保证了地面和太空之间的畅通无阻。</p><h2 id="什么是卫星互联网？"><a href="#什么是卫星互联网？" class="headerlink" title="什么是卫星互联网？"></a>什么是卫星互联网？</h2><p><img src="https://th.bing.com/th/id/Rb8def9d0c7ad45f664dcd3664cf1a0b2?rik=fl8nFmSp3HzlxA&pid=ImgRaw"></p><p>卫星互联网是从绕地球运行的卫星传输的无线互联网。它与有线或 DSL 等陆基互联网服务有很大不同，后者通过电线传输数据。卫星互联网允许您通过从固定在您财产上的碟形天线(俗称卫星锅)向太空中的地球同步卫星发送无线信号来访问万维网。信号会回传到您的互联网提供商的网络接入点，并传输回您的天线、调制解调器，最后是您的计算机，从而完全无线地将您连接到互联网。就像使用任何其他类型的互联网连接一样，您可以使用卫星互联网进行从下载和流媒体到上传和游戏的所有常规在线活动。</p><h2 id="卫星互联网是如何工作的？"><a href="#卫星互联网是如何工作的？" class="headerlink" title="卫星互联网是如何工作的？"></a>卫星互联网是如何工作的？</h2><p>卫星互联网通过三个独立的卫星天线将用户连接到网络；一个悬浮在太空中，一个驻留在互联网服务提供商的中心，一个连接到你的设备。</p><p>卫星互联网的工作原理是使用无线电波与绕地球运行的卫星进行通信。数据通过通信网络发送和检索，该网络从您的设备开始，通过您的调制解调器和卫星天线，到达太空中的卫星，然后返回地球，到达称为网络运营中心 (NOC) 的地面站。然后，数据通过此网络传回太空，然后返回地球上的卫星天线，以在您的设备上传输数据。</p><p><img src="https://th.bing.com/th/id/R52dcc8df47a16021d7bb07a35be95da6?rik=rpXNDsC0HtGlyA&pid=ImgRaw"></p><p><img src="https://www.viasat.com/content/dam/viasat/corpblog/customers/758412_How_Satellite_Internet_Works_002.gif"></p><p>如上所述，卫星互联网信号传输到固定在赤道上方的卫星，然后传输到您的家庭天线，并根据需要来回传输。</p><h2 id="卫星互联网组成"><a href="#卫星互联网组成" class="headerlink" title="卫星互联网组成"></a>卫星互联网组成</h2><p><img src="https://th.bing.com/th/id/R7a12b03f83ee7e86daadbd918c7c4ee7?rik=iiffuzm7CBGQCw&pid=ImgRaw"></p><p>卫星互联网使用<strong>五部分中继系统</strong>：</p><ul><li>联网设备</li><li>调制解调器&#x2F;路由器</li><li>卫星天线</li><li>太空中的卫星</li><li>网络运营中心 (NOC)</li></ul><h3 id="联网设备"><a href="#联网设备" class="headerlink" title="联网设备"></a>联网设备</h3><p>互联网就绪设备是可以通过适当的服务<strong>访问互联网的</strong>任何设备。这包括您的计算机、平板电脑、智能手机、智能电视、游戏机和任何其他支持互联网的设备。</p><p>当您在其中一台设备上使用互联网时，它会通过您的调制解调器&#x2F;路由器发送和接收数据。</p><h3 id="调制解调器-x2F-路由器"><a href="#调制解调器-x2F-路由器" class="headerlink" title="调制解调器&#x2F;路由器"></a>调制解调器&#x2F;路由器</h3><p><strong>转换数据：</strong> 调制解调器转换数据，使得数据可以在您的互联网就绪设备和卫星天线之间移动。您可以使用线缆将某些设备（如计算机、智能电视或游戏机）直接连接到调制解调器。</p><h3 id="卫星天线"><a href="#卫星天线" class="headerlink" title="卫星天线"></a>卫星天线</h3><p>中继的下一步是您的家庭卫星天线。这个碟形天线必须<strong>精确定位</strong>(由微波的波长决定)，以便向在轨供应商的卫星发射信号并接收回信息。</p><p><img src="https://th.bing.com/th/id/R53569baf1bff6a1039b7c435ff9457da?rik=vXXifd9VoOHw8g&pid=ImgRaw"></p><h3 id="太空中的卫星"><a href="#太空中的卫星" class="headerlink" title="太空中的卫星"></a>太空中的卫星</h3><p>在<strong>距离</strong>地球表面大约<strong>22,000</strong> <strong>英里的</strong>地方，传统卫星互联网服务中使用的卫星悬停在赤道上空。它们随行星旋转，因此信号中继保持一致。这称为地球静止轨道。这允许在您的碟形天线和提供商集线器或 NOC 之间<strong>进行双向数据通信</strong>。</p><h3 id="卫星网关和网络运营中心-NOC"><a href="#卫星网关和网络运营中心-NOC" class="headerlink" title="卫星网关和网络运营中心 (NOC)"></a>卫星网关和网络运营中心 (NOC)</h3><p>每当您从 Internet 请求信息时，无论您是单击链接、流式传输节目还是打开 Facebook，来自该请求的数据都会通过上述中继上传。然后卫星将请求发送给 NOC。</p><p>NOC 使用比您家里的卫星天线大得多的卫星天线接收您的请求。然后 NOC<strong>接入互联网骨干网</strong>，收集您请求的信息，并通过中继将其发送回给您。</p><p>所有这些过程，包括将信息发送到太空 22,000 英里并返回<em>两次</em>，都在<strong>几分之一秒内发生</strong>。</p><p>由于信息必须传播到很远的地方，您可能会注意到比 DSL 或有线互联网更多的<strong>延迟</strong>（也称为延迟）</p><h2 id="卫星互联网的优缺点是什么？"><a href="#卫星互联网的优缺点是什么？" class="headerlink" title="卫星互联网的优缺点是什么？"></a>卫星互联网的优缺点是什么？</h2><hr><p>虽然卫星互联网在某些地方通常是最好的（有时是唯一的）选择，但它也带来了一些独特的挑战，如果您选择 DSL 或有线互联网连接，您可能不会面临这些挑战。虽然卫星互联网仍在不断发展和改进，但该技术仍然缺乏有线和光纤互联网的速度和带宽能力。但是，使用卫星连接来装饰您的家有许多宝贵的好处。让我们仔细看看卫星互联网的优缺点。</p><h4 id="卫星互联网的优势"><a href="#卫星互联网的优势" class="headerlink" title="卫星互联网的优势"></a>卫星互联网的优势</h4><ul><li><strong>速度：</strong>您可以期待比标准拨号连接更快的速度，并且可以与卫星互联网服务提供商的 DSL 互联网相媲美。</li><li><strong>覆盖范围：</strong>因为卫星是完全无线的，这种互联网类型几乎在全国任何地方都可用，甚至在船上和房车上。无论您的住所多么偏远，您都可以依靠卫星连接访问网络。</li><li><strong>可靠性：</strong>与有线或 DSL 等流行的地面互联网类型相比，使用卫星连接遇到网络中断的可能性要小得多。</li></ul><h4 id="卫星互联网的缺点"><a href="#卫星互联网的缺点" class="headerlink" title="卫星互联网的缺点"></a>卫星互联网的缺点</h4><ul><li><strong>天气：</strong>您所在位置的天气会影响卫星互联网设置的信号路径。无论是大雨、大雪还是强风，信号都可能因您无法控制的气候因素而中断。</li><li><strong>VPN 不兼容：</strong>不幸的是，虚拟专用网络 (VPN) 与卫星互联网不兼容。VPN 需要高带宽容量才能进行功能上传和下载，并且需要低延迟——这是卫星连接无法保留的两个基本要素。</li><li><strong>高延迟：</strong>延迟问题（互联网连接中的延迟）通常是由于信号必须传播以促进网络连接的距离而导致的，这导致宽带应用程序（即视频游戏、视频聊天、4K 流媒体等）变慢和滞后。</li></ul><h2 id="卫星互联网有多快？"><a href="#卫星互联网有多快？" class="headerlink" title="卫星互联网有多快？"></a>卫星互联网有多快？</h2><p>卫星互联网速度范围为 12 到 100 Mbps，这对于发送电子邮件、浏览和在线学习等常见在线活动来说已经足够了。</p><h2 id="卫星互联网与卫星电视有何不同"><a href="#卫星互联网与卫星电视有何不同" class="headerlink" title="卫星互联网与卫星电视有何不同"></a>卫星互联网与卫星电视有何不同</h2><p><img src="https://www.viasat.com/content/dam/viasat/corpblog/customers/CONUS_v_Spot-beams-1.png"></p><p>卫星电视只向一个方向播放，从卫星向家庭播放视频信号，没有“返航”。互联网信号必须双向传输，而且由于进出的信号不像视频那样广播，因此移动所有数据需要更多的带宽。</p><h2 id="美国星链计划（商业化）"><a href="#美国星链计划（商业化）" class="headerlink" title="美国星链计划（商业化）"></a>美国星链计划（商业化）</h2><p>星链，是美国太空探索技术公司的一个项目，太空探索技术公司计划在2019年至2024年间在太空搭建由约1.2万颗卫星组成的“星链”网络提供互联网服务，其中1584颗将部署在地球上空550千米处的近地轨道，并从2020年开始工作。</p><p>但据有关文件显示，该公司还准备再增加3万颗，使卫星总量达到约4.2万颗。 </p><p>2021年3月11日，美国太空探索技术公司(SpaceX)的“猎鹰9”号运载火箭，携带一组60颗“星链”互联网卫星在美佛罗里达州发射升空  。5月5日，SpaceX发射了60颗Starlink卫星  。5月15日，SpaceX使用八手火箭发射52颗星链卫星</p><h2 id="中国天链卫星"><a href="#中国天链卫星" class="headerlink" title="中国天链卫星"></a>中国天链卫星</h2><p>“天链”顾名思义是“天上的信息链”，<strong>主要为飞船、空间实验室、空间站等载人航天器提供数据中继和测控服务，为中低轨道遥感、测绘、气象等卫星提供数据中继和测控服务，为航天器发射提供测控支持。****天链卫星将能够有效支撑我国空间站通讯任务，我们将能够随时跟天上航天员进行视频通话。</strong></p><p>天链卫星是中国在地球静止轨道上飞行的数据跟踪和中继通信卫星。它们的主要任务是在全球范围内为在轨航天器提供数据中继、测控和传输服务。</p><p><img src="https://nimg.ws.126.net/?url=http://dingyue.ws.126.net/2021/0623/f51b5aefj00qv561j003ec000rs00g4m.jpg&thumbnail=650x2147483647&quality=80&type=jpg"></p><p>该站网络下行速率为1.2G，相当于地面5G通信速度，时间延迟仅在一秒内。</p><p>2008年至2012年，中国先后发射了天链一号01号、天链一号02号和天链一号03号三颗数据跟踪中继卫星。卫星产业链使中国成为世界上第二个拥有覆盖中低轨卫星和载人航天器的中继卫星系统的国家。</p><p>随后几年，天链一号04于2016年进入轨道，天链二号01号于2019年作为国家第二代卫星中的第一颗发射升空。</p><p>所有卫星将合作改进数据跟踪和传输。天链II-01首次用于载人任务，可以监控多个目标，并提供更好的性能和更高的效率。</p><p>天链I-05、天链II-02和天链II-03正在研制中。 </p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://ishare.ifeng.com/c/s/7lZgd4iQHrF">https://ishare.ifeng.com/c/s/7lZgd4iQHrF</a></p><p>3名航天员实现天地通话，在空间站还能刷视频？这事没那么简单！,<a href="https://www.163.com/dy/article/GD6DRFQE05328YVR.html">https://www.163.com/dy/article/GD6DRFQE05328YVR.html</a></p><p>How does China’s satellite chain help taikonauts make home calls?，<a href="https://news.cgtn.com/news/2021-06-23/How-does-China-s-satellite-chain-help-taikonauts-make-home-calls--11k73Oj6YKI/index.html">https://news.cgtn.com/news/2021-06-23/How-does-China-s-satellite-chain-help-taikonauts-make-home-calls--11k73Oj6YKI/index.html</a></p><p><a href="https://www.bandwidthplace.com/satellite-internet/">https://www.bandwidthplace.com/satellite-internet/</a></p><p>5G-equivalanet network speeds in space empower taikonaut’s unimpeded video call with ground，<a href="https://www.globaltimes.cn/page/202106/1226871.shtml">https://www.globaltimes.cn/page/202106/1226871.shtml</a></p>]]></content>
    
    
    <summary type="html">“太空网络”支持宇航员在太空视频聊天


2021 年 6 月 23 日上午，在距离地球约 400 公里的中国天河空间站核心舱上，三名宇航员在北京控制中心接到了地面的第一个视频通话，高分辨率图像给许多人留下了深刻的印象。语音，以及几乎零延迟的地面空间连接。是什么让连接如此顺畅？答案是卫星互联网。

由中国航天科技集团公司和中国航天科技集团公司共同主办的《中国航天报》称，由三颗国产天链卫星组成的“太空网络”保证了地面和太空之间的畅通无阻。

什么是卫星互联网？


卫星互联网是从绕地球运行的卫星传输的无线互联网。它与有线或 DSL 等陆基互联网服务有很大不同，后者通过电线传输数据。卫星互联网允许</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>微软披露路由器NETGEAR固件漏洞</title>
    <link href="http://dianwoshishi.github.io/post/%E5%BE%AE%E8%BD%AF%E6%8A%AB%E9%9C%B2NETGEAR%E5%9B%BA%E4%BB%B6%E6%BC%8F%E6%B4%9E.html"/>
    <id>http://dianwoshishi.github.io/post/%E5%BE%AE%E8%BD%AF%E6%8A%AB%E9%9C%B2NETGEAR%E5%9B%BA%E4%BB%B6%E6%BC%8F%E6%B4%9E.html</id>
    <published>2022-02-26T06:09:33.000Z</published>
    <updated>2022-02-26T06:09:34.483Z</updated>
    
    <content type="html"><![CDATA[<h1 id="微软披露路由器NETGEAR固件漏洞"><a href="#微软披露路由器NETGEAR固件漏洞" class="headerlink" title="微软披露路由器NETGEAR固件漏洞"></a>微软披露路由器NETGEAR固件漏洞</h1><p><img src="https://www.cybersafe.news/wp-content/uploads/2021/07/netgear-800x400.png" alt="img"></p><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>网络安全研究人员披露了影响NETGEAR DGN2200v1系列路由器的关键安全漏洞，这些漏洞可以使认证绕过设备并访问存储的凭证。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>这三个HTTPd认证安全漏洞的CVSS评分为7.1-9.4，影响运行v1.0.0.60之前的固件版本的路由器，作为协调漏洞披露过程的一部分，该公司在2020年12月打了补丁。</p><p>微软365防御者研究团队的Jonathan Bar Or说，越来越多的固件攻击和通过VPN设备和其他面向互联网的系统进行的勒索软件攻击，这是在操作系统层之外和之下发起攻击的例子。由于这些类型的攻击已经变得很普遍，用户甚至必须确保运行其硬件的单一用途软件（如路由器）的安全。</p><p>这些漏洞允许使用认证旁路访问路由器管理页面，使攻击者能够达到对路由器的完全控制，还可以通过加密的侧信道攻击获得保存的路由器凭证，甚至通过利用配置备份&#x2F;恢复功能恢复存储在路由器内存中的用户名和密码。</p><p>研究人员还发现，凭证是用一个恒定的密钥进行加密的，随后可以用它来检索明文密码和用户名。</p><h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><p>建议所有NETGEAR DGN2200v1用户下载并更新到最新固件，以避免任何潜在的攻击。</p>]]></content>
    
    
    <summary type="html">微软披露路由器NETGEAR固件漏洞


摘要
网络安全研究人员披露了影响NETGEAR DGN2200v1系列路由器的关键安全漏洞，这些漏洞可以使认证绕过设备并访问存储的凭证。

正文
这三个HTTPd认证安全漏洞的CVSS评分为7.1-9.4，影响运行v1.0.0.60之前的固件版本的路由器，作为协调漏洞披露过程的一部分，该公司在2020年12月打了补丁。

微软365防御者研究团队的Jonathan Bar Or说，越来越多的固件攻击和通过VPN设备和其他面向互联网的系统进行的勒索软件攻击，这是在操作系统层之外和之下发起攻击的例子。由于这些类型的攻击已经变得很普遍，用户甚至必须确保运行其</summary>
    
    
    
    
  </entry>
  
</feed>
