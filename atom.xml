<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>点我试试的个人博客</title>
  
  
  <link href="http://dianwoshishi.github.io/atom.xml" rel="self"/>
  
  <link href="http://dianwoshishi.github.io/"/>
  <updated>2021-05-29T10:27:33.143Z</updated>
  <id>http://dianwoshishi.github.io/</id>
  
  <author>
    <name>点我试试</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>区块链中的密码学知识</title>
    <link href="http://dianwoshishi.github.io/2021/05/29/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%AD%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
    <id>http://dianwoshishi.github.io/2021/05/29/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%AD%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9F%A5%E8%AF%86/</id>
    <published>2021-05-29T09:09:45.328Z</published>
    <updated>2021-05-29T10:27:33.143Z</updated>
    
    <content type="html"><![CDATA[<p>原文为<a href="https://zhuanlan.zhihu.com/p/304725930">知乎</a>，现转移到个人博客。<br>转发微信公众号<a href="https://mp.weixin.qq.com/s/NkAWmPokc86Jc6nWtz4-yA">文章</a></p><h1 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h1><ol><li> <a href="#org63a3294">BitCoin是什么</a></li><li> <a href="#org1839db4">密码学是什么</a></li><li><a href="#org44c3a48">BitCoin中的密码学知识</a><pre><code> 1.  [哈希(Hash)](#org87067ef) 2.  [公钥密码体制](#orgb205e36)</code></pre></li><li> <a href="#org60092e2">总结</a></li><li> <a href="#orga6c2764">Reference</a></li></ol><p><a id="org63a3294"></a></p><h1 id="BitCoin是什么"><a href="#BitCoin是什么" class="headerlink" title="BitCoin是什么"></a>BitCoin是什么</h1><p>BitCoin，又称比特币，是2009年中本聪提出了一种点对点的数字现金系统，是一种分布式、点对点的货币,允许在线的交易不用经过中心化机构（如银行，支付宝）的情况下，在网络合作支持下，直接由一个用户发往另一个用户,并且可以提供防篡改，可验证的能力。<br>Bitcoin是最早实现“加密货币”这一概念的系统，该设想最早由戴伟（Dai Wei<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup>,音译）于1998年在cypherpunks函件用户组首次提出的:货币可以是任何东西或记录，只要它在一个国家或社会经济体系内被接受为商品服务的支付方式，或是债务偿还的方式。<br>比特币的设计核心思想是以密码学难题(cryptography puzzle)答案作为货币，其发行权独立于任何中央机构之外。</p><p>比特币使用了公开密钥系统<sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup>. 每一个钱币都包括了其拥有者的公开秘钥。当钱币从用户A支付给用户B时, A将B的公开秘钥添加到钱币中, 然后这个钱币又被A用私人密码匙来签名。B现在即拥有了这个钱币并且可以将来使用，而A就不可能再次使用这个钱币，因为以前的交易记录以被全体网络计算机记录。在每笔交易前，钱币的有效性都必须经过检验确认。</p><p><a id="org1839db4"></a></p><h1 id="密码学是什么"><a href="#密码学是什么" class="headerlink" title="密码学是什么"></a>密码学是什么</h1><p>密码学是一种使用先进的数学原理以特定的形式存储和传输数据的方法，以便只有它的目标用户能够读取和处理数据。密码学已经被人们用来在不被发现的情况下转发信息。随着互联网及信息技术的飞速发展，密码学被赋予了新的含义。密码哈希，电子签名等被广泛使用在防篡改，身份认证等场合。当前有三种广泛使用的加密形式：对称加密、非对称加密和哈希。</p><p><a id="org44c3a48"></a></p><h1 id="BitCoin中的密码学知识"><a href="#BitCoin中的密码学知识" class="headerlink" title="BitCoin中的密码学知识"></a>BitCoin中的密码学知识</h1><p>在中本聪的Bitcoin: A Peer-to-Peer Electronic Cash System一文中我们可以看见如下一段话，从这段话中我们可以看出密码学在BitCoin中的应用：</p><blockquote><p>We define an electronic coin as a chain of <strong><strong>digital signatures</strong></strong>. Each owner transfers the coin to the next by digitally <strong><strong>signing</strong></strong> a <strong><strong>hash</strong></strong> of the previous transaction and the <strong><strong>public key</strong></strong> of the next owner and adding these to the end of the coin. A payee can <strong><strong>verify the signatures</strong></strong> to verify the chain of ownership.——Bitcoin: A Peer-to-Peer Electronic Cash System[1]</p></blockquote><p>下面就主要从哈希和 公钥密码体制两个方面介绍BitCoin中的密码学知识。</p><p><a id="org87067ef"></a></p><h3 id="哈希-Hash"><a href="#哈希-Hash" class="headerlink" title="哈希(Hash)"></a>哈希(Hash)</h3><p>哈希（有时称“摘要”,密码散列,Hashing）是文本或数据文件的经过压缩的一种”指纹”。 Hash函数是把任意长度的输入通过散列函数或者说是hash函数转化为固定长度的输出的一种算法。这个输入区间可以无穷大，但输出区间是固定的。比如输入可以是任意的，输出是一个3位数。<br>这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来确定唯一的输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。</p><p>BitCoin中的hash函数主要有SHA-256，RIPEME-160，hash的一个主要应用是Merkle树,其中算法前缀“SHA”和”RIPEMD”表示基础算法，数字后缀”256”和”160”表示输出的固定长度。 </p><p>在比特币协议中，SHA256和RIPEMD160一起用于保护数字签名中使用的公钥。SHA256方法也用于比特币挖掘中的工作函数证明，并作为数字签名算法的一部分。</p><ol><li><p>SHA-256</p><p> SHA就是安全哈希算法（Secure Hash Algorithm）的简写。SHA-256为文本生成几乎唯一的256位（32字节）签名。<br> 另外，比特币挖矿（mining）的cryptograph puzzle也是通过计算满足一定条件的hash来完成的，例如计算的满足256bit位hash前缀满足60个0(由区块链中区块内部的nonce决定)的hash。</p></li><li><p>RIPEME-160</p><p> RIPEMD（RIPE Message Digest）是1992年（原始RIPEMD）和1996年（其他变体）开发的一系列密码哈希函数。 该系列有五个功能：RIPEMD，RIPEMD-128，RIPEMD-160，RIPEMD-256和RIPEMD-320，其中RIPEMD-160是最常见的,也是比特币中使用的Hash算法之一。</p><p> 之所以使用RIPEMD，是因为它产生了最短的哈希,用于生成比特币地址,这允许比特币地址更短。同时，其唯一性仍得到了充分保证。 </p></li><li><p>Merkle Tree</p><p> Merkle树是一种哈希树，其中叶节点是根据数据块计算的加密哈希，而非叶节点是其直接子节点的哈希。根散列也称为数据的“摘要”。</p><p> o<br> 要验证一个记录，它需要一个数据“证明”，其中包含根路径上的节点。递归地重新计算新的根散列，并使用先前保存的摘要检查相等性。</p><p> 如下图：例如L4被修改，那么hash1-1，hash1，top hash 都会被重新计算，最终显示为Top hash的变化，只需要对比Top hash 就能够知道节点中的数据有没有被篡改。</p><p> <img src="/2021/05/29/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%AD%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9F%A5%E8%AF%86/Hash_Tree.jpg" alt="img" title="Merkle树"></p><p> Merkle 树将根存储在比特币区块中，验证者只用验证根的hash是否变化，就可以判断Merkle 树中的子节点是否被篡改，而不用验证全部的节点，极大的减少了验证的复杂度。</p><p> <img src="/2021/05/29/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%AD%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9F%A5%E8%AF%86/Merkle-Tree-representation-of-a-Block.png" alt="img" title="Merkle树表示"></p></li></ol><p><a id="orgb205e36"></a></p><h3 id="公钥密码体制"><a href="#公钥密码体制" class="headerlink" title="公钥密码体制"></a>公钥密码体制</h3><p>公钥密码体制使用*不同的加密密钥与解密密钥*，是一种“由已知加密密钥推导出解密密钥在计算上是不可行的”密码体制。</p><p>公钥密码体制使用的密钥分为公钥和私钥，两种密钥成对使用。使用公钥加密和私钥解密；使用私钥加密和公钥解密。</p><p>现有最著名的公钥密码体制是*RSA* 体制，它基于数论中大数分解问题，由美国三位科学家 Rivest, Shamir 和 Adleman 于 1976 年提出并在 1978 年正式发表的。</p><p>公钥密码体制根据使用秘钥的不同，可以分为两类：发送者使用发送者的私钥处理数据，接受者使用发送者的公钥逆向处理，为签名；发送者使用接受者的公钥处理数据，接受者使用接受者的私钥处理数据，为加密。下面分别讨论这两种方式：</p><ol><li><p>非对称加密</p><p> 非对称密码学利用两个密钥（公共密钥和私有密钥）来加密和解密特定数据。例如：我发消息给你，用你的公钥进行加密，而你用自己的私钥进行解密，你的公钥可以公开，但是你的私钥只有自己知道.这样每个人都可以给你发信息，但只有你自己能通过私钥解密查看。</p><p> 下图为正常的加密、解密流程：</p><p> <img src="/2021/05/29/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%AD%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9F%A5%E8%AF%86/68637037-67713000-0538-11ea-85c9-177b3b26aa5a.png" alt="img" title="密码体制及应用"></p><p> 两种常用的非对称加密算法：Rivest-Shamir-Adleman算法又称为RSA，椭圆曲线密码（ECC）。</p></li><li><p>数字签名</p><p> 比特币本身是不加密的，那么比特币不加密怎么安全呢？</p><p> 如果我要交易，把我的比特币给你，那么我在交易上，用我的私钥进行签名，大家都可以用我的公钥进行验证，这样大家都能知道确实是我进行的交易，证明币是你的，这就涉及到了数字签名。</p><p> 如下图所示：发送者用自己的private key 处理message 和 经过hash的message digest，然后通过信道发送个接受者，接受者通过发送者的public key逆向处理消息，得到message 和 message disgest，通过验证hash(message)是否与messagedigest相等，可以验证是否是发送者发来的消息。</p><p> <img src="/2021/05/29/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%AD%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9F%A5%E8%AF%86/image002.jpg" alt="img" title="数字签名"></p></li></ol><p><a id="org60092e2"></a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>随着互联网和公钥密码体制的发展，人们越来越关注安全和隐私，密码学在日常生活中处处可见，掌握必要的密码学知识至关重要。</p><p>bitcoin通过一系列密码算法的组合，实现了一个分布式、点对点、可信、可验证、不可篡改的加密数字货币，比特币种的密码学知识主要有哈希，公钥密码体制，数字签名。</p><p><a id="orga6c2764"></a></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>[1] Wright, C. S. (2019). Bitcoin: A Peer-to-Peer Electronic Cash System. SSRN Electronic Journal, 1–9. <a href="https://doi.org/10.2139/ssrn.3440802">https://doi.org/10.2139/ssrn.3440802</a></p><h1 id="Footnotes"><a href="#Footnotes" class="headerlink" title="Footnotes"></a>Footnotes</h1><p><sup><a id="fn.1" href="#fnr.1">1</a></sup> <a href="https://en.bitcoin.it/wiki/Wei_Dai">https://en.bitcoin.it/wiki/Wei_Dai</a></p><p><sup><a id="fn.2" href="#fnr.2">2</a></sup> <a href="http://zh.wikipedia.org/wiki/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86">http://zh.wikipedia.org/wiki/公开密钥加密</a></p>]]></content>
    
    
    <summary type="html">原文为知乎，现转移到个人博客。
转发微信公众号文章

Table of Contents
 1.  BitCoin是什么
 2.  密码学是什么
 3. BitCoin中的密码学知识 1.  [哈希(Hash)](#org87067ef)
     2.  [公钥密码体制](#orgb205e36)
    
    
    
 4.  总结
 5.  Reference



BitCoin是什么
BitCoin，又称比特币，是2009年中本聪提出了一种点对点的数字现金系统，是一种分布式、点对点的货币,允许在线的交易不用经过中心化机构（如银行，支付宝）的情况下，在网络合作支持下，直接由一个</summary>
    
    
    
    <category term="学习" scheme="http://dianwoshishi.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="比特币" scheme="http://dianwoshishi.github.io/tags/%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
    <category term="区块链" scheme="http://dianwoshishi.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="密码学" scheme="http://dianwoshishi.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>关于RFC文档有趣的事情</title>
    <link href="http://dianwoshishi.github.io/2021/05/29/%E5%85%B3%E4%BA%8ERFC%E6%96%87%E6%A1%A3%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8B%E6%83%85/"/>
    <id>http://dianwoshishi.github.io/2021/05/29/%E5%85%B3%E4%BA%8ERFC%E6%96%87%E6%A1%A3%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8B%E6%83%85/</id>
    <published>2021-05-29T03:17:15.941Z</published>
    <updated>2021-05-29T10:34:09.623Z</updated>
    
    <content type="html"><![CDATA[<p>原文为知乎<a href="https://zhuanlan.zhihu.com/p/337997798">文章</a>， 现转移到个人博客。</p><h1 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h1><ol><li> <a href="#org34ce3f0">事情的起源</a></li><li><a href="#orgbd0ef9b">研究经过</a><ol><li> <a href="#orgd742468">查询相关资料</a></li><li> <a href="#org7b36c8c">查询相关RFC</a></li><li><a href="#orge2e0fc8">一个想法</a><ol><li> <a href="#org3061772">第一个发现</a></li><li> <a href="#org4e04c37">第二个发现</a></li><li> <a href="#org2636b5a">第三个发现</a></li><li> <a href="#org9ff55be">第四个发现</a></li></ol></li></ol></li><li> <a href="#org9564d4b">总结</a></li></ol><p><a id="org34ce3f0"></a></p><h1 id="事情的起源"><a href="#事情的起源" class="headerlink" title="事情的起源"></a>事情的起源</h1><p>一次被问起，为何TLSv1.0(RFC2246),TLSv1.1(RFC4346),TLSv1.2(RFC5246),TLSv1.3(RFC8446)中的RFC编号都是以64结尾。印象中关于RFC编号都是递增的，因为RFC写好之后就不允许再修改了，如果有新的标准出来，只能在其后某个编号出现，并且引用之前的RFC。<br>但是上述这个问题，TLS四个版本均以64结尾，也太凑巧了，确实很让人疑惑。本着好奇，去研究了研究这事。</p><p>&lt;！–more–&gt;</p><p><a id="orgbd0ef9b"></a></p><h1 id="研究经过"><a href="#研究经过" class="headerlink" title="研究经过"></a>研究经过</h1><p><a id="orgd742468"></a></p><h2 id="查询相关资料"><a href="#查询相关资料" class="headerlink" title="查询相关资料"></a>查询相关资料</h2><p>首先在网上搜索为什么TLS均以64结尾，网上的回答基本上来自如下解释</p><blockquote><p>In the IETF, protocols are called RFCs. TLS 1.0 was RFC 2246, TLS 1.1 was RFC 4346, and TLS 1.2 was RFC 5246. Today, TLS 1.3 was published as RFC 8446. RFCs are generally published in order, keeping 46 as part of the RFC number is a nice touch<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup>.</p></blockquote><p>显然，并没有解决我们的问题。</p><p><a id="org7b36c8c"></a></p><h2 id="查询相关RFC"><a href="#查询相关RFC" class="headerlink" title="查询相关RFC"></a>查询相关RFC</h2><p>思考是否会有某个RFC对这事做了说明吗？查询未果。<br>但是在此过程中，我发现了在RFC文档中，有相邻两个递增编号文档，但是RFC时间并不递增的现象。举个例子</p><blockquote><p>1478 An Architecture for Inter-Domain Policy Routing. M. Steenstrup. June</p><ol><li> (Format: TXT, HTML) (Status: HISTORIC) (DOI: 10.17487/RFC1478)</li></ol><p>1479 Inter-Domain Policy Routing Protocol Specification: Version 1. M.<br>     Steenstrup. July 1993. (Format: TXT, HTML) (Status: HISTORIC) (DOI:<br>     10.17487/RFC1479) </p><p>1480 The US Domain. A. Cooper, J. Postel. June 1993. (Format: TXT, HTML)<br>     (Obsoletes RFC1386) (Status: INFORMATIONAL) (DOI: 10.17487/RFC1480) </p></blockquote><p>其中RFC1478的时间为1993年6月，RFC1479的时间为1993年7月，但是RFC1480的时间为1993年6月，出现了非递增的情况。</p><p>虽然又发现，但好像并没有什么卵用。但是自然会想到，有可能时间上有大的反复吗？有年的反复现象吗？</p><p><a id="orge2e0fc8"></a></p><h2 id="一个想法"><a href="#一个想法" class="headerlink" title="一个想法"></a>一个想法</h2><p><a id="org3061772"></a></p><h3 id="第一个发现"><a href="#第一个发现" class="headerlink" title="第一个发现"></a>第一个发现</h3><p>所以就想分析分析RFC文档的编号的时间问题。第一想法是爬虫，但是工作量太复杂。左搜索右搜索，找到了官网提供的XML版列表<sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup>.超级开心。然后写了个python脚本，自动进行了分析(忽略并不想改的变量名，来自一个豆瓣电影爬虫)。</p><pre><code>#!/usr/bin/python3import calendarfrom xml.dom.minidom import parseimport xml.dom.minidomimport numpy as npimport matplotlib.pyplot as plt # 使用minidom解析器打开 XML 文档DOMTree = xml.dom.minidom.parse(&quot;rfc-index.xml&quot;)collection = DOMTree.documentElementif collection.hasAttribute(&quot;shelf&quot;):   print (&quot;Root element : %s&quot; % collection.getAttribute(&quot;shelf&quot;))# 在集合中获取所有电影movies = collection.getElementsByTagName(&quot;rfc-entry&quot;)# 打印每部电影的详细信息print (&quot;*****Movie*****&quot;)x = [];years = [];months = [];total = [];for movie in movies:   type = movie.getElementsByTagName(&#39;doc-id&#39;)[0].childNodes[0].data   id = int(type[3:]);   x.append(id);#    print (&quot;doc-id: %d&quot; % id)#    author = movie.getElementsByTagName(&#39;author&#39;)[0]#    print (&quot;author: %s&quot; % author.childNodes[1].data)   date = movie.getElementsByTagName(&#39;date&#39;)[0]   month = date.getElementsByTagName(&#39;month&#39;)[0].childNodes[0].data;   int_month = int(list(calendar.month_name).index(month))   months.append(int_month);#    print (&quot;date month: %d&quot; % int_month)   year = int(date.getElementsByTagName(&#39;year&#39;)[0].childNodes[0].data);#    print (&quot;date year: %d&quot; % year)   years.append(year);#    description = movie.getElementsByTagName(&#39;description&#39;)[0]#    print (&quot;Description: %s&quot; % description.childNodes[0].data)   total.append(year + 10  + int_month  )plt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Arial Unicode MS&#39;]plt.rcParams[&#39;axes.unicode_minus&#39;] = False   # 解决保存图像是负号&#39;-&#39;显示为方块的问题plt.title(&quot;Matplotlib&quot;) plt.xlabel(&quot;RFC编号&quot;) plt.ylabel(&quot;年份&quot;) plt.plot(x,years, label=r&#39;年&#39;) plt.plot(x,total, label=r&#39;年 + 月 + 10(向上平移10)&#39;) # plt.subplot(2,1,1)# plt.plot(x,years) # plt.subplot(2,1,2)# plt.plot(x,months) plt.legend();plt.grid()plt.show()</code></pre><p>经过经过分析有了如下所示图：<br><img src="/2021/05/29/%E5%85%B3%E4%BA%8ERFC%E6%96%87%E6%A1%A3%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8B%E6%83%85/%E5%B9%B4%E4%BB%BD%E5%9B%BE.png" alt="img"><br>果然有问题！！！！上图横坐标为RFC编号，纵坐标为RFC编号对应的年份。可以看出RFC文档从一九六几年到今天一共发表8000余份。有意思的是，其中有一些凸起的部分，就是一些异常点。例如2000年前有一个极高的凸起，这代表这个编号的年份远远超出这个编号附近的年份，这与我们的常识不符。实际上，查看这个异常点，如下图所示：<br><img src="/2021/05/29/%E5%85%B3%E4%BA%8ERFC%E6%96%87%E6%A1%A3%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8B%E6%83%85/image-20201218225458777.png" alt="img"><br>其中RFC1849的年份为2010年，但其附近的RFC文档编号均为1995年，其中相差15年，造成第一幅图中的凸起。</p><p><a id="org4e04c37"></a></p><h3 id="第二个发现"><a href="#第二个发现" class="headerlink" title="第二个发现"></a>第二个发现</h3><p>同时，我们还会发现另一个有意思的现象。如下图所示：<br><img src="/2021/05/29/%E5%85%B3%E4%BA%8ERFC%E6%96%87%E6%A1%A3%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8B%E6%83%85/%E6%95%B4%E6%95%B0%E9%97%B4%E9%9A%94%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="整数间隔示意图"><br>其中编号为1299，1399，1499，1599，1699,&#x2026;等，均出现凸起现象。并且实际上1299，1399，1499，1599，1699，1799，1899，1999的年份均为1997年。存在明显的人为痕迹。</p><p><a id="org2636b5a"></a></p><h3 id="第三个发现"><a href="#第三个发现" class="headerlink" title="第三个发现"></a>第三个发现</h3><p>年份和月份基本满足递增，但是有波动。如下图所示：<br><img src="/2021/05/29/%E5%85%B3%E4%BA%8ERFC%E6%96%87%E6%A1%A3%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8B%E6%83%85/%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="img"><br>放大后：<br><img src="/2021/05/29/%E5%85%B3%E4%BA%8ERFC%E6%96%87%E6%A1%A3%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8B%E6%83%85/%E7%A4%BA%E6%84%8F%E5%9B%BE%E6%94%BE%E5%A4%A7.png" alt="img"><br>为方便对比，将其中月份显示为（年+月，再向上平移10个单位(年)）。</p><p><a id="org9ff55be"></a></p><h3 id="第四个发现"><a href="#第四个发现" class="headerlink" title="第四个发现"></a>第四个发现</h3><p>TLS的主要作者，目前是Eric Rescorla。对TLS四个版本作者做简单统计，如下图：<br><img src="/2021/05/29/%E5%85%B3%E4%BA%8ERFC%E6%96%87%E6%A1%A3%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8B%E6%83%85/image-20201218231640006.png" alt="img"><br>可以看出，最开始Tim Dierks逐渐从第二作者，向第一作者上升，此时带了个徒弟。慢慢Tim Dierks开始退居二线，Eric Rescorla开始独挡一面（纯属胡说八道）。</p><p><a id="org9564d4b"></a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>虽然并没有直接的证据来回答开头提出的问题，但是我们可以发现以下现象：</p><ul><li>  RFC的编号并非严格的时间递增，而是存在一些波动</li><li>  RFC的编号中存在一些，小概率发生的现象，例如等间隔凸起</li></ul><p>基于以上现象呢，我们可以大胆猜测（hu shuo ba dao）：</p><ul><li>  RFC编号的审批机构，会因为某些原因，保留一些编号</li><li>  RFC的编号其实并没有想象中的那么严格</li><li>  大佬在RFC编号中具有一定的发言权，可以”预定“一些编号。如TLSv1，2，3，4以64结尾</li></ul><h1 id="Footnotes"><a href="#Footnotes" class="headerlink" title="Footnotes"></a>Footnotes</h1><p><sup><a id="fn.1" href="#fnr.1">1</a></sup> <a href="https://blog.cloudflare.com/rfc-8446-aka-tls-1-3/">https://blog.cloudflare.com/rfc-8446-aka-tls-1-3/</a></p><p><sup><a id="fn.2" href="#fnr.2">2</a></sup> <a href="https://www.rfc-editor.org/rfc-index.xml">https://www.rfc-editor.org/rfc-index.xml</a></p>]]></content>
    
    
    <summary type="html">原文为知乎文章， 现转移到个人博客。

Table of Contents
 1.  事情的起源
 2. 研究经过 1.  查询相关资料
     2.  查询相关RFC
     3. 一个想法 1.  第一个发现
         2.  第二个发现
         3.  第三个发现
         4.  第四个发现
        
        
    
    
 3.  总结



事情的起源
一次被问起，为何TLSv1.0(RFC2246),TLSv1.1(RFC4346),TLSv1.2(RFC5246),TLSv1.3(RFC8446)中的RFC编号都是以64结尾</summary>
    
    
    
    <category term="研究" scheme="http://dianwoshishi.github.io/categories/%E7%A0%94%E7%A9%B6/"/>
    
    
    <category term="RFC" scheme="http://dianwoshishi.github.io/tags/RFC/"/>
    
    <category term="编号" scheme="http://dianwoshishi.github.io/tags/%E7%BC%96%E5%8F%B7/"/>
    
    <category term="python" scheme="http://dianwoshishi.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>基于netfilter的IP数据统计设计</title>
    <link href="http://dianwoshishi.github.io/2021/05/29/%E5%9F%BA%E4%BA%8Enetfilter%E7%9A%84IP%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E8%AE%BE%E8%AE%A1%E4%B8%8ELinux%E9%A9%B1%E5%8A%A8%E5%AE%9E%E7%8E%B0/"/>
    <id>http://dianwoshishi.github.io/2021/05/29/%E5%9F%BA%E4%BA%8Enetfilter%E7%9A%84IP%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E8%AE%BE%E8%AE%A1%E4%B8%8ELinux%E9%A9%B1%E5%8A%A8%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-05-29T03:12:54.799Z</published>
    <updated>2021-05-29T08:54:57.814Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h1><ol><li> <a href="#orgab76e7a">背景</a></li><li><a href="#org02ac451">IP信息统计</a><ol><li> <a href="#org62d4d73">统计信息设计</a></li><li> <a href="#org44f97b2">存储数据结构</a></li></ol></li><li><a href="#orgde188bf">Linux驱动</a><ol><li> <a href="#orgc0bb933">网络型驱动设备</a></li><li> <a href="#org9e48264">字符型设备</a></li><li> <a href="#org8ee7f64">用户代码</a></li></ol></li><li><a href="#org3f4753d">总结</a><ol><li> <a href="#org01bad05">Linux 驱动</a></li><li> <a href="#orgd1e6a5e">Linux内核</a></li><li> <a href="#org4c6ff33">其他</a></li></ol></li><li> <a href="#orgfe8069d">参考资料</a></li></ol><p><a id="orgab76e7a"></a></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>当今社会，没有都有自己的信息处理设备，如手机、计算机甚至可能是路由器。在使用这些设备的时候，我们想知道的一件事就是，我的电脑和那些设备有过通信，通信情况怎么样，以便在网络出现问题，如拥塞，或是自己主机被黑客控制出现异常数据的时候，能够通过上述统计信息快速定位问题所在。因此本文通过Linux驱动中的netfilter对IP数据报中的IP信息进行统计，通过字符型驱动实现用户态查看统计信息，达到了统计主机通信的目的，为进一步做好异常处理打下了基础。</p><p><a id="org02ac451"></a></p><h1 id="IP信息统计"><a href="#IP信息统计" class="headerlink" title="IP信息统计"></a>IP信息统计</h1><p><a id="org62d4d73"></a></p><h2 id="统计信息设计"><a href="#统计信息设计" class="headerlink" title="统计信息设计"></a>统计信息设计</h2><p>统计对象为源IP地址，信息内容目前设计为：IP出现频次，最后一个IP数据包出现时的时间戳。</p><pre><code>typedef struct IPData&#123;  int timestamp;  int count&#125;ipdata;</code></pre><p><a id="org44f97b2"></a></p><h2 id="存储数据结构"><a href="#存储数据结构" class="headerlink" title="存储数据结构"></a>存储数据结构</h2><p>由于在Linux Kernel中没有C++的set，map等数据结构，因此使用其提供的红黑树实现IP信息的快速存储和读取。其中红黑树节点的信息如下所示：</p><pre><code>   typedef struct roc_node_s&#123;    struct rb_node node;    void *ctx;    int key;    ipdata ipcount;&#125;roc_node_t;</code></pre><p>红黑树的实现使用Linux Kernel自带的rbtree数据结构，头文件为：</p><pre><code>#include &lt;linux/rbtree.h&gt;</code></pre><p>红黑树插入，删除等代码参考链接为：<a href="https://blog.csdn.net/chn475111/article/details/52594457">https://blog.csdn.net/chn475111/article/details/52594457</a>.</p><pre><code>/** * filename: my_rbtree.h * @author lijk@.infosec.com.cn * @version 0.0.1 * @date 2016-9-20 11:52:06 */#include &lt;linux/string.h&gt;#include &lt;linux/rbtree.h&gt;typedef struct IPData&#123;  int timestamp;  int count&#125;ipdata;typedef struct roc_node_s&#123;    struct rb_node node;    void *ctx;    int key;    ipdata ipcount;&#125;roc_node_t;typedef void (*roc_cb)(void*);roc_node_t* roc_search(struct rb_root *root, int key)&#123;    struct rb_node *node = root-&gt;rb_node;    while(node)    &#123;        roc_node_t *data = rb_entry(node, roc_node_t, node);        int result = key - data-&gt;key;        if (result &lt; 0)            node = node-&gt;rb_left;        else if (result &gt; 0)            node = node-&gt;rb_right;        else            return data;    &#125;    return NULL;&#125;int roc_insert(struct rb_root *root, roc_node_t *data)&#123;    struct rb_node **new = &amp;(root-&gt;rb_node), *parent = NULL;    while(*new)    &#123;        roc_node_t *this = rb_entry(*new, roc_node_t, node);        int result = data-&gt;key - this-&gt;key;        parent = *new;        if (result &lt; 0)            new = &amp;((*new)-&gt;rb_left);        else if (result &gt; 0)            new = &amp;((*new)-&gt;rb_right);        else            return 0;    &#125;    rb_link_node(&amp;data-&gt;node, parent, new);    rb_insert_color(&amp;data-&gt;node, root);    return 1;&#125;void roc_erase(struct rb_root *root, int key, roc_cb cb)&#123;    roc_node_t *data = roc_search(root, key);    if(data)    &#123;        rb_erase(&amp;data-&gt;node, root);        RB_CLEAR_NODE(&amp;data-&gt;node);        if(cb) cb(data);    &#125;&#125;void roc_destroy(struct rb_root *root, roc_cb cb)&#123;    roc_node_t *pos = NULL;    struct rb_node *node = NULL;    while((node = rb_first(root)))    &#123;        pos = rb_entry(node, roc_node_t, node);    #ifdef _DEBUG        sprintf(message, &quot;key = %d\n&quot;, pos-&gt;key);    #endif        rb_erase(&amp;pos-&gt;node, root);        RB_CLEAR_NODE(&amp;pos-&gt;node);        if(cb) cb(pos);    &#125;&#125;void roc_dump(struct rb_root *root)&#123;    struct rb_node *node = NULL;  int sip, count, timestamp;  //printk(&quot;roc_dump&quot;);    memset(message, 0, MAX_SIZE);    for(node = rb_first(root); strlen(message) &lt; MAX_SIZE &amp;&amp; node != NULL; node = rb_next(node))&#123;  sip = (unsigned int)rb_entry(node, roc_node_t, node)-&gt;key ;     count = (unsigned int)rb_entry(node, roc_node_t, node)-&gt;ipcount.count ;     timestamp = (unsigned int)rb_entry(node, roc_node_t, node)-&gt;ipcount.timestamp ;    sprintf(message, &quot;%s%d.%d.%d.%d|%d|%d,&quot;,message, NIPQUAD( sip), count, timestamp);      //printk(message);    &#125;&#125;void roc_free(void *ptr)&#123;    roc_node_t *node = (roc_node_t*)ptr;    if(node)    &#123;        if(node-&gt;ctx) kfree(node-&gt;ctx);        kfree(node);    &#125;&#125;int test(int argc, char const *argv[])&#123;    struct rb_root root = RB_ROOT;    int loop = 0;    roc_node_t *node = NULL;    for(loop = 0; loop &lt; 100; loop ++)    &#123;        node = (roc_node_t*)kmalloc(sizeof(roc_node_t), GFP_KERNEL );        if(node == NULL)            break;        node-&gt;ctx = NULL;        node-&gt;key = loop;        roc_insert(&amp;root, node);    &#125;#if 0    for(loop = 0; loop &lt; 100; loop ++)        roc_erase(&amp;root, loop, roc_free);#endif    roc_dump(&amp;root);    roc_destroy(&amp;root, roc_free);    return 0;&#125;</code></pre><p><a id="orgde188bf"></a></p><h1 id="Linux驱动"><a href="#Linux驱动" class="headerlink" title="Linux驱动"></a>Linux驱动</h1><p>考虑在内核实现的原因是目前Linux相关设备非常多，可能具有一定的参考价值和移植性。<br>笔者的内核环境为：</p><pre><code>  uname -r4.15.0-142-generic</code></pre><p><a id="orgc0bb933"></a></p><h2 id="网络型驱动设备"><a href="#网络型驱动设备" class="headerlink" title="网络型驱动设备"></a>网络型驱动设备</h2><p>netfilter的相关参考资料为：Linnux5.0.0下，基于Netlink与NetFilter对本机数据包进行筛选监控,<a href="https://blog.csdn.net/qq_40758751/article/details/105117750">https://blog.csdn.net/qq_40758751/article/details/105117750</a> , netfilter数据包过滤, <a href="https://blog.csdn.net/specialsun/article/details/84695519">https://blog.csdn.net/specialsun/article/details/84695519</a><br>因为本文为源Ip数据包信息统计，所以netfilter hook的层级在NF<sub>INET</sub><sub>LOCAL</sub><sub>IN</sub>.<br>Hook 函数为filter<sub>http</sub>(忽略函数名，粘贴过来，不想改了).</p><p><a id="org9e48264"></a></p><h2 id="字符型设备"><a href="#字符型设备" class="headerlink" title="字符型设备"></a>字符型设备</h2><p>内核态数据在用户态访问需要通过字符型设备驱动进行。因此建立一个字符型设备/dev/IPDataSet 使得用户态能够访问内核 态的数据信息。<br>参考资料：ubuntu 添加字符设备驱动程序, <a href="https://blog.csdn.net/ARAFATms/article/details/79397800">https://blog.csdn.net/ARAFATms/article/details/79397800</a><br>因为上述驱动需要自己手动添加字符设备，所以通过以下方法自动添加设备节点。<br>参考资料：linux驱动：自动创建设备节点, <a href="https://blog.csdn.net/u012247418/article/details/83684029">https://blog.csdn.net/u012247418/article/details/83684029</a></p><pre><code>// filename: filter_ip.c#ifndef __KERNEL__#define __KERNEL__#endif  /* __KERNEL__ */#include &lt;linux/module.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/types.h&gt;#include &lt;linux/string.h&gt;//#include &lt;asm/uaccess.h&gt;#include &lt;linux/netdevice.h&gt;#include &lt;linux/netfilter_ipv4.h&gt;  // ip4 netfilter,ipv6则需引入相应 linux/netfilter_ipv6.h#include &lt;linux/ip.h&gt;#include &lt;linux/tcp.h&gt;#include &lt;linux/sched.h&gt;#include &quot;linux/kernel.h&quot;#include &quot;linux/fs.h&quot;#include &quot;linux/errno.h&quot;#include &quot;linux/uaccess.h&quot;#include &quot;linux/kdev_t.h&quot;#include &lt;linux/device.h&gt;#include &lt;linux/time.h&gt;#define NIPQUAD(addr) \  ((unsigned char *)&amp;addr)[0], \  ((unsigned char *)&amp;addr)[1], \  ((unsigned char *)&amp;addr)[2], \  ((unsigned char *)&amp;addr)[3]  #define MAX_SIZE 1024 * 1024 * 8char message[MAX_SIZE] = &quot;&quot;;  //打开设备时会显示的消息#include &quot;my_rbtree.h&quot;struct rb_root root = RB_ROOT;int insert(int key, int timestamp)&#123;  roc_node_t *node = NULL;  node = roc_search(&amp;root, key);  if(node != NULL) &#123;    node-&gt;ipcount.count++;    node-&gt;ipcount.timestamp = timestamp;    return 1;  &#125;  node = (roc_node_t*)kmalloc(sizeof(roc_node_t), GFP_KERNEL );  node-&gt;ctx = NULL;  node-&gt;key = key;  node-&gt;ipcount.count = 1;  node-&gt;ipcount.timestamp = timestamp;  return roc_insert(&amp;root, node);&#125;struct timeval time;// 过滤http数据包unsigned int filter_http(char *type,struct sk_buff *pskb)&#123;  __be32 sip,dip;  int retval = NF_ACCEPT;  int ret, ms;  struct sk_buff *skb = pskb;  struct iphdr *iph = ip_hdr(skb);  // 获取ip头  sip = iph-&gt;saddr;    dip = iph-&gt;daddr;    //printk(&quot;Packet for source address: %d.%d.%d.%d destination address: %d.%d.%d.%d\n&quot;, NIPQUAD(sip), NIPQUAD(dip));    //sprintf(message, &quot;Packet for source address: %d.%d.%d.%d destination address: %d.%d.%d.%d\n&quot;, NIPQUAD(sip), NIPQUAD(dip));  do_gettimeofday(&amp;time);  /*第一次去获取时间*/  ms = time.tv_sec * 1000 + time.tv_usec / 1000;  ret = insert(sip, ms);  //if(ret == 1)&#123;      roc_dump(&amp;root);  printk(message);  //&#125;  return retval;&#125;unsigned int NET_HookLocalIn(void *priv,     struct sk_buff *pskb,     const struct nf_hook_state *state)&#123;  return filter_http(&quot;in&quot;,pskb);&#125;unsigned int NET_HookLocalOut(void *priv,     struct sk_buff *pskb,     const struct nf_hook_state *state)&#123;  //return filter_http(&quot;out&quot;,pskb);  return NF_ACCEPT;&#125;unsigned int NET_HookPreRouting(void *priv,     struct sk_buff *pskb,     const struct nf_hook_state *state)&#123;  return NF_ACCEPT;&#125;unsigned int NET_HookPostRouting(void *priv,     struct sk_buff *pskb,     const struct nf_hook_state *state)&#123;  return NF_ACCEPT;&#125;unsigned int NET_HookForward(void *priv,     struct sk_buff *pskb,     const struct nf_hook_state *state)&#123;  return NF_ACCEPT;&#125;// 钩子数组static struct nf_hook_ops net_hooks[] = &#123;  &#123;    .hook         = NET_HookLocalIn,        // 发往本地数据包    .pf            = PF_INET,    .hooknum    =    NF_INET_LOCAL_IN,    .priority    = NF_IP_PRI_FILTER-1,  &#125;,  &#123;    .hook         = NET_HookLocalOut,        // 本地发出数据包    .pf            = PF_INET,    .hooknum    =    NF_INET_LOCAL_OUT,    .priority    = NF_IP_PRI_FILTER-1,  &#125;,  &#123;    .hook         = NET_HookForward,        // 转发的数据包    .pf            = PF_INET,    .hooknum    =    NF_INET_FORWARD,    .priority    = NF_IP_PRI_FILTER-1,  &#125;,  &#123;    .hook        = NET_HookPreRouting,    // 进入本机路由前        .pf            = PF_INET,                    .hooknum    = NF_INET_PRE_ROUTING,            .priority    = NF_IP_PRI_FILTER-1,          &#125;,  &#123;    .hook        = NET_HookPostRouting,    // 本机发出包经路由后        .pf            = PF_INET,                    .hooknum    = NF_INET_POST_ROUTING,            .priority    = NF_IP_PRI_FILTER-1,          &#125;,&#125;;int my_open(struct inode *inode, struct file *file);int my_release(struct inode *inode, struct file *file);ssize_t my_read(struct file *file, char __user *user, size_t t, loff_t *f);ssize_t my_write(struct file *file, const char __user *user, size_t t, loff_t *f);char* devName = &quot;IPDataSet&quot;;//设备名struct file_operations pStruct =&#123; open:my_open,      release:my_release,      read:my_read,      write:my_write, &#125;;//打开int my_open(struct inode *inode, struct file *file)&#123;  printk(&quot;open lgsDrive OK!\n&quot;);  try_module_get(THIS_MODULE);  return 0;&#125;//关闭int my_release(struct inode *inode, struct file *file)&#123;  printk(&quot;Device released!\n&quot;);  module_put(THIS_MODULE);  return 0;&#125;//读设备里的信息ssize_t my_read(struct file *file, char __user *user, size_t t, loff_t *f)&#123;  roc_dump(&amp;root);  if(copy_to_user(user,message,t))  &#123;    return -2;  &#125;  return sizeof(message);&#125;//向设备里写信息ssize_t my_write(struct file *file, const char __user *user, size_t t, loff_t *f)&#123;  if(copy_from_user(message,user,t))  &#123;    return -3;  &#125;  return sizeof(message);&#125;static struct class *drv_class = NULL;int major = 0;//设备号static int __init nf_init(void) &#123;  int ret = 0;  //char device  major = register_chrdev(0, &quot;ipdataset_drv&quot;, &amp;pStruct);  drv_class = class_create(THIS_MODULE, &quot;ipdataset_drv&quot;);  device_create(drv_class, NULL, MKDEV(major, 0), NULL, devName);  //    ret = register_chrdev(0, devName, &amp;pStruct);  //    if (ret &lt; 0)  //    &#123;  //        printk(&quot;failed to register_chrdev.\n&quot;);  //        return -1;  //    &#125;  //    else  //    &#123;  //        printk(&quot;the lgsDrive has been registered!\n&quot;);  //        printk(&quot;id: %d\n&quot;, ret);  //        device_num = ret;  //   //        return 0;  //    &#125;  //net device  ret = nf_register_net_hook(&amp;init_net, net_hooks);  //ret = nf_register_hooks(net_hooks,ARRAY_SIZE(net_hooks));    // 安装钩子  if(ret)  &#123;    printk(KERN_ERR &quot;register hook failed\n&quot;);    return -1;  &#125;  printk(&quot;Start...\n&quot;);  return 0;&#125;void close(void)&#123;  roc_destroy(&amp;root, roc_free);&#125;static void __exit nf_exit(void)&#123;  close();  unregister_chrdev(major, &quot;ipdataset_drv&quot;);  device_destroy(drv_class, MKDEV(major, 0));  class_destroy(drv_class);  //unregister_chrdev(device_num, devName);  nf_unregister_net_hook(&amp;init_net, net_hooks);  //nf_unregister_hooks(net_hooks,ARRAY_SIZE(net_hooks));    // 卸载钩子  printk(&quot;Exit...\n&quot;);&#125;module_init(nf_init);module_exit(nf_exit);MODULE_LICENSE(&quot;Dual BSD/GPL&quot;);MODULE_AUTHOR(&quot;dianwoshishi&quot;);MODULE_DESCRIPTION(&quot;Netfilter IP Statistic&quot;);MODULE_VERSION(&quot;1.0.1&quot;);MODULE_ALIAS(&quot;Netfilter 01&quot;);</code></pre><p><a id="org8ee7f64"></a></p><h2 id="用户代码"><a href="#用户代码" class="headerlink" title="用户代码"></a>用户代码</h2><p>上述字符型设备创建了一个字符节点为：/dev/IPDataSet， 在用户态程序中，我们通过Linux编程中提供的read函数对驱动中的数据message进行读取。<br>代码如下：</p><pre><code>   #include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#define MAX_SIZE 1024 char message[MAX_SIZE] ;  //打开设备时会显示的消息int main(int num, char *arg[])&#123;    if(2 != num)&#123;        printf(&quot;Usage: %s /dev/IPDataSet\n&quot;, arg[0]);        return -1;    &#125;    int fd = open(arg[1], O_RDWR);    if(0 &gt; fd)&#123;        perror(&quot;open&quot;);        return -1;    &#125;    int ret = read(fd, message, MAX_SIZE);    printf(&quot;read: ret = %d. %s\n&quot;, ret, message);    memset(message, 0, MAX_SIZE);    ret = write(fd, message, MAX_SIZE);    printf(&quot;write: ret = %d.\n&quot;, ret);    close(fd);    return 0;&#125;</code></pre><p><a id="org3f4753d"></a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><a id="org01bad05"></a></p><h2 id="Linux-驱动"><a href="#Linux-驱动" class="headerlink" title="Linux 驱动"></a>Linux 驱动</h2><p>熟悉Linux驱动的编写流程。 了解了Linux内核代码与用户代码的不同，比较明显的就是缺少了类似C++ STL类似的好用的库，只能使用类似红黑树（rbtree)这样的数据结构来做一些set的操作，需要对红黑树有一定的了解。<br>网络设备驱动和字符型设备驱动的编写结构都差不多，但是目前也是一知半解，尤其是一些简单操作之外的特性还不了解，例如加锁？多线程？不知道</p><p><a id="orgd1e6a5e"></a></p><h2 id="Linux内核"><a href="#Linux内核" class="headerlink" title="Linux内核"></a>Linux内核</h2><p>Linux内核的设计模式还是比较令人佩服的，虽然不懂全貌，但是也能从局部出发，贡献一些力量。再一次感受到了设计的魅力。</p><p><a id="org4c6ff33"></a></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>一定要在虚拟机中编写、测试驱动，不知道有什么错出现，你就要重启你的电脑，boring！</p><p><a id="orgfe8069d"></a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>linux驱动编写（总结篇）,<a href="https://blog.csdn.net/feixiaoxing/article/details/79913476?spm=1001.2014.3001.5506">https://blog.csdn.net/feixiaoxing/article/details/79913476?spm=1001.2014.3001.5506</a><br>智能路由器设备流量、网速统计及上下线提醒（基于netfilter编程）,<a href="https://blog.csdn.net/u012819339/article/details/50513387?spm=1001.2014.3001.5506">https://blog.csdn.net/u012819339/article/details/50513387?spm=1001.2014.3001.5506</a><br>利用Linux内核模块Netfilter hook UDP报文, <a href="https://blog.csdn.net/qq_41791640/article/details/104933006?spm=1001.2014.3001.5506">https://blog.csdn.net/qq_41791640/article/details/104933006?spm=1001.2014.3001.5506</a><br>Netfilter的使用和实现, <a href="https://blog.csdn.net/zhangskd/article/details/22678659?spm=1001.2014.3001.5506">https://blog.csdn.net/zhangskd/article/details/22678659?spm=1001.2014.3001.5506</a></p>]]></content>
    
    
    <summary type="html">Table of Contents
 1.  背景
 2. IP信息统计 1.  统计信息设计
     2.  存储数据结构
    
    
 3. Linux驱动 1.  网络型驱动设备
     2.  字符型设备
     3.  用户代码
    
    
 4. 总结 1.  Linux 驱动
     2.  Linux内核
     3.  其他
    
    
 5.  参考资料



背景
当今社会，没有都有自己的信息处理设备，如手机、计算机甚至可能是路由器。在使用这些设备的时候，我们想知道的一件事就是，我的电脑和那些设备有过通信，通信情况怎么样，以便在网络出现问</summary>
    
    
    
    <category term="开发" scheme="http://dianwoshishi.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Linux" scheme="http://dianwoshishi.github.io/tags/Linux/"/>
    
    <category term="netfilter" scheme="http://dianwoshishi.github.io/tags/netfilter/"/>
    
    <category term="内核" scheme="http://dianwoshishi.github.io/tags/%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
</feed>
