<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>懂珠宝的NetW0rker的个人博客</title>
  
  
  <link href="http://dianwoshishi.github.io/atom.xml" rel="self"/>
  
  <link href="http://dianwoshishi.github.io/"/>
  <updated>2021-08-23T08:16:07.000Z</updated>
  <id>http://dianwoshishi.github.io/</id>
  
  <author>
    <name>懂珠宝的NetW0rker</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://dianwoshishi.github.io/2021/08/23/MQTT%E5%8D%8F%E8%AE%AE/"/>
    <id>http://dianwoshishi.github.io/2021/08/23/MQTT%E5%8D%8F%E8%AE%AE/</id>
    <published>2021-08-23T08:16:07.000Z</published>
    <updated>2021-08-23T08:16:07.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MQTT"><a href="#MQTT" class="headerlink" title="MQTT"></a>MQTT</h1><p>大家好，我是明说网络的小明同学。今天我们来聊一聊物联网通协议MQTT。</p><h2 id="什么是MQ"><a href="#什么是MQ" class="headerlink" title="什么是MQ"></a>什么是MQ</h2><p>消息队列最原始的模型：生产者先将消息投递一个叫做「队列」的容器中，然后再从这个容器中取出消息，最后再转发给消费者</p><p><img src="https://pic2.zhimg.com/80/v2-c38c2609bee9a1f9a638a38ef503d604_720w.jpg?source=1940ef5c" alt="img"></p><h3 id="消息队列有什么优势呢？"><a href="#消息队列有什么优势呢？" class="headerlink" title="消息队列有什么优势呢？"></a>消息队列有什么优势呢？</h3><p>MQ 解决的最核心的问题：系统解耦和异步：</p><p><img src="https://pic3.zhimg.com/80/v2-b0b81fcf533970cd71d23a85ec266e5b_720w.jpg?source=1940ef5c" alt="img"></p><blockquote><p>参考：<a href="https://www.zhihu.com/question/54152397">https://www.zhihu.com/question/54152397</a></p></blockquote><h3 id="从MQ的角度去理解MQTT"><a href="#从MQ的角度去理解MQTT" class="headerlink" title="从MQ的角度去理解MQTT"></a>从MQ的角度去理解MQTT</h3><p><strong>而MQTT是专门针对物联网设计的消息队列</strong>！实际上使用的是MQ其中的<strong>发布/订阅模式</strong></p><p><img src="https://images2018.cnblogs.com/blog/1355489/201808/1355489-20180823155237825-1191723728.png" alt="img"></p><h2 id="MQTT简介"><a href="#MQTT简介" class="headerlink" title="MQTT简介"></a>MQTT简介</h2><p>随着 5G 时代的来临，万物互联的伟大构想正在成为现实。海量的设备接入和设备管理对网络带宽、通信协议以及平台服务架构都带来了很大挑战。尤其对于物联网设备来说，电量消耗，资源控制等都尤为重要。在此背景下MQTT应运而生。</p><p><img src="https://pic3.zhimg.com/v2-55ba5fc5be6df6ec686e9d149e24fc6b_1440w.jpg?source=172ae18b" alt="物联网MQTT协议简易入门教程"></p><p>MQTT（Message Queuing Telemetry Transport，消息队列遥测传输协议），是一种基于发布/订阅（publish/subscribe）模式的”轻量级”通讯协议，该协议构建于TCP/IP协议上，由IBM在1999年发布（由 IBM 的 Andy Stanford-Clark 和 Arcom 的 Arlen Nipper 为了一个通过卫星网络连接输油管道的项目开发，之后 IBM 一直将 MQTT 作为一个内部协议在其产品中使用，直到 2010 年，IBM 公开发布了 MQTT 3.1 版本。在 2014 年，MQTT 协议正式成为了 OASIS（结构化信息标准促进组织）的标准协议，<a href="https://zhuanlan.zhihu.com/p/79455828">来源</a>）。MQTT最大优点在于，可以以极少的代码和有限的带宽，为连接远程设备提供实时可靠的消息服务。作为一种低开销、低带宽占用的即时通讯协议，使其在物联网、小型设备、移动应用等方面有较广泛的应用。MQTT 3 （当前版本3.1.1）是目前使用的最为广泛的 MQTT 协议标准。</p><h3 id="为什么选择MQTT"><a href="#为什么选择MQTT" class="headerlink" title="为什么选择MQTT"></a>为什么选择MQTT</h3><p>它的设计思想是轻巧、开放、简单、规范，易于实现。这些特点使得它对很多场景来说都是很好的选择，特别是对于受限的环境如机器与机器的通信（M2M）以及物联网环境（IoT）。</p><p><img src="/2021/08/23/MQTT%E5%8D%8F%E8%AE%AE/image-20210721090551290.png" alt="image-20210721090551290"></p><h3 id="MQTT的应用场景"><a href="#MQTT的应用场景" class="headerlink" title="MQTT的应用场景"></a>MQTT的应用场景</h3><p>MQTT 协议广泛应用于物联网、移动互联网、智能硬件、车联网、电力、能源等领域。</p><p><img src="/2021/08/23/MQTT%E5%8D%8F%E8%AE%AE/image-20210721090656372.png" alt="image-20210721090656372"></p><h3 id="相关参考资料"><a href="#相关参考资料" class="headerlink" title="相关参考资料"></a>相关参考资料</h3><p><a href="https://www.emqx.cn/mqtt">https://www.emqx.cn/mqtt</a></p><p><a href="https://www.runoob.com/w3cnote/mqtt-intro.html">https://www.runoob.com/w3cnote/mqtt-intro.html</a></p><p><a href="https://www.jianshu.com/p/ecde412d2eeb">https://www.jianshu.com/p/ecde412d2eeb</a></p><p>MQTT协议中文版，<a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/">https://mcxiaoke.gitbooks.io/mqtt-cn/content/</a></p><p><a href="https://zhuanlan.zhihu.com/p/158145940">https://zhuanlan.zhihu.com/p/158145940</a></p><h2 id="MQTT通信模型"><a href="#MQTT通信模型" class="headerlink" title="MQTT通信模型"></a>MQTT通信模型</h2><p>有别于传统的客户端/服务器通讯协议，MQTT协议并不是端到端的，消息传递通过代理，包括会话（session）也不是建立在发布者和订阅者之间，而是建立在端和代理之间。代理解除了发布者和订阅者之间的耦合。这对理解MQTT很重要</p><p>通过下面两个图理解MQTT</p><p><img src="https://pic1.zhimg.com/v2-1c26fc1a94a6fe3da6982d7e699c5ce8_r.jpg" alt="preview"></p><p><img src="/2021/08/23/MQTT%E5%8D%8F%E8%AE%AE/mqtt-fidge-2.svg" alt="img"></p><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><p>在MQTT中，有三个主要的角色：</p><ul><li>发布者（Publish）：类似于报纸发布者</li><li>代理（Broker）（服务器）：MQTT服务器以称为”消息代理”（Broker），可以是一个应用程序或一台设备。它是位于消息发布者和订阅者之间。类似于以前的报刊亭，会有很多人向报亭发布报纸，报停会更具不同的订阅分发报纸。</li><li>订阅者（Subscribe）：类似于报纸订阅者。</li></ul><p>需要注意的是，这里的发布者和订阅者并不是绝对的。发布者可以变成订阅者，订阅者也可以变成发布者，甚至是同一台设备既可以是发布者也可以是订阅者，甚至是broker。这是与现实中报亭的例子有些区别的地方，人们可以订报纸，同时还能发报纸，甚至是自己给自己卖报纸！</p><h3 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h3><p>这三个角色之间通过消息进行通信：MQTT传输的消息分为：主题（Topic）和负载（payload）两部分：</p><ul><li><p>（1）Topic，可以理解为消息的类型，订阅者订阅（Subscribe）后，就会收到该主题的消息内容（payload）</p><ul><li>连接到一个应用程序消息的标签，该标签与服务器的订阅相匹配。服务器会将消息发送给订阅所匹配标签的每个客户端。一个主题可以有多个级别，级别之间用斜杠字符分隔。例如，<code>/world</code> 和 <code>emq/emqtt/emqx</code> 是有效的主题。订阅者的Topic name支持通配符<code>#</code>和<code>+</code> ：<ul><li># 支持一个主题内任意级别话题</li><li>+只匹配一个主题级别的通配符</li></ul></li></ul></li><li><p>（2）payload，可以理解为消息的内容，是指订阅者具体要使用的内容。</p><ul><li><p>Payload`消息体</p><p>`CONNECT、SUBSCRIBE、SUBACK、UNSUBSCRIBE四种类型的消息 有消息体：</p><ul><li><code>CONNECT</code>，消息体内容主要是：客户端的ClientID、订阅的Topic、Message以及用户名和密码</li><li><code>SUBSCRIBE</code>，消息体内容是一系列的要订阅的主题以及<code>QoS</code>。</li><li><code>SUBACK</code>，消息体内容是服务器对于<code>SUBSCRIBE</code>所申请的主题及<code>QoS</code>进行确认和回复。</li><li><code>UNSUBSCRIBE</code>，消息体内容是要订阅的主题。</li></ul></li></ul></li></ul><h2 id="mosquitto使用"><a href="#mosquitto使用" class="headerlink" title="mosquitto使用"></a>mosquitto使用</h2><p>Mosquitto是一个实现了MQTT3.1协议的代理服务器，由MQTT协议创始人之一的Andy Stanford-Clark开发</p><p>学习网址：</p><p>libmosquitto编程：<a href="https://blog.csdn.net/dancer__sky/article/details/77855249">https://blog.csdn.net/dancer__sky/article/details/77855249</a></p><p> <a href="https://www.cnblogs.com/chen1-kerr/p/7258487.html">MQTT的学习之Mosquitto安装&amp;使用</a></p><p>MQTT服务端软件使用：<a href="https://zhuanlan.zhihu.com/p/56727359">https://zhuanlan.zhihu.com/p/56727359</a></p><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><p>MQTT安全篇：为何以及如何运用MQTT提供的安全特性来保证物联网项目的顺利实施 <a href="https://zhuanlan.zhihu.com/p/21421094">https://zhuanlan.zhihu.com/p/21421094</a></p>]]></content>
    
    
    <summary type="html">MQTT
大家好，我是明说网络的小明同学。今天我们来聊一聊物联网通协议MQTT。

什么是MQ
消息队列最原始的模型：生产者先将消息投递一个叫做「队列」的容器中，然后再从这个容器中取出消息，最后再转发给消费者



消息队列有什么优势呢？
MQ 解决的最核心的问题：系统解耦和异步：



参考：https://www.zhihu.com/question/54152397

从MQ的角度去理解MQTT
而MQTT是专门针对物联网设计的消息队列！实际上使用的是MQ其中的发布/订阅模式



MQTT简介
随着 5G 时代的来临，万物互联的伟大构想正在成为现实。海量的设备接入和设备管理对网络带宽、</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://dianwoshishi.github.io/2021/07/26/C%E8%AF%AD%E8%A8%80%E5%9B%9E%E5%A4%B4%E7%9C%8B--%E5%8F%8C%E8%83%9E%E8%83%8Ei++%E5%92%8C++i%E7%9A%84%E6%95%85%E4%BA%8B/"/>
    <id>http://dianwoshishi.github.io/2021/07/26/C%E8%AF%AD%E8%A8%80%E5%9B%9E%E5%A4%B4%E7%9C%8B--%E5%8F%8C%E8%83%9E%E8%83%8Ei++%E5%92%8C++i%E7%9A%84%E6%95%85%E4%BA%8B/</id>
    <published>2021-07-26T01:27:04.167Z</published>
    <updated>2021-07-26T14:54:25.672Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C语言回头看–诡异的i-和-i"><a href="#C语言回头看–诡异的i-和-i" class="headerlink" title="C语言回头看–诡异的i++和++i"></a>C语言回头看–诡异的i++和++i</h1><p>C语言中的<code>i++</code>和<code>++i</code>使用非常的方便，简单明了。但是很多人在学习C语言的过程中，对这两个语句还是存在恐惧，因为这两条语句会引起不必要的麻烦。例如：到底是先用再加，还是先加再用？ 同时在一些程序语句中也会出现一些令人意想不到的结果，例如<code>i=1,((++i)+(++i))=6</code>的情况，非常的诡异。</p><p>因此本文针对这个问题，深入到汇编层面，理解双胞胎i++和++i的故事。相信通过本文，你能够更加深刻的理解C语言中的自加自减等操作。</p><h2 id="例子介绍"><a href="#例子介绍" class="headerlink" title="例子介绍"></a>例子介绍</h2><h3 id="本文所用程序"><a href="#本文所用程序" class="headerlink" title="本文所用程序"></a>本文所用程序</h3><p>C语言文件如下所示，逻辑为：分别输出<code>i++</code>和<code>++i</code>的结果。</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">#include &lt;stdio.h&gt;int main()&#123;int i &#x3D; 0;printf(&quot;i &#x3D; 0,++i &#x3D; %d\n&quot;, ++i);i &#x3D; 0;printf(&quot;i &#x3D; 0,i++ &#x3D; %d\n&quot;, i++);i &#x3D; 1;printf(&quot;i &#x3D; 1,(i++)+(++i) &#x3D; %d\n&quot;, (i++)+(++i));i &#x3D; 1;printf(&quot;i &#x3D; 1,(++i)+(i++) &#x3D; %d\n&quot;, (++i)+(i++));i &#x3D; 1;printf(&quot;i &#x3D; 1,(++i)+(++i) &#x3D; %d\n&quot;, (++i)+(++i));return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用<code>make</code>进行构建，<code>makefile</code>如下所示</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">OBJ<span class="token operator">=</span>selfincre<span class="token symbol"><span class="token variable">$</span>(OBJ)</span><span class="token punctuation">:</span>g++ -Wall main.c -o <span class="token variable">$@</span><span class="token symbol">clean</span><span class="token punctuation">:</span>-rm -rf <span class="token variable">$</span><span class="token punctuation">(</span>OBJ<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>本机所用的环境如下所示：</p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">Ubuntu 16.04 (64位，内核版本4.15.0-142-generic）gcc version 5.4.0 20160609 (Ubuntu 5.4.0-6ubuntu1~16.04.12)make：GNU Make 4.1，Built for x86_64-pc-linux-gnu<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>结果如下：</p><p><img src="/2021/07/26/C%E8%AF%AD%E8%A8%80%E5%9B%9E%E5%A4%B4%E7%9C%8B--%E5%8F%8C%E8%83%9E%E8%83%8Ei++%E5%92%8C++i%E7%9A%84%E6%95%85%E4%BA%8B/image-20210726110945317.png" alt="image-20210726110945317"></p><h2 id="汇编分析"><a href="#汇编分析" class="headerlink" title="汇编分析"></a>汇编分析</h2><p>在ubuntu中我们使用<code>objdump ~d ./selfincre &gt; objdump.txt</code>，将程序进行反汇编，我们将不重要的信息剔除，只保留<code>main</code>函数，如下所示，在部分汇编语句中进行了注释，可以结合‘餐食’。</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">.&#x2F;selfincre:     file format elf64-x86-640000000000400526 &lt;main&gt;:  400526:55                   push   %rbp  400527:48 89 e5             mov    %rsp,%rbp  40052a:48 83 ec 10          sub    $0x10,%rsp  40052e:c7 45 fc 00 00 00 00 movl   $0x0,-0x4(%rbp) # -0x4(%rbp) 是局部变量i，本操作为赋值为0  400535:83 45 fc 01          addl   $0x1,-0x4(%rbp) # i + 1  400539:8b 45 fc             mov    -0x4(%rbp),%eax # 将i放入eax  40053c:89 c6                mov    %eax,%esi# 将eax复制给esi，作为printf的第一个参数  40053e:bf 04 06 40 00       mov    $0x400604,%edi  400543:b8 00 00 00 00       mov    $0x0,%eax  400548:e8 b3 fe ff ff       callq  400400 &lt;printf@plt&gt;  40054d:c7 45 fc 00 00 00 00 movl   $0x0,-0x4(%rbp)## -0x4(%rbp) 是局部变量i，本操作为赋值为0  400554:8b 45 fc             mov    -0x4(%rbp),%eax## i赋值给eax  400557:8d 50 01             lea    0x1(%rax),%edx## 取rax的值加一（注意：rax本身并没有+1)，并赋值给edx  40055a:89 55 fc             mov    %edx,-0x4(%rbp)## 将edx赋值给局部变量i  40055d:89 c6                mov    %eax,%esi## 注意这里的eax并没有进行+1操作，所以值自赋值为0后并未改变，作为printf的第一个参数  40055f:bf 0e 06 40 00       mov    $0x40060e,%edi  400564:b8 00 00 00 00       mov    $0x0,%eax  400569:e8 92 fe ff ff       callq  400400 &lt;printf@plt&gt;  40056e:b8 00 00 00 00       mov    $0x0,%eax  400573:c9                   leaveq   400574:c3                   retq     400575:66 2e 0f 1f 84 00 00 nopw   %cs:0x0(%rax,%rax,1)  40057c:00 00 00   40057f:90                   nop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="分析-i"><a href="#分析-i" class="headerlink" title="分析++i"></a>分析++i</h3><p>主要分析一下C代码</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">++i;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>汇编如下所示：</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">40052e:c7 45 fc 00 00 00 00 movl   $0x0,-0x4(%rbp) # -0x4(%rbp) 是局部变量i，本操作为赋值为0 400535:83 45 fc 01          addl   $0x1,-0x4(%rbp) # i + 1 400539:8b 45 fc             mov    -0x4(%rbp),%eax # 将i放入eax 40053c:89 c6                mov    %eax,%esi# 将eax复制给esi，作为printf的第一个参数 40053e:bf 04 06 40 00       mov    $0x400604,%edi 400543:b8 00 00 00 00       mov    $0x0,%eax 400548:e8 b3 fe ff ff       callq  400400 &lt;printf@plt&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>++i正如字面的意思一样，先加后用！</strong></p><p>其加一汇编操作，均在<code>-0x4(%rbp)</code>进行，加一操作为<code>addl   $0x1,-0x4(%rbp)</code>，<strong>因此++i直接造成的结果就是i的改变。</strong></p><h3 id="分析i"><a href="#分析i" class="headerlink" title="分析i++"></a>分析i++</h3><p>C代码如下</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">i<span class="token operator">++</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>汇编如下所示：</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">40054d:c7 45 fc 00 00 00 00 movl   $0x0,-0x4(%rbp)## -0x4(%rbp) 是局部变量i，本操作为赋值为0400554:8b 45 fc             mov    -0x4(%rbp),%eax## i赋值给eax400557:8d 50 01             lea    0x1(%rax),%edx## 取rax的值加一（注意：rax本身并没有+1)，并赋值给edx40055a:89 55 fc             mov    %edx,-0x4(%rbp)## 将edx赋值给局部变量i40055d:89 c6                mov    %eax,%esi## 注意这里的eax并没有进行+1操作，所以值自赋值为0后并未改变，作为printf的第一个参数40055f:bf 0e 06 40 00       mov    $0x40060e,%edi400564:b8 00 00 00 00       mov    $0x0,%eax400569:e8 92 fe ff ff       callq  400400 &lt;printf@plt&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>i++正如字面的意思一样，先用后加！</strong></p><p>其加一汇编操作，在寄存器<code>eax</code>的值的基础上进行，加一操作为<code>lea    0x1(%rax),%edx；mov    %edx,-0x4(%rbp)</code>。</p><p>我们可以如下理解i++， 拆分为两句：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">i<span class="token operator">++</span> <span class="token operator">--</span><span class="token operator">></span> i<span class="token punctuation">;</span>i <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>i++</code>相当于：先使用<code>i</code>，在对<code>i</code>进行加一操作。</p><ul><li><p>先使用i：操作为将i的值存储在eax以便在后面使用，<code>eax</code>代表了<code>i++</code>这条语句的结果</p></li><li><p>对i进行加一操作：<code>lea    0x1(%rax),%edx；mov    %edx,-0x4(%rbp)</code>，加一操作并不影响eax寄存器。 </p></li></ul><p>因此<code>i++</code>的结果是<code>i</code>，使用的方法是<code>eax寄存器</code>。只不过在使用完<code>i</code>，会有一个加一的操作而已。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>++i，先加后用！</strong></p><p><strong>i++，先用后加！</strong></p><p>出现<code>i++</code>，<code>++i</code>这样语句的目的可能在于减少语句操作吧。通过上述字面理解，其实是最快的。</p><h2 id="i-i-6？？？"><a href="#i-i-6？？？" class="headerlink" title="(i++)+(++i)=6？？？"></a>(i++)+(++i)=6？？？</h2><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>使用如下代码进行分析</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">i &#x3D; 1;printf(&quot;i &#x3D; 1,(i++)+(++i) &#x3D; %d\n&quot;, (i++)+(++i));i &#x3D; 1;printf(&quot;i &#x3D; 1,(++i)+(++i) &#x3D; %d\n&quot;, (++i)+(++i));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="分析-i-i"><a href="#分析-i-i" class="headerlink" title="分析(i++)+(++i)"></a>分析(i++)+(++i)</h3><p>首先我们先进行一个简单一些的分析，<code>i = 1;(i++)+(++i)</code> 的结果是多少呢？</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm"># (i++)+(++i)# i &#x3D; 140056e:c7 45 fc 01 00 00 00 movl   $0x1,-0x4(%rbp)## -0x4(%rbp) 就是局部变量i，本操作为赋值为1,i &#x3D; 1# i++400575:8b 45 fc             mov    -0x4(%rbp),%eax## eax &#x3D; i &#x3D; 1400578:8d 50 01             lea    0x1(%rax),%edx## 取rax的值加一，赋值给edx40057b:89 55 fc             mov    %edx,-0x4(%rbp)## i &#x3D; edx, 此时i &#x3D; 2# ++i40057e:83 45 fc 01          addl   $0x1,-0x4(%rbp)## i+ 1 &#x3D; i,此时i &#x3D; 3# $1 + $2400582:8b 55 fc             mov    -0x4(%rbp),%edx## i的值赋给edx，也就是3400585:01 d0                add    %edx,%eax## 执行eax + edx &#x3D; eax 也就是1 + 3 &#x3D; 4400587:89 c6                mov    %eax,%esi## eax赋给esi，作为printf的第一个参数，也就是4400589:bf 74 06 40 00       mov    $0x400674,%edi40058e:b8 00 00 00 00       mov    $0x0,%eax400593:e8 68 fe ff ff       callq  400400 &lt;printf@plt&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过第二节的分析，我们知道，其实<code>(i++)+(++i) </code>的可以看做<code>(i_1 + (++i_2))</code>（<code>i_1</code>是因为此时<code>i_1</code>的值是eax的值，<code>i_1</code> 不等同于<code>i_2</code>，并不随<code>i</code>的值变化）， <del>再由C语言中表达式的计算是由右到左，所以会先计算<code>++i</code>，然后是</del>再相加。那么结果应该是1 + 2 = 3。</p><p>但是，实际结果却是4.为什么呢？</p><p>原因就是在进行<code>++i</code>的时候，虽然后续用的是<code>eax</code>的值，但是这句话（第5行）随后进行的操作改变了<code>-0x4(%rbp)</code>的值（第6、7行）。其本意是<code>-0x4(%rbp)+1</code>，但是此时<code>-0x4(%rbp)</code>的值已经被<code>i++</code>修改过了，为2，所以<code>++i</code>的结果就成为了3。最终两式一加，结果为4.</p><h3 id="分析-i-i-1"><a href="#分析-i-i-1" class="headerlink" title="分析(++i)+(++i)"></a>分析(++i)+(++i)</h3><p>下面我们分析<code>(++i)+(++i) = 6？</code></p><p>汇编代码如下所示：</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm"># (++i)+(++i)# i &#x3D; 1400598:c7 45 fc 01 00 00 00 movl   $0x1,-0x4(%rbp)# -0x4(%rbp) &#x3D; i &#x3D; 1#(++i)40059f:83 45 fc 01          addl   $0x1,-0x4(%rbp)# -0x4(%rbp) &#x3D; i &#x3D; 2#(++i)4005a3:83 45 fc 01          addl   $0x1,-0x4(%rbp)# -0x4(%rbp) &#x3D; i &#x3D; 3# $1 + $24005a7:8b 45 fc             mov    -0x4(%rbp),%eax# -0x4(%rbp)赋值给eax， eax &#x3D; 34005aa:01 c0                add    %eax,%eax# eax + eax &#x3D; 64005ac:89 c6                mov    %eax,%esi4005ae:bf 8c 06 40 00       mov    $0x40068c,%edi4005b3:b8 00 00 00 00       mov    $0x0,%eax4005b8:e8 43 fe ff ff       callq  400400 &lt;printf@plt&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>经过上一小节的分析，其实这里已经非常简单了，因为两次<code>++i</code>不断的改变<code>-0x4(%rbp)</code>的值，使得<code>-0x4(%rbp)</code>在使用时变成了3，最终两式相加为6.</p><h3 id="练手题目"><a href="#练手题目" class="headerlink" title="练手题目"></a>练手题目</h3><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">i &#x3D; 1;printf(&quot;i &#x3D; 1,(++i)+(i++) &#x3D; %d\n&quot;, (++i)+(i++));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">400598:c7 45 fc 01 00 00 00 movl   $0x1,-0x4(%rbp)40059f:83 45 fc 01          addl   $0x1,-0x4(%rbp)4005a3:8b 45 fc             mov    -0x4(%rbp),%eax4005a6:8d 50 01             lea    0x1(%rax),%edx4005a9:89 55 fc             mov    %edx,-0x4(%rbp)4005ac:8b 55 fc             mov    -0x4(%rbp),%edx4005af:01 d0                add    %edx,%eax4005b1:89 c6                mov    %eax,%esi4005b3:bf ac 06 40 00       mov    $0x4006ac,%edi4005b8:b8 00 00 00 00       mov    $0x0,%eax4005bd:e8 3e fe ff ff       callq  400400 &lt;printf@plt&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>他的结果是5，通过上述分析，你算对了吗？</p><p>关键提示：</p><ul><li><del>C语言中运行由右至左，所以先算<code>i++</code>，再算<code>++i</code></del></li><li><code>i++</code>和<code>++i</code>的运算过程改变了<code>-0x4(%rbp)</code>的值，所以出现了非预期的结果。</li></ul><h2 id="未定义行为"><a href="#未定义行为" class="headerlink" title="未定义行为"></a>未定义行为</h2><p>虽然这有点复杂，感觉确定性非常的不高。但是不用担心，在C语言的编译过程中，会警告我们，这样的语句中i没有定义。如果你发现这样的问题后，就需要注意了。</p><p><img src="/2021/07/26/C%E8%AF%AD%E8%A8%80%E5%9B%9E%E5%A4%B4%E7%9C%8B--%E5%8F%8C%E8%83%9E%E8%83%8Ei++%E5%92%8C++i%E7%9A%84%E6%95%85%E4%BA%8B/image-20210726111037526.png" alt="image-20210726111037526"></p><p>下面文章中对这个问题进行了解释，不再赘述。</p><blockquote><p>i＝1，为什么 (++i)+(++i)＝6？ - CWKSC的回答 - 知乎 <a href="https://www.zhihu.com/question/347864795/answer/836263029">https://www.zhihu.com/question/347864795/answer/836263029</a></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>从汇编角度理解++i和i++，可以更好的得出一些奇奇怪怪的语句的结果，让我们更好的理解C语言，理解编译器。</li><li>一定不建议写这样的语句！一定不建议写这样的语句！一定不建议写这样的语句！请用<code>i += 1</code>这样代替。多写一个字符而已。如果一定要写i++或++i，请将其单独为一个语句，不要进行组合！不要进行组合！不要进行组合！这样，你好我好大家好，不然当某一天你维护的代码出现灵异事件时，就只有祷告了。</li></ul><p>====</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">return</span> i<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">return</span> i<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> ret<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> c <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span> d <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>d <span class="token operator">=</span> a <span class="token operator">*</span> b <span class="token operator">+</span> c <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">0000000000400526 &lt;_Z1fv&gt;:  400526:55                   push   %rbp  400527:48 89 e5             mov    %rsp,%rbp  40052a:c7 45 fc 01 00 00 00 movl   $0x1,-0x4(%rbp)  400531:8b 45 fc             mov    -0x4(%rbp),%eax  400534:8d 50 01             lea    0x1(%rax),%edx  400537:89 55 fc             mov    %edx,-0x4(%rbp)  40053a:5d                   pop    %rbp  40053b:c3                   retq   000000000040053c &lt;_Z1gv&gt;:  40053c:55                   push   %rbp  40053d:48 89 e5             mov    %rsp,%rbp  400540:c7 45 fc 01 00 00 00 movl   $0x1,-0x4(%rbp)  400547:8b 45 fc             mov    -0x4(%rbp),%eax  40054a:8d 50 01             lea    0x1(%rax),%edx  40054d:89 55 fc             mov    %edx,-0x4(%rbp)  400550:5d                   pop    %rbp  400551:c3                   retq   0000000000400552 &lt;main&gt;:  400552:55                   push   %rbp  400553:48 89 e5             mov    %rsp,%rbp  400556:53                   push   %rbx  400557:48 83 ec 28          sub    $0x28,%rsp  40055b:e8 c6 ff ff ff       callq  400526 &lt;_Z1fv&gt;#f()  400560:89 c3                mov    %eax,%ebx  400562:e8 d5 ff ff ff       callq  40053c &lt;_Z1gv&gt;#g()  400567:01 d8                add    %ebx,%eax  400569:89 45 dc             mov    %eax,-0x24(%rbp)  40056c:8b 45 dc             mov    -0x24(%rbp),%eax  40056f:89 c6                mov    %eax,%esi  400571:bf 74 06 40 00       mov    $0x400674,%edi  400576:b8 00 00 00 00       mov    $0x0,%eax  40057b:e8 80 fe ff ff       callq  400400 &lt;printf@plt&gt;  400580:e8 a1 ff ff ff       callq  400526 &lt;_Z1fv&gt;#f()  400585:89 c3                mov    %eax,%ebx  400587:e8 b0 ff ff ff       callq  40053c &lt;_Z1gv&gt;#g()  40058c:01 d8                add    %ebx,%eax  40058e:89 c6                mov    %eax,%esi  400590:bf 74 06 40 00       mov    $0x400674,%edi  400595:b8 00 00 00 00       mov    $0x0,%eax  40059a:e8 61 fe ff ff       callq  400400 &lt;printf@plt&gt;  40059f:c7 45 e0 01 00 00 00 movl   $0x1,-0x20(%rbp) #a  4005a6:c7 45 e4 02 00 00 00 movl   $0x2,-0x1c(%rbp)#b  4005ad:c7 45 e8 03 00 00 00 movl   $0x3,-0x18(%rbp)#c  4005b4:c7 45 ec 04 00 00 00 movl   $0x4,-0x14(%rbp) #d  4005bb:8b 45 e0             mov    -0x20(%rbp),%eax  4005be:0f af 45 e4          imul   -0x1c(%rbp),%eax # a * b  4005c2:8b 55 e8             mov    -0x18(%rbp),%edx   4005c5:01 d2                add    %edx,%edx# c + c &#x3D; c*2  4005c7:01 d0                add    %edx,%eax# 相加  4005c9:89 45 ec             mov    %eax,-0x14(%rbp)  4005cc:8b 45 ec             mov    -0x14(%rbp),%eax  4005cf:89 c6                mov    %eax,%esi  4005d1:bf 74 06 40 00       mov    $0x400674,%edi  4005d6:b8 00 00 00 00       mov    $0x0,%eax  4005db:e8 20 fe ff ff       callq  400400 &lt;printf@plt&gt;  4005e0:b8 00 00 00 00       mov    $0x0,%eax  4005e5:48 83 c4 28          add    $0x28,%rsp  4005e9:5b                   pop    %rbx  4005ea:5d                   pop    %rbp  4005eb:c3                   retq     4005ec:0f 1f 40 00          nopl   0x0(%rax)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从汇编代码可以看出，实际上<code>f()+g()</code> 和<code>a * b + c *2</code>的顺序均为从左向右。</p><p>实际上，之前自己记忆中一直是以下这句：</p><ul><li><strong>复合赋值运算的优先级符合C语言运算符的优先级表，结合方向为从右到左。</strong> C语言中可以进行连续赋值,如a=b=c=1,“=”运算符是从右至左结合</li><li> <strong>函数参数：</strong>主要是函数参数入栈的方式造成有，入栈从右向左，运算也就从右向左。 i=1; printf(“%d%d”,i,i++);//输出2 1</li></ul>]]></content>
    
    
    <summary type="html">C语言回头看–诡异的i++和++i
C语言中的i++和++i使用非常的方便，简单明了。但是很多人在学习C语言的过程中，对这两个语句还是存在恐惧，因为这两条语句会引起不必要的麻烦。例如：到底是先用再加，还是先加再用？ 同时在一些程序语句中也会出现一些令人意想不到的结果，例如i=1,((++i)+(++i))=6的情况，非常的诡异。

因此本文针对这个问题，深入到汇编层面，理解双胞胎i++和++i的故事。相信通过本文，你能够更加深刻的理解C语言中的自加自减等操作。

例子介绍
本文所用程序
C语言文件如下所示，逻辑为：分别输出i++和++i的结果。

#include &lt;stdio.h&gt;

int</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://dianwoshishi.github.io/2021/07/24/Linux%E4%B8%8B%E6%89%8B%E6%92%95c++-%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/"/>
    <id>http://dianwoshishi.github.io/2021/07/24/Linux%E4%B8%8B%E6%89%8B%E6%92%95c++-%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/</id>
    <published>2021-07-23T16:20:01.189Z</published>
    <updated>2021-07-24T03:19:22.215Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux下从汇编手撕c-值传递和引用传递"><a href="#Linux下从汇编手撕c-值传递和引用传递" class="headerlink" title="Linux下从汇编手撕c++-值传递和引用传递"></a>Linux下从汇编手撕c++-值传递和引用传递</h1><h2 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h2><p><code>main.c</code></p><p>主要分为两个部分，每个部分使用一个display函数，函数内使得传入的参数自加1，然后打印到标准输出上。不同的地方在于，display1使用了值传递，display2使用了引用传递</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;stdio.h&gt;void display1(int num)&#123; &#x2F;&#x2F;int num，属于值传递num++;printf(&quot;display1: %d\n&quot;, num);&#125;void display2(int &amp; num)&#123; &#x2F;&#x2F;int &amp; num ，属于引用传递num++;printf(&quot;display2: %d\n&quot;, num);&#125;int main()&#123;int num1 &#x3D; 0, num2 &#x3D; 0;display1(num1);printf(&quot;num1:%d\n&quot;, num1);printf(&quot;--------------------\n&quot;);display2(num2);printf(&quot;num2:%d\n&quot;, num2);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>makefile</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">OBJ&#x3D;reference$(OBJ):g++ main.c -o $@clean:-rm -rf $(OBJ)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在ubuntu中使用<code>make</code>命令进行编译并运行，结果如下图所示。</p><p><img src="/2021/07/24/Linux%E4%B8%8B%E6%89%8B%E6%92%95c++-%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/image-20210724002053895.png" alt="image-20210724002053895"></p><p>通过上述结果我们可以看出，虽然仅仅一个<code>&amp;</code>符号的差异，但通过参数传递和通过值传递获得的<strong>结果不一样</strong>。</p><ul><li><p>值传递中的num虽然进行了自加操作(输出display:1可以看出)，但是<strong>并没有影响</strong>到main函数中的num1（num1:0可以看出)</p></li><li><p>但是引用传递中的num进行了自加1(输出display:1可以看出)，并且<strong>影响到</strong>了main函数中的num2(num2:1可以看出).</p></li></ul><h2 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h2><p>是什么原因造成了仅仅一个<code>&amp;</code>符号的差异，导致函数内值传递和引用传递的差别呢？</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p><code>objdump -d ./reference &gt; objdump.txt</code></p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">.&#x2F;reference:     file format elf64-x86-6400000000004005d6 &lt;_Z8display1i&gt;:  4005d6:55                   push   %rbp  4005d7:48 89 e5             mov    %rsp,%rbp  4005da:48 83 ec 10          sub    $0x10,%rsp  4005de:89 7d fc             mov    %edi,-0x4(%rbp) #将值取出到%rbp-0x4  4005e1:83 45 fc 01          addl   $0x1,-0x4(%rbp)# +1运算  4005e5:8b 45 fc             mov    -0x4(%rbp),%eax#写回%rbp-0x4, 仍然是局部变量，生命周期在函数内  4005e8:89 c6                mov    %eax,%esi  4005ea:bf 44 07 40 00       mov    $0x400744,%edi  4005ef:b8 00 00 00 00       mov    $0x0,%eax  4005f4:e8 b7 fe ff ff       callq  4004b0 &lt;printf@plt&gt;  4005f9:90                   nop  4005fa:c9                   leaveq   4005fb:c3                   retq   00000000004005fc &lt;_Z8display2Ri&gt;:  4005fc:55                   push   %rbp  4005fd:48 89 e5             mov    %rsp,%rbp  400600:48 83 ec 10          sub    $0x10,%rsp  400604:48 89 7d f8          mov    %rdi,-0x8(%rbp)#将值取出到%rbp-0x8， 注意此时%rdi为地址  400608:48 8b 45 f8          mov    -0x8(%rbp),%rax  40060c:8b 00                mov    (%rax),%eax  40060e:8d 50 01             lea    0x1(%rax),%edx  #加一  400611:48 8b 45 f8          mov    -0x8(%rbp),%rax  400615:89 10                mov    %edx,(%rax) # 将结果放入原地址所指的内存当中，  400617:48 8b 45 f8          mov    -0x8(%rbp),%rax  40061b:8b 00                mov    (%rax),%eax  40061d:89 c6                mov    %eax,%esi  40061f:bf 52 07 40 00       mov    $0x400752,%edi  400624:b8 00 00 00 00       mov    $0x0,%eax  400629:e8 82 fe ff ff       callq  4004b0 &lt;printf@plt&gt;  40062e:90                   nop  40062f:c9                   leaveq   400630:c3                   retq   0000000000400631 &lt;main&gt;:  400631:55                   push   %rbp  400632:48 89 e5             mov    %rsp,%rbp  400635:48 83 ec 10          sub    $0x10,%rsp  400639:64 48 8b 04 25 28 00 mov    %fs:0x28,%rax  400640:00 00   400642:48 89 45 f8          mov    %rax,-0x8(%rbp)  400646:31 c0                xor    %eax,%eax  400648:c7 45 f4 00 00 00 00 movl   $0x0,-0xc(%rbp)  40064f:c7 45 f0 00 00 00 00 movl   $0x0,-0x10(%rbp)  400656:8b 45 f4             mov    -0xc(%rbp),%eax # 将%rbp-0xc的值放入%eax，相当于复制了一份  400659:89 c7                mov    %eax,%edi  40065b:e8 76 ff ff ff       callq  4005d6 &lt;_Z8display1i&gt;  400660:8b 45 f4             mov    -0xc(%rbp),%eax  400663:89 c6                mov    %eax,%esi  400665:bf 60 07 40 00       mov    $0x400760,%edi  40066a:b8 00 00 00 00       mov    $0x0,%eax  40066f:e8 3c fe ff ff       callq  4004b0 &lt;printf@plt&gt;  400674:bf 69 07 40 00       mov    $0x400769,%edi  400679:e8 12 fe ff ff       callq  400490 &lt;puts@plt&gt;  40067e:48 8d 45 f0          lea    -0x10(%rbp),%rax # 将%rbp-0xc的地址放入%eax，想到与对原地址进行操作  400682:48 89 c7             mov    %rax,%rdi  400685:e8 72 ff ff ff       callq  4005fc &lt;_Z8display2Ri&gt;  40068a:8b 45 f0             mov    -0x10(%rbp),%eax  40068d:89 c6                mov    %eax,%esi  40068f:bf 7e 07 40 00       mov    $0x40077e,%edi  400694:b8 00 00 00 00       mov    $0x0,%eax  400699:e8 12 fe ff ff       callq  4004b0 &lt;printf@plt&gt;  40069e:b8 00 00 00 00       mov    $0x0,%eax  4006a3:48 8b 55 f8          mov    -0x8(%rbp),%rdx  4006a7:64 48 33 14 25 28 00 xor    %fs:0x28,%rdx  4006ae:00 00   4006b0:74 05                je     4006b7 &lt;main+0x86&gt;  4006b2:e8 e9 fd ff ff       callq  4004a0 &lt;__stack_chk_fail@plt&gt;  4006b7:c9                   leaveq   4006b8:c3                   retq     4006b9:0f 1f 80 00 00 00 00 nopl   0x0(%rax)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过上述汇编代码（相关关键步骤已经使用注释进行了说明）。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">display1(num1);display2(num2);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">400656:8b 45 f4             mov    -0xc(%rbp),%eax # 注意mov操作！！将%rbp-0xc的值（也就是局部变量num1）放入%eax，相当于复制了一份400659:89 c7                mov    %eax,%edi40065b:e8 76 ff ff ff       callq  4005d6 &lt;_Z8display1i&gt;  40067e:48 8d 45 f0          lea    -0x10(%rbp),%rax # 注意lea 操作！！将%rbp-0xc（也就是局部变量num2）的地址放入%eax，想当于对原地址进行操作400682:48 89 c7             mov    %rax,%rdi400685:e8 72 ff ff ff       callq  4005fc &lt;_Z8display2Ri&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出：</p><ul><li><p>对于值传递，使用<code>mov</code>指令，相当于<strong>复制</strong>了一份；</p></li><li><p>对于引用，使用<code>lea</code>指令，得到了地址，随后的操作都在<strong>地址上</strong>进行，相当于直接对该地址的数进行操作。</p></li></ul><p>因此，我们知道，虽然传递的都是传递的一个变量名，但display1使用的值传递，display2使用的是引用传递：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">display1(num1);&#x2F;&#x2F;虽然进行了自加1，但是是对num1的副本进行的操作，作用范围在display函数内display2(num2);&#x2F;&#x2F;使用引用传递，相当于指针操作，作用范围在main函数当中。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><p>当使用值传递时，在函数内对参数的操作，参数作用范围只在函数内，跳出函数后该是啥还是啥，在原函数(这里是main)里就是进入函数前的状态。因为值传递方式，在函数中只改变的是值的副本。</p></li><li><p>在使用引用传递时，引用的本质使用的是指针。因此在函数中的操作，都会直接作用于该地址的值。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过对值传递和引用传递的汇编代码的分析，我们清晰的看出值传递本是上是传递了一个原值的副本，其变化并不影响调用函数的值；引用传递的本质是指针，其变化，直接作用于调用函数的值。</p>]]></content>
    
    
    <summary type="html">Linux下从汇编手撕c++-值传递和引用传递
示例程序
main.c

主要分为两个部分，每个部分使用一个display函数，函数内使得传入的参数自加1，然后打印到标准输出上。不同的地方在于，display1使用了值传递，display2使用了引用传递

#include &lt;stdio.h&gt;

void display1(int num){ //int num，属于值传递
	num++;
	printf(&quot;display1: %d\n&quot;, num);
}

void display2(int &amp; num){ //int &amp; num ，属于引用传递
	num++;
	printf(&quot;displ</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://dianwoshishi.github.io/2021/07/21/%E6%89%93%E5%8D%B0%E6%9C%BA%E8%BD%AF%E4%BB%B6%E4%B8%AD%E5%AD%98%E5%9C%A816%E5%B9%B4%E7%9A%84%E6%BC%8F%E6%B4%9E%E5%8F%AF%E8%AE%A9%E9%BB%91%E5%AE%A2%E8%8E%B7%E5%8F%96%E7%AE%A1%E7%90%86%E6%9D%83%E9%99%90/"/>
    <id>http://dianwoshishi.github.io/2021/07/21/%E6%89%93%E5%8D%B0%E6%9C%BA%E8%BD%AF%E4%BB%B6%E4%B8%AD%E5%AD%98%E5%9C%A816%E5%B9%B4%E7%9A%84%E6%BC%8F%E6%B4%9E%E5%8F%AF%E8%AE%A9%E9%BB%91%E5%AE%A2%E8%8E%B7%E5%8F%96%E7%AE%A1%E7%90%86%E6%9D%83%E9%99%90/</id>
    <published>2021-07-21T00:25:34.587Z</published>
    <updated>2021-07-21T00:41:13.197Z</updated>
    
    <content type="html"><![CDATA[<h1 id="打印机软件中存在16年的漏洞可让黑客获取管理权限"><a href="#打印机软件中存在16年的漏洞可让黑客获取管理权限" class="headerlink" title="打印机软件中存在16年的漏洞可让黑客获取管理权限"></a>打印机软件中存在16年的漏洞可让黑客获取管理权限</h1><p><img src="https://www.cybersafe.news/wp-content/uploads/2021/07/printer-800x400.jpg" alt="img"></p><h2 id="速揽"><a href="#速揽" class="headerlink" title="速揽"></a>速揽</h2><p>在惠普、施乐和三星打印机驱动程序中发现的一个存在16年的安全漏洞，允许攻击者在使用有漏洞的驱动程序软件的系统上获得管理权限。这个被称为CVE-2021-3438的安全漏洞是特定型号打印机的SSPORT.SYS驱动程序中的缓冲区溢出，可能导致用户权限的本地升级。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>在惠普、施乐和三星打印机驱动程序中发现的一个存在16年的安全漏洞，允许攻击者在使用有漏洞的驱动程序软件的系统上获得管理权限。这个被称为CVE-2021-3438的安全漏洞是特定型号打印机的SSPORT.SYS驱动程序中的缓冲区溢出，可能导致用户权限的本地升级。</p><p>这个高危漏洞自2005年起就存在于打印机软件中，影响到全球数以亿计的设备和数百万的用户。</p><p>SentinelOne的研究人员发现，这个有问题的驱动程序会自动与打印机软件一起安装，并在每次系统重启后被Windows加载。这使得它成为提升权限的完美目标，因为即使在打印机没有连接到目标设备时，也很容易滥用这个漏洞。要成功利用这个漏洞，需要本地用户访问，这意味着威胁者将需要首先在目标设备上获得一个立足点。一旦他们得到这一点，他们就可以滥用这个安全漏洞，在不需要用户交互的情况下，在低复杂度的攻击中提升权限。</p><p>研究人员表示，在成功利用驱动漏洞后，可能会让攻击者有可能安装程序，查看、改变、加密或删除数据，或创建具有完全用户权限的新账户。</p><p>由于没有证据表明这一漏洞在现实中被利用但单目前有数以亿计的企业和用户存在漏洞，攻击者会寻找那些采取适当防护措施的人。惠普、施乐和三星的企业和家庭用户尽快应用这两家供应商提供的补丁。</p>]]></content>
    
    
    <summary type="html">打印机软件中存在16年的漏洞可让黑客获取管理权限


速揽
在惠普、施乐和三星打印机驱动程序中发现的一个存在16年的安全漏洞，允许攻击者在使用有漏洞的驱动程序软件的系统上获得管理权限。这个被称为CVE-2021-3438的安全漏洞是特定型号打印机的SSPORT.SYS驱动程序中的缓冲区溢出，可能导致用户权限的本地升级。

正文
在惠普、施乐和三星打印机驱动程序中发现的一个存在16年的安全漏洞，允许攻击者在使用有漏洞的驱动程序软件的系统上获得管理权限。这个被称为CVE-2021-3438的安全漏洞是特定型号打印机的SSPORT.SYS驱动程序中的缓冲区溢出，可能导致用户权限的本地升级。

这个高</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://dianwoshishi.github.io/2021/07/20/%E4%BB%8Ehello%20world%E5%BC%80%E5%A7%8B%EF%BC%8C%E6%8B%86%E8%A7%A3%E5%87%BD%E6%95%B0%E6%A0%88%E7%BB%93%E6%9E%84/"/>
    <id>http://dianwoshishi.github.io/2021/07/20/%E4%BB%8Ehello%20world%E5%BC%80%E5%A7%8B%EF%BC%8C%E6%8B%86%E8%A7%A3%E5%87%BD%E6%95%B0%E6%A0%88%E7%BB%93%E6%9E%84/</id>
    <published>2021-07-20T15:52:32.549Z</published>
    <updated>2021-07-20T17:00:45.928Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从hello-world开始，拆解函数栈结构"><a href="#从hello-world开始，拆解函数栈结构" class="headerlink" title="从hello world开始，拆解函数栈结构"></a>从hello world开始，拆解函数栈结构</h1><h2 id="第一个程序helloworld"><a href="#第一个程序helloworld" class="headerlink" title="第一个程序helloworld"></a>第一个程序helloworld</h2><h3 id="编写程序"><a href="#编写程序" class="headerlink" title="编写程序"></a>编写程序</h3><p>首先我们有如下程序：<code>main.c</code></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//main.c</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">test_stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">25</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">puts</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">test_stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述程序实现的功能很简单，就是从<code>scanf</code>输入一个字符串，赋值到<code>name</code>，并且通过<code>puts</code>打印。</p><p>是不是很简单！</p><h3 id="程序编译makefile"><a href="#程序编译makefile" class="headerlink" title="程序编译makefile"></a>程序编译makefile</h3><p>为了便于说明，我们使用makefile文件进行编译。创建文件名为<code>makefile</code>的文件，内容如下：</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token comment"># makefile</span>OBJ<span class="token operator">=</span>stack<span class="token symbol"><span class="token variable">$</span>(OBJ)</span><span class="token punctuation">:</span>gcc main.c -o <span class="token variable">$@</span><span class="token symbol">clean</span><span class="token punctuation">:</span>-rm -rf <span class="token variable">$</span><span class="token punctuation">(</span>OBJ<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们生成的文件名为<code>stack</code>，这里你可以改为你喜欢的任意名称。</p><p>使用<code>make</code>命令进行编译，会生成最终文件。运行后就可以看见输出。</p><h2 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h2><p>C语言中函数栈是如何组织的呢？都有哪些元素呢？</p><h2 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h2><p>首先，我们通过汇编代码，理解上述C语言代码，我们能更加清晰的看出一个<code>test_stack</code>函数到底干了什么。相关内容我们在其后直接进行了注释。</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm"># objdump -d .&#x2F;stack.&#x2F;stack:     file format elf64-x86-6400000000004005f6 &lt;test_stack&gt;:  4005f6:55                   push   %rbp  4005f7:48 89 e5             mov    %rsp,%rbp  4005fa:48 83 ec 30          sub    $0x30,%rsp #栈上开辟了0x30&#x3D;48的空间，注意我们的局部变量只需要25的空间  4005fe:64 48 8b 04 25 28 00 mov    %fs:0x28,%rax # 从%fs:0x28取了一个值，放在了栈底之上，这就是canary，一种栈溢出的保护措施  400605:00 00   400607:48 89 45 f8          mov    %rax,-0x8(%rbp)  40060b:31 c0                xor    %eax,%eax  40060d:48 c7 45 d0 00 00 00 movq   $0x0,-0x30(%rbp) #char name[25] &#x3D; &#123;0&#125;;  400614:00   400615:48 c7 45 d8 00 00 00 movq   $0x0,-0x28(%rbp)  40061c:00   40061d:48 c7 45 e0 00 00 00 movq   $0x0,-0x20(%rbp)  400624:00   400625:c6 45 e8 00          movb   $0x0,-0x18(%rbp)  400629:48 8d 45 d0          lea    -0x30(%rbp),%rax  40062d:48 89 c6             mov    %rax,%rsi  400630:bf 04 07 40 00       mov    $0x400704,%edi #’%s&#39;  400635:b8 00 00 00 00       mov    $0x0,%eax  40063a:e8 a1 fe ff ff       callq  4004e0 &lt;__isoc99_scanf@plt&gt;  40063f:48 8d 45 d0          lea    -0x30(%rbp),%rax  400643:48 89 c7             mov    %rax,%rdi  400646:e8 65 fe ff ff       callq  4004b0 &lt;puts@plt&gt;  40064b:b8 00 00 00 00       mov    $0x0,%eax  400650:48 8b 55 f8          mov    -0x8(%rbp),%rdx  400654:64 48 33 14 25 28 00 xor    %fs:0x28,%rdx #检查canary  40065b:00 00   40065d:74 05                je     400664 &lt;test_stack+0x6e&gt;  40065f:e8 5c fe ff ff       callq  4004c0 &lt;__stack_chk_fail@plt&gt;  400664:c9                   leaveq   400665:c3                   retq   0000000000400666 &lt;main&gt;:  400666:55                   push   %rbp  400667:48 89 e5             mov    %rsp,%rbp  40066a:b8 00 00 00 00       mov    $0x0,%eax  40066f:e8 82 ff ff ff       callq  4005f6 &lt;test_stack&gt;  400674:b8 00 00 00 00       mov    $0x0,%eax  400679:5d                   pop    %rbp  40067a:c3                   retq     40067b:0f 1f 44 00 00       nopl   0x0(%rax,%rax,1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主要进行了以下操作：</p><ul><li><strong>callq操作。</strong>我们需要注意一个隐含操作，就是上述第40行<code>callq  4005f6 &lt;test_stack&gt;</code>,这个操作隐含将下一条指令地址压栈，即0x400674</li><li><strong>开辟栈空间。</strong>开辟了大小为48的栈空间，这里注意，我们的局部变量name只需要25大小的空间</li><li><strong>canary值。</strong>从%fs:0x28取了一个值，放在了栈底之上，这就是canary，一种栈溢出的保护措施，最后对其检查</li><li><strong>初试化操作。</strong>使用3个<code>movq</code>和1个<code>movb</code>对name变量进行了初始化。name变量的起始地址为<code>$rbp-0x30$</code>即<code>$rsp$</code>栈顶</li><li><strong>赋值。</strong>使用<code>scanf</code>函数，对name变量进行了赋值</li></ul><p>其中，初始化，赋值通过汇编代码都很容易看出。下面我们通过gdb主要来看看栈结构吧。</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>使用gdb+pwngdb插件进行解释，如不清楚，可私信我或加我公众号。</p><h3 id="callq操作"><a href="#callq操作" class="headerlink" title="callq操作"></a>callq操作</h3><p>![image-20210721000901757](从hello world开始，拆解函数栈结构/image-20210721000901757.png)</p><p>在进行callq操作之前，rbp和rsp为同一地址，说明栈空间大小为0.</p><p>![image-20210721001254187](从hello world开始，拆解函数栈结构/image-20210721001254187.png)</p><p>注意箭头部分，当我们进入<code>test_stack</code>函数时，callq操作，进行了隐含操作，callq的下一条指令地址压栈，在这里我们可以看出，其内容为<code>0x400674</code>，与我们静态分析汇编代码一致。验证了callq操作对栈的影响。</p><h3 id="开辟栈空间"><a href="#开辟栈空间" class="headerlink" title="开辟栈空间"></a>开辟栈空间</h3><p>此操作中，注意rsp和rbp的变化。</p><ul><li>push指令，将栈底压栈。</li></ul><p>![image-20210721001715969](从hello world开始，拆解函数栈结构/image-20210721001715969.png)</p><ul><li>将栈底和栈顶地址设为相同（可通过栈底的上一条内容01：0008，恢复上一个栈底）。</li></ul><p>![image-20210721001827503](从hello world开始，拆解函数栈结构/image-20210721001827503.png)</p><ul><li>开辟栈空间，大小为0x30=48。</li></ul><p>![image-20210721002102212](从hello world开始，拆解函数栈结构/image-20210721002102212.png)</p><p>红框中<code>[00:0000-06:0030)</code>之间，为当前<code>test_stack</code>栈帧中的结构，大小为0x30=48字节。中间的数据为一些初始化函数执行过程中残留的栈数据，暂时不用管它。(s + buffer + canary)</p><p>rbp为test_stack函数的第一个push rbp的操作压入的栈底（saved ebp)</p><p>07:0038为test_stack函数执行完毕后的返回地址。(return address)</p><p>示意图如下：</p><p><img src="https://manybutfinite.com/img/stack/bufferCanary.png" alt="See the source image"></p><h3 id="canary值"><a href="#canary值" class="headerlink" title="canary值"></a>canary值</h3><p>如下图，我们继续执行两步，该函数在<code>fs:[0x28]</code>处取了一个值，然后放入了rbp-8的位置，即图中画线的位置，值为：0x92cb97cb6f51ae00，这个数就是我们所谓的canary，金丝雀。主要用来检测栈溢出。</p><p>![image-20210721003510355](从hello world开始，拆解函数栈结构/image-20210721003510355.png)</p><p>然后我们查看栈顶开始的48个字节，即栈的内容</p><p>![image-20210721004153415](从hello world开始，拆解函数栈结构/image-20210721004153415.png)</p><p>s: 0x7fffffffddd0:    （0x00000000    0x00000000    0x00000000    0x00000000<br>0x7fffffffdde0:    0x00000000    0x00000000    0x00）s表示我们局部变量填充的空间         </p><p>buffer: (000000    0x00000000<br>0x7fffffffddf0:    0x00400680    0x00000000)buffer    代表补齐8字节所占用的空间</p><p>canary: (0x6f51ae00    0x92cb97cb)canary 代表栈溢出检测指标。</p><p><img src="https://manybutfinite.com/img/stack/bufferCanary.png" alt="See the source image"></p><p>通过IDA pro验证我们的想法：</p><p>![image-20210721010044515](从hello world开始，拆解函数栈结构/image-20210721010044515.png)</p><h2 id="缓冲区溢出分析"><a href="#缓冲区溢出分析" class="headerlink" title="缓冲区溢出分析"></a>缓冲区溢出分析</h2><p>实际上我们花了大量的篇幅去讲栈的结构，其实目的就是这么一张图</p><p><img src="https://manybutfinite.com/img/stack/bufferCanary.png" alt="See the source image"></p><p>栈溢出其实就是使得字符串长度达到return address的位置，使得在函数执行完毕retn时，return address的地址弹出给rip寄存器，从而使得CPU按照rip寄存的内容执行下一条指令。这里面要非常清楚的就是栈的结构，栈空间的计算真正要做到”一字不差“！</p><p>当然了，这里的canary对栈进行了保护，是一个随机生成的数。当然还有很多办法来绕过甚至是猜出canary，实现栈溢出，这不在本篇文章的范畴之内，留给下一次机会吧。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对通过一个最简单的程序对栈的结构进行了静态和动态的分析，得出了一张刻画栈帧空间的图。对于栈的计算要十分的仔细，这样在pwn题中才能做到心中有数，一招制敌。</p>]]></content>
    
    
    <summary type="html">从hello world开始，拆解函数栈结构
第一个程序helloworld
编写程序
首先我们有如下程序：main.c

//main.c
#include&lt;stdio.h&gt;
int test_stack(){
	char name[25] = {0};
	scanf(&quot;%s&quot;, name);
	puts(name);
	return 0;
}
int main(){
	test_stack();
	return 0;
}

上述程序实现的功能很简单，就是从scanf输入一个字符串，赋值到name，并且通过puts打印。

是不是很简单！

程序编译makefile
为了便于说明，我们使用m</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://dianwoshishi.github.io/2021/07/19/%E4%BB%8Ehello%20world%E5%BC%80%E5%A7%8B%EF%BC%8C%E6%8B%86%E8%A7%A3%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E7%9A%84%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE/"/>
    <id>http://dianwoshishi.github.io/2021/07/19/%E4%BB%8Ehello%20world%E5%BC%80%E5%A7%8B%EF%BC%8C%E6%8B%86%E8%A7%A3%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E7%9A%84%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE/</id>
    <published>2021-07-19T08:02:03.219Z</published>
    <updated>2021-07-20T06:47:45.093Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从hello-world开始，拆解字符串常量的存储位置"><a href="#从hello-world开始，拆解字符串常量的存储位置" class="headerlink" title="从hello world开始，拆解字符串常量的存储位置"></a>从hello world开始，拆解字符串常量的存储位置</h1><h2 id="第一个程序helloworld"><a href="#第一个程序helloworld" class="headerlink" title="第一个程序helloworld"></a>第一个程序helloworld</h2><h3 id="编写程序"><a href="#编写程序" class="headerlink" title="编写程序"></a>编写程序</h3><p>首先我们有如下程序：<code>main.c</code></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//main.c</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hello world! %s\n"</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">char</span> <span class="token operator">*</span>g_pstr <span class="token operator">=</span> <span class="token string">"global_I'm a string\n"</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">char</span> <span class="token operator">*</span>pname <span class="token operator">=</span> <span class="token string">"III'm a stringI'm a stringII'm a stringI'm a stringII'm a stringI'm a stringII'm a stringI'm a stringII'm a stringI'm a stringII'm a stringI'm a stringII'm a stringI'm a stringII'm a stringI'm a stringII'm a stringI'm a stringII'm a stringI'm a stringI'm a stringI'm a string"</span><span class="token punctuation">;</span><span class="token function">puts</span><span class="token punctuation">(</span>pname<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">puts</span><span class="token punctuation">(</span>g_pstr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"local_string_I'm a string"</span><span class="token punctuation">;</span> <span class="token function">display</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述程序实现的功能很简单，就是输出三个字符串pname，g_pstr和name，为了便于说明，其中故意使用了一个函数调用<code>int display(char *)</code>。</p><p>函数的逻辑为，main函数–&gt; display()函数(一个参数)–&gt;printf函数(两个参数)。</p><p>是不是很简单！</p><h3 id="程序编译makefile"><a href="#程序编译makefile" class="headerlink" title="程序编译makefile"></a>程序编译makefile</h3><p>为了便于说明，我们使用makefile文件进行编译。创建文件名为<code>makefile</code>的文件，内容如下：</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token comment"># makefile</span>OBJ<span class="token operator">=</span>printf.main<span class="token symbol"><span class="token variable">$</span>(OBJ)</span><span class="token punctuation">:</span>gcc main.c -o <span class="token variable">$@</span><span class="token symbol">clean</span><span class="token punctuation">:</span>-rm <span class="token variable">$</span><span class="token punctuation">(</span>OBJ<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们生成的文件名为<code>printf.main</code>，这里你可以改为你喜欢的任意名称。</p><p>使用<code>make</code>命令进行编译，会生成最终文件。运行后就可以看见输出。</p><h2 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h2><p>我们想要知道字符串常量在程序运行中存储的位置</p><h2 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h2><p>我们通过命令<code>objdump -d ./printf.main</code>, 查看相应的汇编代码。如下所示，定位到关键步骤，关键步骤已经使用‘#’注释</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">.&#x2F;printf.main:     file format elf64-x86-6400000000004005d6 &lt;display&gt;:  4005d6:55                   push   %rbp  4005d7:48 89 e5             mov    %rsp,%rbp  4005da:48 83 ec 10          sub    $0x10,%rsp  4005de:48 89 7d f8          mov    %rdi,-0x8(%rbp)  4005e2:48 8b 45 f8          mov    -0x8(%rbp),%rax  4005e6:48 89 c6             mov    %rax,%rsi  4005e9:bf 48 07 40 00       mov    $0x400748,%edi  4005ee:b8 00 00 00 00       mov    $0x0,%eax  4005f3:e8 b8 fe ff ff       callq  4004b0 &lt;printf@plt&gt;  4005f8:90                   nop  4005f9:c9                   leaveq   4005fa:c3                   retq   00000000004005fb &lt;main&gt;:  4005fb:55                   push   %rbp  4005fc:48 89 e5             mov    %rsp,%rbp  4005ff:48 81 ec 20 01 00 00 sub    $0x120,%rsp  400606:64 48 8b 04 25 28 00 mov    %fs:0x28,%rax  40060d:00 00   40060f:48 89 45 f8          mov    %rax,-0x8(%rbp)  400613:31 c0                xor    %eax,%eax  400615:48 c7 85 e8 fe ff ff movq   $0x400770,-0x118(%rbp)# 0x400770作为pname的地址  40061c:70 07 40 00   400620:48 8b 85 e8 fe ff ff mov    -0x118(%rbp),%rax  400627:48 89 c7             mov    %rax,%rdi  40062a:e8 61 fe ff ff       callq  400490 &lt;puts@plt&gt;  40062f:48 8b 05 12 0a 20 00 mov    0x200a12(%rip),%rax        # 601048 &lt;g_pstr&gt;  400636:48 89 c7             mov    %rax,%rdi  400639:e8 52 fe ff ff       callq  400490 &lt;puts@plt&gt;  40063e:48 b8 6c 6f 63 61 6c movabs $0x74735f6c61636f6c,%rax#‘local_st’ &quot;local_string_I&#39;m a string&quot;变量以常量整型的方式进行复制。  400645:5f 73 74   400648:48 89 85 f0 fe ff ff mov    %rax,-0x110(%rbp)  40064f:48 b8 72 69 6e 67 5f movabs $0x6d27495f676e6972,%rax  # ‘ring_I&#39;m’  400656:49 27 6d   400659:48 89 85 f8 fe ff ff mov    %rax,-0x108(%rbp)  400660:48 b8 20 61 20 73 74 movabs $0x6e69727473206120,%rax  400667:72 69 6e   40066a:48 89 85 00 ff ff ff mov    %rax,-0x100(%rbp)  400671:48 c7 85 08 ff ff ff movq   $0x67,-0xf8(%rbp)  400678:67 00 00 00   40067c:48 8d 95 10 ff ff ff lea    -0xf0(%rbp),%rdx  400683:b8 00 00 00 00       mov    $0x0,%eax  400688:b9 1c 00 00 00       mov    $0x1c,%ecx  40068d:48 89 d7             mov    %rdx,%rdi  400690:f3 48 ab             rep stos %rax,%es:(%rdi)  400693:48 8d 85 f0 fe ff ff lea    -0x110(%rbp),%rax  40069a:48 89 c7             mov    %rax,%rdi  40069d:e8 34 ff ff ff       callq  4005d6 &lt;display&gt;  4006a2:b8 00 00 00 00       mov    $0x0,%eax  4006a7:48 8b 75 f8          mov    -0x8(%rbp),%rsi  4006ab:64 48 33 34 25 28 00 xor    %fs:0x28,%rsi  4006b2:00 00   4006b4:74 05                je     4006bb &lt;main+0xc0&gt;  4006b6:e8 e5 fd ff ff       callq  4004a0 &lt;__stack_chk_fail@plt&gt;  4006bb:c9                   leaveq   4006bc:c3                   retq     4006bd:0f 1f 00             nopl   (%rax)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="第一个pname参数"><a href="#第一个pname参数" class="headerlink" title="第一个pname参数"></a>第一个pname参数</h3><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">400615:48 c7 85 e8 fe ff ff movq   $0x400770,-0x118(%rbp)# 0x400770作为pname的地址40061c:70 07 40 00 400620:48 8b 85 e8 fe ff ff mov    -0x118(%rbp),%rax400627:48 89 c7             mov    %rax,%rdi40062a:e8 61 fe ff ff       callq  400490 &lt;puts@plt&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>![image-20210720102416074](从hello world开始，复习C语言知识——字符串常亮/image-20210720102416074.png)</p><p>查看地址<strong>0x400770</strong>，得到字符串。</p><h3 id="第二个参数g-pstr"><a href="#第二个参数g-pstr" class="headerlink" title="第二个参数g_pstr"></a>第二个参数g_pstr</h3><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">40062f:48 8b 05 12 0a 20 00 mov    0x200a12(%rip),%rax        # 601048 &lt;g_pstr&gt;400636:48 89 c7             mov    %rax,%rdi400639:e8 52 fe ff ff       callq  400490 &lt;puts@plt&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>![image-20210720102733348](从hello world开始，复习C语言知识——字符串常亮/image-20210720102733348.png)</p><p>查看地址<strong>0x400759</strong>，得到地址</p><h3 id="第三个参数字符串常量"><a href="#第三个参数字符串常量" class="headerlink" title="第三个参数字符串常量"></a>第三个参数字符串常量</h3><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">40063e:48 b8 6c 6f 63 61 6c movabs $0x74735f6c61636f6c,%rax#‘local_st’ &quot;local_string_I&#39;m a string&quot;变量以常量整型的方式进行复制。400645:5f 73 74 400648:48 89 85 f0 fe ff ff mov    %rax,-0x110(%rbp)40064f:48 b8 72 69 6e 67 5f movabs $0x6d27495f676e6972,%rax  # ‘ring_I&#39;m’400656:49 27 6d 400659:48 89 85 f8 fe ff ff mov    %rax,-0x108(%rbp)400660:48 b8 20 61 20 73 74 movabs $0x6e69727473206120,%rax400667:72 69 6e 40066a:48 89 85 00 ff ff ff mov    %rax,-0x100(%rbp)400671:48 c7 85 08 ff ff ff movq   $0x67,-0xf8(%rbp)400678:67 00 00 00 40067c:48 8d 95 10 ff ff ff lea    -0xf0(%rbp),%rdx400683:b8 00 00 00 00       mov    $0x0,%eax<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>0x74735f6c61636f6c -&gt; 为字符串”local_st“</p><p>0x6d27495f676e6972-&gt;为字符串”ring_I’m“</p><p>其他等等</p><p>得到字符串。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><h4 id="全局变量和只有引用的字符串常量，使用rodata数据区存储其值"><a href="#全局变量和只有引用的字符串常量，使用rodata数据区存储其值" class="headerlink" title="全局变量和只有引用的字符串常量，使用rodata数据区存储其值"></a>全局变量和只有引用的字符串常量，使用rodata数据区存储其值</h4><p>全局变量g_pstr和pname所指向的地址，均为<code>.rodata</code>，意思是read only。从以下IDA pro的结果中我们也能看出来。</p><p>![image-20210720143206385](从hello world开始，复习C语言知识——字符串常亮/image-20210720143206385.png)</p><h4 id="能够实现赋值初始化的字符串常量，由编译器优化，使用整型常量的方式复制到栈上，不占用rodata空间"><a href="#能够实现赋值初始化的字符串常量，由编译器优化，使用整型常量的方式复制到栈上，不占用rodata空间" class="headerlink" title="能够实现赋值初始化的字符串常量，由编译器优化，使用整型常量的方式复制到栈上，不占用rodata空间"></a>能够实现赋值初始化的字符串常量，由编译器优化，使用整型常量的方式复制到栈上，不占用<code>rodata</code>空间</h4><p>对于<code>char name[256] = &quot;local_string_I&#39;m a string&quot;; </code>实现的赋值语句，其常量是以整型的方式存储，然后赋值到栈上的name变量中。实际上，这是编译器帮助我们实现了这个步骤。</p><p>为了确认这一事实，我们做如下实验：</p><p>使用<code>char name[256] = &quot;llocal_string_I&#39;m a stringlocal_string_I&#39;m a stringlocal_string_I&#39;m a stringlocal_string_I&#39;m a stringocal_string_I&#39;m a string&quot;;</code>进行试验，得到如下结果。</p><p>![image-20210720143749564](从hello world开始，复习C语言知识——字符串常亮/image-20210720143749564.png)</p><p>可以看出，确实是将字符串拆解为整型常量，然后赋值到栈空间上。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其他的常量也可以依次类推。</p><p>一般我们的理解都是字符串常量都是放在<code>rodata</code>中，但是通过汇编代码，我们可以清晰的看出，当字符串常量初始化给一个数组时，字符串常量并不会放在<code>rodata</code>中，二是将字符串常量转化为多个整型常量，然后在运行时直接复制到栈上。</p>]]></content>
    
    
    <summary type="html">从hello world开始，拆解字符串常量的存储位置
第一个程序helloworld
编写程序
首先我们有如下程序：main.c

//main.c
#include &lt;stdio.h&gt;
int display(char *name){
	
	printf(&quot;hello world! %s\n&quot;, name);
}
char *g_pstr = &quot;global_I&#39;m a string\n&quot;;
int 
main(){
	char *pname = &quot;III&#39;m a stringI&#39;m a stringII&#39;m a stringI&#39;m a stringII&#39;m a stringI&#39;m a s</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://dianwoshishi.github.io/2021/07/19/%E4%BB%8E%E4%B8%80%E4%B8%AAhello%20world%E8%AF%B4%E8%B5%B7/"/>
    <id>http://dianwoshishi.github.io/2021/07/19/%E4%BB%8E%E4%B8%80%E4%B8%AAhello%20world%E8%AF%B4%E8%B5%B7/</id>
    <published>2021-07-19T02:09:59.993Z</published>
    <updated>2021-07-21T05:04:10.673Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从一个hello-world说起"><a href="#从一个hello-world说起" class="headerlink" title="从一个hello world说起"></a>从一个hello world说起</h1><p>大家好，我是明说网络的小明同学。今天我们从C语言的Hello World说起，和大家一起温习一下C语言中一个Hello World怎么运行起来的，以及C语言如何组织栈缓冲区等。本文不适用于C语言初学者，需要具备有一定的汇编基础。好了下面，我们开始吧。</p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>本文的工具为：</p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">操作系统：Ubuntu16.04， 4.15.0-142-generic编译器：gcc version 5.4.0 20160609 (Ubuntu 5.4.0-6ubuntu1~16.04.12)make工具GNU Make 4.1反汇编查看器：objdumpelf文件查看器：readelfgdb，pwngdb<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="C语言介绍"><a href="#C语言介绍" class="headerlink" title="C语言介绍"></a>C语言介绍</h2><p>C 语言是一种通用的高级语言，最初是由丹尼斯·里奇在贝尔实验室为开发 UNIX 操作系统而设计的。UNIX 操作系统，C编译器，和几乎所有的 UNIX 应用程序都是用 C 语言编写的。由于各种原因，C 语言现在已经成为一种广泛使用的专业语言。</p><p>同时，C语言是一门大学期间基本上都会开设的课程。作为一门入门编程课程，C语言有着独特的魅力和不可替代的作用。虽然当前python火热，C语言好像显得不那么重要了，“python难道不香吗”的疑问开始出现。但是我的观点是：每种语言有每种语言的优势，python永远也取代不了C语言。像我独爱指针，能够带来自由的感觉。</p><p>下面就开始我们的探索之旅吧。</p><h2 id="第一个程序helloworld"><a href="#第一个程序helloworld" class="headerlink" title="第一个程序helloworld"></a>第一个程序helloworld</h2><h3 id="编写程序"><a href="#编写程序" class="headerlink" title="编写程序"></a>编写程序</h3><p>首先我们有如下程序：<code>main.c</code></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//main.c</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hello world! %s\n"</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"I'm a string"</span><span class="token punctuation">;</span><span class="token function">display</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述程序实现的功能很简单，就是输出一句话<code>hello world! I&#39;m a string</code>，为了便于说明，其中故意使用了一个函数调用<code>int display(char *)</code>。</p><p>函数的逻辑为，main函数–&gt; display()函数(一个参数)–&gt;printf函数(两个参数)。</p><p>是不是很简单！</p><h3 id="程序编译makefile"><a href="#程序编译makefile" class="headerlink" title="程序编译makefile"></a>程序编译makefile</h3><p>为了便于说明，我们使用makefile文件进行编译。创建文件名为<code>makefile</code>的文件，内容如下：</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token comment"># makefile</span>OBJ<span class="token operator">=</span>printf.main<span class="token symbol"><span class="token variable">$</span>(OBJ)</span><span class="token punctuation">:</span>gcc main.c -o <span class="token variable">$@</span><span class="token symbol">clean</span><span class="token punctuation">:</span>-rm <span class="token variable">$</span><span class="token punctuation">(</span>OBJ<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们生成的文件名为<code>printf.main</code>，这里你可以改为你喜欢的任意名称。</p><p>使用<code>make</code>命令进行编译，会生成最终文件。运行后就可以看见<code>hello world! I&#39;m a string</code></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>到这里我们就完成了一个helloworld程序的编写和编译，并且运行。是不是很简单。对于初学者，其实到这里就完了，姑且可以认为main函数就是一个程序的开始和结束（我曾经就一直这么认为）。但是对于有过一定经验的人来说，就知道：main函数并不是一个程序的开始，也不是一个程序的结束。</p><p>咦，这么神奇的吗？就让我们来看看吧。</p><h2 id="Hello-world-的背后"><a href="#Hello-world-的背后" class="headerlink" title="Hello world 的背后"></a>Hello world 的背后</h2><p>首先让我们来认识一下我们生成的<code>printf.main。</code></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">file .&#x2F;printf.main .&#x2F;printf.main: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter &#x2F;lib64&#x2F;ld-linux-x86-64.so.2, for GNU&#x2F;Linux 2.6.32, BuildID[sha1]&#x3D;5c389a402866aaa012b8b8ab992fed778eb989b0, not stripped<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>ELF是执行和链接格式（Execurable and Linking Format）的缩略词。它是UNIX系统的几种可执行文件格式中的一种。</p><p>使用命令<code>readelf -h ./printf.main &gt; elf_head.txt</code></p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">ELF Header:  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00   Class:                             ELF64  Data:                              2&#39;s complement, little endian  Version:                           1 (current)  OS&#x2F;ABI:                            UNIX - System V  ABI Version:                       0  Type:                              EXEC (Executable file)  Machine:                           Advanced Micro Devices X86-64  Version:                           0x1  Entry point address:               0x4004a0 &#x2F;&#x2F;注意这一行  Start of program headers:          64 (bytes into file)  Start of section headers:          6712 (bytes into file)  Flags:                             0x0  Size of this header:               64 (bytes)  Size of program headers:           56 (bytes)  Number of program headers:         9  Size of section headers:           64 (bytes)  Number of section headers:         31  Section header string table index: 28<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里面，我们注意第11行，<code>Entry point address:               0x4004a0</code>,显示，入口点地址为address，说明操作系统在运行这个<code>printf.main</code>程序时，首先从这个地址开始运行。那么我们看看这个地址到底是什么吧</p><h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><p>使用命令<code>objdump -d printf.main &gt; objdump.txt</code>将程序的汇编代码提取出来（删除了一些当前没有必要说明的内容），如下所示：</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">printf.main:     file format elf64-x86-64Disassembly of section .init:0000000000400428 &lt;_init&gt;:  400428:48 83 ec 08          sub    $0x8,%rsp  40042c:48 8b 05 c5 0b 20 00 mov    0x200bc5(%rip),%rax        # 600ff8 &lt;_DYNAMIC+0x1d0&gt;  400433:48 85 c0             test   %rax,%rax  400436:74 05                je     40043d &lt;_init+0x15&gt;  400438:e8 53 00 00 00       callq  400490 &lt;__libc_start_main@plt+0x10&gt;  40043d:48 83 c4 08          add    $0x8,%rsp  400441:c3                   retq   Disassembly of section .plt:0000000000400470 &lt;printf@plt&gt;:  400470:ff 25 aa 0b 20 00    jmpq   *0x200baa(%rip)        # 601020 &lt;_GLOBAL_OFFSET_TABLE_+0x20&gt;  400476:68 01 00 00 00       pushq  $0x1  40047b:e9 d0 ff ff ff       jmpq   400450 &lt;_init+0x28&gt;0000000000400480 &lt;__libc_start_main@plt&gt;:  400480:ff 25 a2 0b 20 00    jmpq   *0x200ba2(%rip)        # 601028 &lt;_GLOBAL_OFFSET_TABLE_+0x28&gt;  400486:68 02 00 00 00       pushq  $0x2  40048b:e9 c0 ff ff ff       jmpq   400450 &lt;_init+0x28&gt;Disassembly of section .plt.got:0000000000400490 &lt;.plt.got&gt;:  400490:ff 25 62 0b 20 00    jmpq   *0x200b62(%rip)        # 600ff8 &lt;_DYNAMIC+0x1d0&gt;  400496:66 90                xchg   %ax,%axDisassembly of section .text:00000000004004a0 &lt;_start&gt;:  4004a0:31 ed                xor    %ebp,%ebp  4004a2:49 89 d1             mov    %rdx,%r9  4004a5:5e                   pop    %rsi  4004a6:48 89 e2             mov    %rsp,%rdx  4004a9:48 83 e4 f0          and    $0xfffffffffffffff0,%rsp  4004ad:50                   push   %rax  4004ae:54                   push   %rsp  4004af:49 c7 c0 b0 06 40 00 mov    $0x4006b0,%r8 &#x2F;&#x2F;00000000004006b0 &lt;__libc_csu_fini&gt;:  4004b6:48 c7 c1 40 06 40 00 mov    $0x400640,%rcx &#x2F;&#x2F;0000000000400640 &lt;__libc_csu_init&gt;:  4004bd:48 c7 c7 bb 05 40 00 mov    $0x4005bb,%rdi &#x2F;&#x2F;00000000004005bb &lt;main&gt;:  4004c4:e8 b7 ff ff ff       callq  400480 &lt;__libc_start_main@plt&gt;  4004c9:f4                   hlt      4004ca:66 0f 1f 44 00 00    nopw   0x0(%rax,%rax,1)0000000000400596 &lt;display&gt;:  400596:55                   push   %rbp  400597:48 89 e5             mov    %rsp,%rbp  40059a:48 83 ec 10          sub    $0x10,%rsp  40059e:48 89 7d f8          mov    %rdi,-0x8(%rbp)  4005a2:48 8b 45 f8          mov    -0x8(%rbp),%rax  4005a6:48 89 c6             mov    %rax,%rsi  4005a9:bf c4 06 40 00       mov    $0x4006c4,%edi  4005ae:b8 00 00 00 00       mov    $0x0,%eax  4005b3:e8 b8 fe ff ff       callq  400470 &lt;printf@plt&gt;  4005b8:90                   nop  4005b9:c9                   leaveq   4005ba:c3                   retq   00000000004005bb &lt;main&gt;:  4005bb:55                   push   %rbp  4005bc:48 89 e5             mov    %rsp,%rbp  4005bf:48 81 ec 10 01 00 00 sub    $0x110,%rsp  4005c6:64 48 8b 04 25 28 00 mov    %fs:0x28,%rax  4005cd:00 00   4005cf:48 89 45 f8          mov    %rax,-0x8(%rbp)  4005d3:31 c0                xor    %eax,%eax  4005d5:48 b8 49 27 6d 20 61 movabs $0x74732061206d2749,%rax  4005dc:20 73 74   4005df:48 89 85 f0 fe ff ff mov    %rax,-0x110(%rbp)  4005e6:48 c7 85 f8 fe ff ff movq   $0x676e6972,-0x108(%rbp)  4005ed:72 69 6e 67   4005f1:48 8d 95 00 ff ff ff lea    -0x100(%rbp),%rdx  4005f8:b8 00 00 00 00       mov    $0x0,%eax  4005fd:b9 1e 00 00 00       mov    $0x1e,%ecx  400602:48 89 d7             mov    %rdx,%rdi  400605:f3 48 ab             rep stos %rax,%es:(%rdi)  400608:48 8d 85 f0 fe ff ff lea    -0x110(%rbp),%rax  40060f:48 89 c7             mov    %rax,%rdi  400612:e8 7f ff ff ff       callq  400596 &lt;display&gt;  400617:b8 00 00 00 00       mov    $0x0,%eax  40061c:48 8b 75 f8          mov    -0x8(%rbp),%rsi  400620:64 48 33 34 25 28 00 xor    %fs:0x28,%rsi  400627:00 00   400629:74 05                je     400630 &lt;main+0x75&gt;  40062b:e8 30 fe ff ff       callq  400460 &lt;__stack_chk_fail@plt&gt;  400630:c9                   leaveq   400631:c3                   retq     400632:66 2e 0f 1f 84 00 00 nopw   %cs:0x0(%rax,%rax,1)  400639:00 00 00   40063c:0f 1f 40 00          nopl   0x0(%rax)0000000000400640 &lt;__libc_csu_init&gt;:  400640:41 57                push   %r15  400642:41 56                push   %r14  400644:41 89 ff             mov    %edi,%r15d  400647:41 55                push   %r13  400649:41 54                push   %r12  40064b:4c 8d 25 be 07 20 00 lea    0x2007be(%rip),%r12        # 600e10 &lt;__frame_dummy_init_array_entry&gt;  400652:55                   push   %rbp  400653:48 8d 2d be 07 20 00 lea    0x2007be(%rip),%rbp        # 600e18 &lt;__init_array_end&gt;  40065a:53                   push   %rbx  40065b:49 89 f6             mov    %rsi,%r14  40065e:49 89 d5             mov    %rdx,%r13  400661:4c 29 e5             sub    %r12,%rbp  400664:48 83 ec 08          sub    $0x8,%rsp  400668:48 c1 fd 03          sar    $0x3,%rbp  40066c:e8 b7 fd ff ff       callq  400428 &lt;_init&gt;  400671:48 85 ed             test   %rbp,%rbp  400674:74 20                je     400696 &lt;__libc_csu_init+0x56&gt;  400676:31 db                xor    %ebx,%ebx  400678:0f 1f 84 00 00 00 00 nopl   0x0(%rax,%rax,1)  40067f:00   400680:4c 89 ea             mov    %r13,%rdx  400683:4c 89 f6             mov    %r14,%rsi  400686:44 89 ff             mov    %r15d,%edi  400689:41 ff 14 dc          callq  *(%r12,%rbx,8)  40068d:48 83 c3 01          add    $0x1,%rbx  400691:48 39 eb             cmp    %rbp,%rbx  400694:75 ea                jne    400680 &lt;__libc_csu_init+0x40&gt;  400696:48 83 c4 08          add    $0x8,%rsp  40069a:5b                   pop    %rbx  40069b:5d                   pop    %rbp  40069c:41 5c                pop    %r12  40069e:41 5d                pop    %r13  4006a0:41 5e                pop    %r14  4006a2:41 5f                pop    %r15  4006a4:c3                   retq     4006a5:90                   nop  4006a6:66 2e 0f 1f 84 00 00 nopw   %cs:0x0(%rax,%rax,1)  4006ad:00 00 00 00000000004006b0 &lt;__libc_csu_fini&gt;:  4006b0:f3 c3                repz retq Disassembly of section .fini:00000000004006b4 &lt;_fini&gt;:  4006b4:48 83 ec 08          sub    $0x8,%rsp  4006b8:48 83 c4 08          add    $0x8,%rsp  4006bc:c3                   retq   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里我们注意第45，46，47，48行，注意其中</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">4004af:49 c7 c0 b0 06 40 00 mov    $0x4006b0,%r8 &#x2F;&#x2F;00000000004006b0 &lt;__libc_csu_fini&gt;:4004b6:48 c7 c1 40 06 40 00 mov    $0x400640,%rcx &#x2F;&#x2F;0000000000400640 &lt;__libc_csu_init&gt;:4004bd:48 c7 c7 bb 05 40 00 mov    $0x4005bb,%rdi &#x2F;&#x2F;00000000004005bb &lt;main&gt;:4004c4:e8 b7 ff ff ff       callq  400480 &lt;__libc_start_main@plt&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>__libc_start_main@plt</code>包含了三个参数，<code>__libc_csu_fini</code>,<code>__libc_csu_init</code>,<code>main</code>显然，从名称上就可以看出这四个函数的作用。</p><p>__libc_start_main是libc.so.6中的一个函数。它的原型是这样的：</p><pre class="line-numbers language-none"><code class="language-none">extern int BP_SYM (__libc_start_main) (int (*main) (int, char **, char **),int argc,char *__unbounded *__unbounded ubp_av,void (*init) (void),void (*fini) (void),void (*rtld_fini) (void),void *__unbounded stack_end)__attribute__ ((noreturn));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个函数需要做的是建立/初始化一些数据结构/环境然后调用我们的main()。</p><p>程序启动的过程应该：<code>_start -&gt; __libc_start_main -&gt; __libc_csu_init -&gt; _init -&gt; main -&gt; _fini</code>.</p><p>这篇文章有详细的说明：<a href="https://blog.csdn.net/gary_ygl/article/details/8506007">linux编程之main()函数启动过程</a></p><h3 id="栈缓冲区及结构"><a href="#栈缓冲区及结构" class="headerlink" title="栈缓冲区及结构"></a>栈缓冲区及结构</h3><blockquote><h3 id="汇编基础"><a href="#汇编基础" class="headerlink" title="汇编基础"></a>汇编基础</h3><p>x86_64有16个64位寄存器，分别是：</p><p>%rax，%rbx，%rcx，%rdx，%esi，%edi，%rbp，%rsp，%r8，%r9，%r10，%r11，%r12，%r13，%r14，%r15。</p><p>其中：</p><p>%rax 作为函数返回值使用。<br>%rsp 栈指针寄存器，指向栈顶<br>%rdi，%rsi，%rdx，%rcx，%r8，%r9 用作函数参数，依次对应第1参数，第2参数<br>%rbx，%rbp，%r12，%r13，%14，%15 用作数据存储，遵循被调用者使用规则，简单说就是随便用，调用子函数之前要备份它，以防他被修改<br>%r10，%r11 用作数据存储，遵循调用者使用规则，简单说就是使用之前要先保存原值</p><p>64位与32位的不同在于64位不用压栈来存储下一个函数参数，而是放在了%rdi，%rsi，%rdx，%rcx，%r8，%r9六个寄存器中，超出部分再压栈。</p><p><img src="https://pic1.zhimg.com/v2-8c6f52a7fabfb4f31464e51c3aa0e8a4_r.jpg" alt="preview"></p><p><img src="https://pic2.zhimg.com/v2-03edf3d060b91b58698db2a58bfb3be5_r.jpg" alt="preview"></p><p><img src="https://pic4.zhimg.com/80/v2-0cbd2ee34a6a173804028b19fe0a9167_720w.jpg" alt="img"></p></blockquote><p>首先，我们将<code>main.c</code>文件进行汇编，使用命令<code>gcc -S main.c</code>，在当前目录下回生成<code>main.s</code>的汇编文件，内容如下：</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">.file&quot;main.c&quot;.section.rodata.LC0:.string&quot;hello world! %s\n&quot;.text.globldisplay.typedisplay, @functiondisplay:.LFB0:.cfi_startprocpushq%rbp.cfi_def_cfa_offset 16.cfi_offset 6, -16movq%rsp, %rbp.cfi_def_cfa_register 6subq$16, %rspmovq%rdi, -8(%rbp)movq-8(%rbp), %raxmovq%rax, %rsimovl$.LC0, %edimovl$0, %eaxcallprintfnopleave.cfi_def_cfa 7, 8ret.cfi_endproc.LFE0:.sizedisplay, .-display.globlmain.typemain, @functionmain:.LFB1:.cfi_startprocpushq%rbp.cfi_def_cfa_offset 16.cfi_offset 6, -16movq%rsp, %rbp.cfi_def_cfa_register 6subq$272, %rspmovq%fs:40, %raxmovq%rax, -8(%rbp)xorl%eax, %eaxmovabsq$8391086132249306953, %rax &#x2F;&#x2F;0x74732061206d2749 (&quot;I&#39;m a st&quot;)movq%rax, -272(%rbp)movq$1735289202, -264(%rbp)leaq-256(%rbp), %rdxmovl$0, %eaxmovl$30, %ecxmovq%rdx, %rdirep stosqleaq-272(%rbp), %raxmovq%rax, %rdi &#x2F;&#x2F;使用%rdi寄存器压入参数calldisplay &#x2F;&#x2F;调用函数movl$0, %eaxmovq-8(%rbp), %rsixorq%fs:40, %rsije.L4call__stack_chk_fail.L4:leave.cfi_def_cfa 7, 8ret.cfi_endproc.LFE1:.sizemain, .-main.ident&quot;GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.12) 5.4.0 20160609&quot;.section.note.GNU-stack,&quot;&quot;,@progbits<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h4><p>在53，54行，使用<code>rdi</code>压入了一个参数，参数的地址在<code>-272(%rbp)（即rdi）</code>, 可以看出正好是字符串”I’m a string”的地址。如下所示：![image-20210719112214862](从一个hello world说起/image-20210719112214862.png)</p><p>其中，函数调用栈缓冲区<code>backtrace</code>显示当前栈缓冲区为main，再上一层为__libc_start_main，再次印证了上一节的说法。</p><h4 id="display函数"><a href="#display函数" class="headerlink" title="display函数"></a>display函数</h4><p>下面我们进入display函数，可以看出printf的两个参数分别放在<code>rdi,rsi</code>两个寄存器当中。</p><p>![image-20210719112513484](从一个hello world说起/image-20210719112513484.png)其中，函数调用栈缓冲区<code>backtrace</code>显示当前栈缓冲区为display，再上一层为main，__libc_start_main，再次印证了上一节的说法。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>通过对main函数中display函数的参数，display函数中的printf函数的参数进行实验，说明了C语言在函数调用时的栈缓冲区的组织。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>对于一个普普通通的C语言程序，其实其背后是一堆复杂的操作系统预备好的操作，执行完毕之后，就开始执行我们的main函数。main函数并不是程序执行的第一个函数，当然也不是最后一个。我们编写的程序的main函数，仅仅是操作系统在加载elf文件时候调用的函数而已，仅仅是函数而已。</p><p>栈缓冲区的组织，一定要动手自己调一调，理解栈缓冲区，有助于理解pwn题中的栈缓冲的利用。</p><p>这就是我喜欢C语言的原因，因为他能让我更加清晰的看到程序运行的背后，而像python这类语言，我也使用，因为真的方便，但是对于理解计算机、理解背后的故事非常的不利。</p><p>关注我，学习更多系统的知识！</p>]]></content>
    
    
    <summary type="html">从一个hello world说起
大家好，我是明说网络的小明同学。今天我们从C语言的Hello World说起，和大家一起温习一下C语言中一个Hello World怎么运行起来的，以及C语言如何组织栈缓冲区等。本文不适用于C语言初学者，需要具备有一定的汇编基础。好了下面，我们开始吧。

工具
本文的工具为：

操作系统：Ubuntu16.04， 4.15.0-142-generic

编译器：gcc version 5.4.0 20160609 (Ubuntu 5.4.0-6ubuntu1~16.04.12)

make工具GNU Make 4.1

反汇编查看器：objdump

elf文件</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://dianwoshishi.github.io/2021/07/15/%E7%94%B1SolarWinds%E6%8F%90%E4%BE%9B%E7%9A%84Serv-U%E7%AE%A1%E7%90%86%E7%9A%84%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E6%9C%8D%E5%8A%A1%E4%B8%AD%E7%9A%84%E4%B8%80%E4%B8%AARCE%E6%BC%8F%E6%B4%9E%E8%A2%AB%E4%BA%BA%E5%88%A9%E7%94%A8/"/>
    <id>http://dianwoshishi.github.io/2021/07/15/%E7%94%B1SolarWinds%E6%8F%90%E4%BE%9B%E7%9A%84Serv-U%E7%AE%A1%E7%90%86%E7%9A%84%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E6%9C%8D%E5%8A%A1%E4%B8%AD%E7%9A%84%E4%B8%80%E4%B8%AARCE%E6%BC%8F%E6%B4%9E%E8%A2%AB%E4%BA%BA%E5%88%A9%E7%94%A8/</id>
    <published>2021-07-15T04:39:35.683Z</published>
    <updated>2021-07-15T04:40:08.922Z</updated>
    
    <content type="html"><![CDATA[<h1 id="由SolarWinds提供的Serv-U管理的文件传输服务中的一个RCE漏洞被人利用"><a href="#由SolarWinds提供的Serv-U管理的文件传输服务中的一个RCE漏洞被人利用" class="headerlink" title="由SolarWinds提供的Serv-U管理的文件传输服务中的一个RCE漏洞被人利用"></a>由SolarWinds提供的Serv-U管理的文件传输服务中的一个RCE漏洞被人利用</h1><p><img src="https://cyware-ent.s3.amazonaws.com/image_bank/08ab_shutterstock_1092298922.jpg" alt="SolarWinds Zero-Day Vulnerability Under Active Attack"></p><p>由SolarWinds提供的Serv-U管理的文件传输服务中的一个RCE漏洞被人利用。SolarWinds公司早些时候通过供应链攻击成为目标，该公司已发布补丁以修复该漏洞。</p><h2 id="发生了什么？"><a href="#发生了什么？" class="headerlink" title="发生了什么？"></a>发生了什么？</h2><p>微软已经提出了有限的和目标客户受到被追踪为CVE-2021-35211的零日漏洞影响的证据。然而，SolarWinds 並沒有准确估计有多少客戶可能受到该漏洞的影响。<br>该漏洞影响到Serv-U 15.2.3 HF1及之前的版本。成功利用该漏洞后，攻击者可在受感染的系统上运行任意代码。<br>此外，该漏洞使攻击者能够安装恶意程序并查看、更改或删除重要数据。然而，该漏洞在Serv-U 15.2.3版热修复（HF）2中得到解决。<br>该公司要求管理员注意任何通过SSH从IP地址98[.]176[.]196[.]89和68[.]235[.]178[.]32或208[.]113[.]35[.]58通过TCP 443的潜在可疑连接。<br>SolarWinds在其最近的公告中表示，发现的零日与SUNBURST供应链攻击没有任何关系。此外，它不影响任何其他产品，特别是Orion平台。</p><h2 id="最近的供应链攻击"><a href="#最近的供应链攻击" class="headerlink" title="最近的供应链攻击"></a>最近的供应链攻击</h2><p>有几起事件被曝光，其中有供应链攻击。<br>最近，卡西亚在一次供应链攻击中被REvil勒索软件盯上，目标是其虚拟系统管理员解决方案中的关键安全漏洞（CVE-2021-30116/19/20）。<br>6月，对航空业的一次巨大的供应链攻击与中国国家行为者APT41有关。<br>5月，加拿大邮政遭遇数据泄露事件，影响到其95万名客户。该安全漏洞是由于基于恶意软件的供应链攻击而发生的。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>最近的供应链攻击突出了现代网络和供应链的脆弱性。攻击者越来越多地发现广泛使用的软件链中的漏洞，以部署恶意软件。因此，建议企业遵循安全机构提供的建议，并定期审查其网络安全态势。</p>]]></content>
    
    
    <summary type="html">由SolarWinds提供的Serv-U管理的文件传输服务中的一个RCE漏洞被人利用


由SolarWinds提供的Serv-U管理的文件传输服务中的一个RCE漏洞被人利用。SolarWinds公司早些时候通过供应链攻击成为目标，该公司已发布补丁以修复该漏洞。

发生了什么？
微软已经提出了有限的和目标客户受到被追踪为CVE-2021-35211的零日漏洞影响的证据。然而，SolarWinds 並沒有准确估计有多少客戶可能受到该漏洞的影响。
该漏洞影响到Serv-U 15.2.3 HF1及之前的版本。成功利用该漏洞后，攻击者可在受感染的系统上运行任意代码。
此外，该漏洞使攻击者能够安装恶意程</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://dianwoshishi.github.io/2021/07/15/%E5%B0%8F%E5%BF%83!%20%E7%BD%91%E7%BB%9C%E7%8A%AF%E7%BD%AA%E5%88%86%E5%AD%90%E6%AD%A3%E5%9C%A8%E5%AF%B9%E5%8A%A0%E5%AF%86%E8%B4%A7%E5%B8%81%E7%94%A8%E6%88%B7%E8%BF%9B%E8%A1%8C%E6%94%BB%E5%87%BB/"/>
    <id>http://dianwoshishi.github.io/2021/07/15/%E5%B0%8F%E5%BF%83!%20%E7%BD%91%E7%BB%9C%E7%8A%AF%E7%BD%AA%E5%88%86%E5%AD%90%E6%AD%A3%E5%9C%A8%E5%AF%B9%E5%8A%A0%E5%AF%86%E8%B4%A7%E5%B8%81%E7%94%A8%E6%88%B7%E8%BF%9B%E8%A1%8C%E6%94%BB%E5%87%BB/</id>
    <published>2021-07-15T04:31:41.164Z</published>
    <updated>2021-07-15T04:34:00.265Z</updated>
    
    <content type="html"><![CDATA[<h1 id="小心-网络犯罪分子正在对加密货币用户进行攻击"><a href="#小心-网络犯罪分子正在对加密货币用户进行攻击" class="headerlink" title="小心! 网络犯罪分子正在对加密货币用户进行攻击"></a>小心! 网络犯罪分子正在对加密货币用户进行攻击</h1><p><img src="https://cyware-ent.s3.amazonaws.com/image_bank/f464_shutterstock_1076473562.jpg" alt="Watch Out! Cybercriminals are Hitting Hard at Cryptocurrency Users"></p><p>随着网络犯罪分子不断发展他们的攻击技术和恶意软件，非法的加密挖矿活动正在飞速增长。上升的主要原因之一是快速增长的加密货币汇率。</p><p>此外，新数字货币的引入和加密货币的正式交易，使人们对加密货币滥用和加密货币诈骗带来的新威胁产生了怀疑。根据Akamai最近的报告，在2020年3月至2021年5月期间，虚假的加密货币交易所钓鱼网址激增超过500%。这些钓鱼网址最终使攻击者能够秘密地盗取钱财。然而，攻击者正在将重点从URL转移到恶意应用程序，以欺骗用户并赚取更多利润。</p><h2 id="BitScam和CloudScam"><a href="#BitScam和CloudScam" class="headerlink" title="BitScam和CloudScam"></a>BitScam和CloudScam</h2><p>最近，Lookout威胁实验室的安全研究人员发现了170多个安卓应用，这些应用欺骗对加密货币感兴趣的人。<br>根据研究人员的发现，这些应用程序被归类为BitScam和CloudScam。这些应用程序承诺帮助受害者进行云采矿，而不需要额外的商品或服务。<br>这两个版本都提供了加密采矿的订阅和服务，用户可以通过Google Play的应用内付费系统来启用。<br>BitScam与CloudScam的唯一区别是在支付选项中增加了比特币和以太坊。<br>然而，受害者并不知道，攻击者正在眼皮下利用他们。据悉，攻击者至少骗取了35万美元的加密货币资金。</p><h2 id="更深层次-的攻击"><a href="#更深层次-的攻击" class="headerlink" title="更深层次 的攻击"></a>更深层次 的攻击</h2><p>联邦调查局发布了一份关于正在进行的针对加密货币所有者和第三方平台的攻击的警告。<br>该警告显示，攻击者正在使用几种战术来控制目标的加密货币交易所账户并窃取数字货币。<br>冒充支付平台和利用SIM卡交换攻击是攻击者用来发动攻击的一些战术。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>随着加密货币变得更加重要，看到它在越来越多的受到攻击将不足为奇，例如DDoS勒索和勒索软件攻击。鉴于与加密货币相关的攻击对消费者和企业的潜在影响，强烈建议建立主动的安全监测和控制。</p>]]></content>
    
    
    <summary type="html">小心! 网络犯罪分子正在对加密货币用户进行攻击


随着网络犯罪分子不断发展他们的攻击技术和恶意软件，非法的加密挖矿活动正在飞速增长。上升的主要原因之一是快速增长的加密货币汇率。

此外，新数字货币的引入和加密货币的正式交易，使人们对加密货币滥用和加密货币诈骗带来的新威胁产生了怀疑。根据Akamai最近的报告，在2020年3月至2021年5月期间，虚假的加密货币交易所钓鱼网址激增超过500%。这些钓鱼网址最终使攻击者能够秘密地盗取钱财。然而，攻击者正在将重点从URL转移到恶意应用程序，以欺骗用户并赚取更多利润。

BitScam和CloudScam
最近，Lookout威胁实验室的安全研究人员</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://dianwoshishi.github.io/2021/07/14/IT%E3%80%81%E5%88%B6%E9%80%A0%E4%B8%9A%E5%92%8C%E5%8C%BB%E7%96%97%E5%8D%AB%E7%94%9F%E9%83%A8%E9%97%A8%E6%88%90%E4%B8%BA%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E7%9A%84%E9%87%8D%E7%82%B9%E7%9B%AE%E6%A0%87/"/>
    <id>http://dianwoshishi.github.io/2021/07/14/IT%E3%80%81%E5%88%B6%E9%80%A0%E4%B8%9A%E5%92%8C%E5%8C%BB%E7%96%97%E5%8D%AB%E7%94%9F%E9%83%A8%E9%97%A8%E6%88%90%E4%B8%BA%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E7%9A%84%E9%87%8D%E7%82%B9%E7%9B%AE%E6%A0%87/</id>
    <published>2021-07-14T07:25:00.683Z</published>
    <updated>2021-07-14T07:26:29.710Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IT、制造业和医疗卫生部门成为网络攻击的重点目标"><a href="#IT、制造业和医疗卫生部门成为网络攻击的重点目标" class="headerlink" title="IT、制造业和医疗卫生部门成为网络攻击的重点目标"></a>IT、制造业和医疗卫生部门成为网络攻击的重点目标</h1><p><img src="https://cyware-ent.s3.amazonaws.com/image_bank/shutterstock_178125287.jpg" alt="IT, Manufacturing, and Healthcare Sectors Need to Stay Away from Cyberattacks"></p><p>医疗保健和制造业受到主动的网络攻击，这已经不是什么秘密。威胁形势已经发生了巨大的变化，而且事情正在变得越来越糟糕。除了这两个行业，IT行业也已成为网络攻击的最主要目标之一。</p><h2 id="一些统计数字"><a href="#一些统计数字" class="headerlink" title="一些统计数字"></a>一些统计数字</h2><p>Avanan公司最近的一份报告对今年上半年的网络攻击趋势作了说明。</p><ul><li>IT行业的公司见证了9000多封钓鱼邮件，其次是医疗保健和制造业，每10,000名用户每30天大约有6000封钓鱼邮件。</li><li>在所有网络钓鱼攻击中，凭证收集占54%，BEC攻击占20.7%，敲诈占2.2%。</li><li>黑客已经开始瞄准非行政人员，而不是C级行政人员，占据了77%的份额。</li></ul><h2 id="为什么这很重要？"><a href="#为什么这很重要？" class="headerlink" title="为什么这很重要？"></a>为什么这很重要？</h2><p>当医疗机构受到勒索软件攻击者的攻击，制造业公司不断遭受供应链中断的影响时，黑客已经诉诸于最基本的战术–钓鱼邮件来进行未经授权的访问。这些行业非常容易受到网络攻击，因为它们管理着有价值的信息，而这些信息在暗网市场上需求很大。此外，设施设备仍然使用过时的技术，再加上缺乏适当的员工培训和基本的网络安全防护知识，使这些部门被攻击者盯上。</p><h2 id="底线"><a href="#底线" class="headerlink" title="底线"></a>底线</h2><p>现在，我们已经意识到网络犯罪分子为实现其邪恶的意图会不惜一切代价。诸如网络钓鱼和社会工程等经久不衰的方法，以及诸如供应链攻击等独特而复杂的方法，都被用来获得对未受保护或保护不力的系统的访问。如果没有适当的防御措施，这些部门将继续成为网络攻击的目标。</p>]]></content>
    
    
    <summary type="html">IT、制造业和医疗卫生部门成为网络攻击的重点目标


医疗保健和制造业受到主动的网络攻击，这已经不是什么秘密。威胁形势已经发生了巨大的变化，而且事情正在变得越来越糟糕。除了这两个行业，IT行业也已成为网络攻击的最主要目标之一。

一些统计数字
Avanan公司最近的一份报告对今年上半年的网络攻击趋势作了说明。

 * IT行业的公司见证了9000多封钓鱼邮件，其次是医疗保健和制造业，每10,000名用户每30天大约有6000封钓鱼邮件。
 * 在所有网络钓鱼攻击中，凭证收集占54%，BEC攻击占20.7%，敲诈占2.2%。
 * 黑客已经开始瞄准非行政人员，而不是C级行政人员，占据了77%的份</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://dianwoshishi.github.io/2021/07/14/%E9%BB%91%E5%AE%A2%E4%BC%AA%E8%A3%85%E6%88%90%E5%AD%A6%E8%80%85%E7%AA%83%E5%8F%96%E5%AF%86%E7%A0%81/"/>
    <id>http://dianwoshishi.github.io/2021/07/14/%E9%BB%91%E5%AE%A2%E4%BC%AA%E8%A3%85%E6%88%90%E5%AD%A6%E8%80%85%E7%AA%83%E5%8F%96%E5%AF%86%E7%A0%81/</id>
    <published>2021-07-14T04:05:31.240Z</published>
    <updated>2021-07-14T04:05:51.772Z</updated>
    
    <content type="html"><![CDATA[<h1 id="黑客伪装成学者窃取密码"><a href="#黑客伪装成学者窃取密码" class="headerlink" title="黑客伪装成学者窃取密码"></a>黑客伪装成学者窃取密码</h1><p><img src="https://www.cybersafe.news/wp-content/uploads/2021/07/iran-1-800x400.jpg" alt="img"></p><p>一个在伊朗的攻击组织在钓鱼攻击中使用了英国大学真实学者的欺骗性身份，以窃取大学、智囊团、记者和教授的中东事务专家的密码口令信息。</p><p>企业安全公司Proofpoint将这一被称为 “SpoofedScholars行动 “的活动归咎于被追踪的高级持续性威胁TA453，也被称为APT35（FireEye）、Charming Kitten（ClearSky）和Phosphorous（Microsoft）。</p><p>这个政府网络战组织被怀疑代表伊斯兰革命卫队（IRGC）开展情报工作。</p><p>据安全研究人员称，确定的目标包括来自智囊团的中东事务专家、知名学术机构的高级教授和专门从事中东报道的记者。</p><p>这一活动表明TA453的方法有了新的升级和复杂性。</p><p>攻击链涉及到威胁行为者冒充英国学者，向一群高度选择性的受害者试图诱使目标点击一个在线会议的注册链接，该链接被设计为从谷歌、微软、Facebook和雅虎获取各种凭证。</p><p>该证书钓鱼基础设施被托管在一个属于伦敦大学东方和非洲研究学院（SOAS）的真实但被破坏的网站上，利用该网站将个性化的证书采集页面伪装成注册链接，然后传递给毫无戒心的接收者。</p><p>例如，TA453向目标人物的个人电子邮件账户发送了一封证书采集电子邮件。</p><p>TA453还坚持要求目标在该组织在线时登录注册网络研讨会，这使攻击者有可能 “计划立即手动验证捕获的凭证”。</p><p>据信这些攻击发生在2021年1月，在该集团在随后的电子邮件钓鱼引诱中转移了他们的战术。</p>]]></content>
    
    
    <summary type="html">黑客伪装成学者窃取密码


一个在伊朗的攻击组织在钓鱼攻击中使用了英国大学真实学者的欺骗性身份，以窃取大学、智囊团、记者和教授的中东事务专家的密码口令信息。

企业安全公司Proofpoint将这一被称为 “SpoofedScholars行动 “的活动归咎于被追踪的高级持续性威胁TA453，也被称为APT35（FireEye）、Charming Kitten（ClearSky）和Phosphorous（Microsoft）。

这个政府网络战组织被怀疑代表伊斯兰革命卫队（IRGC）开展情报工作。

据安全研究人员称，确定的目标包括来自智囊团的中东事务专家、知名学术机构的高级教授和专门从事中东报</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://dianwoshishi.github.io/2021/07/14/%E6%97%B6%E5%B0%9A%E9%9B%B6%E5%94%AE%E5%95%86Guess%E6%8A%AB%E9%9C%B2%E6%95%B0%E6%8D%AE%E6%B3%84%E9%9C%B2/"/>
    <id>http://dianwoshishi.github.io/2021/07/14/%E6%97%B6%E5%B0%9A%E9%9B%B6%E5%94%AE%E5%95%86Guess%E6%8A%AB%E9%9C%B2%E6%95%B0%E6%8D%AE%E6%B3%84%E9%9C%B2/</id>
    <published>2021-07-14T03:57:15.753Z</published>
    <updated>2021-07-14T03:58:53.187Z</updated>
    
    <content type="html"><![CDATA[<h1 id="时尚零售商Guess披露数据泄露"><a href="#时尚零售商Guess披露数据泄露" class="headerlink" title="时尚零售商Guess披露数据泄露"></a>时尚零售商Guess披露数据泄露</h1><p><img src="https://www.cybersafe.news/wp-content/uploads/2021/07/guess.jpg" alt="img"></p><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>美国时尚品牌和零售商Guess在2月份的勒索软件攻击导致数据被盗后，又遭遇了数据泄露。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>该公司已经开始通知受影响的客户有关数据泄露的情况，其中指出，经调查发现，在2021年2月2日至2021年2月23日期间，Guess的系统遭到未经授权的访问。</p><p>经过调查，在2021年5月26日，确定与某些人有关的个人信息可能已经被未经授权的行为者使用。在这次攻击中暴露的信息包括社会安全号码、驾驶执照号码、护照号码和/或金融账户号码等细节。尽管受影响的个人数量没有透露，但提交给缅因州总检察长办公室的信息显示，在2月份的攻击中，有超过1300人的数据被暴露或被访问。</p><p>Guess没有提供任何关于勒索软件攻击背后的威胁者的细节，但DarkSide勒索软件团伙已将Guess列入其数据泄露网站。</p><p>该团伙声称，在试图加密他们的系统之前，已经从这家时尚零售商的网络中窃取了价值超过200GB的文件。</p><h2 id="措施和进展"><a href="#措施和进展" class="headerlink" title="措施和进展"></a>措施和进展</h2><p>这家时尚零售商在2021年6月3日完成了对存储在被入侵系统中的文件的全面审查后，确定了所有受影响个人的地址。</p><p>Guess已经通过Experian向所有受影响的个人提供免费的身份盗窃保护服务和一年的免费信用监测。</p><p>Guess公司已经实施了额外的措施来提高其安全协议，并正在与执法部门合作，作为正在进行的事件调查的一部分。</p><p>截至2021年5月，Guess在美洲、欧洲和亚洲直接经营1041家零售店，其分销商和合作伙伴在全球另有539家店。属于Guess零售网络的商店目前在大约100个国家经营。</p>]]></content>
    
    
    <summary type="html">时尚零售商Guess披露数据泄露


摘要
美国时尚品牌和零售商Guess在2月份的勒索软件攻击导致数据被盗后，又遭遇了数据泄露。

正文
该公司已经开始通知受影响的客户有关数据泄露的情况，其中指出，经调查发现，在2021年2月2日至2021年2月23日期间，Guess的系统遭到未经授权的访问。

经过调查，在2021年5月26日，确定与某些人有关的个人信息可能已经被未经授权的行为者使用。在这次攻击中暴露的信息包括社会安全号码、驾驶执照号码、护照号码和/或金融账户号码等细节。尽管受影响的个人数量没有透露，但提交给缅因州总检察长办公室的信息显示，在2月份的攻击中，有超过1300人的数据被暴露或被</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://dianwoshishi.github.io/2021/07/12/%E7%8A%AF%E7%BD%AA%E5%88%86%E5%AD%90%E8%BF%9B%E5%85%A5%E4%B8%80%E4%B8%AA%E7%BD%91%E7%BB%9C%E9%9C%80%E8%A6%81%E5%A4%9A%E5%B0%91%E9%92%B1%EF%BC%9F%E5%8F%AF%E8%83%BD%E6%98%AF7200%E7%BE%8E%E5%85%83/"/>
    <id>http://dianwoshishi.github.io/2021/07/12/%E7%8A%AF%E7%BD%AA%E5%88%86%E5%AD%90%E8%BF%9B%E5%85%A5%E4%B8%80%E4%B8%AA%E7%BD%91%E7%BB%9C%E9%9C%80%E8%A6%81%E5%A4%9A%E5%B0%91%E9%92%B1%EF%BC%9F%E5%8F%AF%E8%83%BD%E6%98%AF7200%E7%BE%8E%E5%85%83/</id>
    <published>2021-07-12T00:47:34.170Z</published>
    <updated>2021-07-12T00:48:54.004Z</updated>
    
    <content type="html"><![CDATA[<h1 id="犯罪分子进入一个网络需要多少钱？可能是7200美元"><a href="#犯罪分子进入一个网络需要多少钱？可能是7200美元" class="headerlink" title="犯罪分子进入一个网络需要多少钱？可能是7200美元"></a>犯罪分子进入一个网络需要多少钱？可能是7200美元</h1><p><img src="https://cybernews.com/wp-content/uploads/2021/07/hacker-2-750x375.jpg" alt="Average cost to break into a network – $7,200"></p><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>Verizon数据泄露调查报告（DBIR）显示，勒索软件是泄露事件当中的第三大热门行动。”报告的作者Phil Langlois在一次网络研讨会上说：”这很令人吃惊。平均而言，网络犯罪分子进入一个网络要花费7200美元。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>Verizon分析了来自全球88个国家的样本，近8万起事件，其中5,300起是确认的泄露事件。研究强调，事件和漏洞之间是有区别的。事件是指损害信息资产的完整性、保密性或可用性的安全事件，而漏洞是一个导致数据被确认披露给未授权方的事件。</p><h2 id="三种最常见的入侵类型"><a href="#三种最常见的入侵类型" class="headerlink" title="三种最常见的入侵类型"></a>三种最常见的入侵类型</h2><p>研究人员将他们观察到的事件和漏洞归纳为八个核心模式，代表了绝大多数的事件。当我们谈论漏洞时，社会工程、基本网络应用程序攻击和系统入侵是最流行的模式。Phil Langlois简要地介绍了这三种模式。</p><p><strong>社会工程。</strong>研究人员发现，他们分析的大约85%的漏洞涉及人为因素。”有人点击了一个链接，错误地配置了一个防火墙，或类似的东西，”Langlois说明道。研究人员还看到网络钓鱼有了相对显著的增长。以前，它占数据泄露的1/4，而现在它徘徊在36%左右。</p><p><strong>基本的网络应用程序攻击</strong>是那些在最初的网络应用程序被破坏后有少量的步骤或额外的行动。它们非常专注于直接攻击目标，从获取电子邮件和网络应用程序数据，到重新利用网络应用程序进行恶意软件分发、污损或未来的DDoS攻击。Langlois说：”我们谈论的是单步攻击，在这种攻击中，对手利用的往往是受损的凭证、弱口令，有时还有漏洞，”。他称其为互联网噪音（internet noise）：不断看到凭证被使用和暴力攻击的尝试。</p><p><strong>系统入侵</strong>涉及一个高级攻击者。这种模式代表了一个专门的攻击者使用黑客和恶意软件技术的组合来实现其目标。系统入侵的三个主要组成部分是勒索软件、一般的高级威胁，以及magecart攻击，即攻击者在应用程序中注入恶意的javascript以窃取信用卡信息。例如，电子商务安全供应商Sansec报告说，Lazarus集团一直在使用Magecart支付卡盗刷来攻击美国和欧盟的电子零售商。</p><p>Langlois强调说，赎金软件在增长，现在占他们分析的泄露事件的10%。他说：”这是一个相当戏剧性的上升”。</p><h2 id="犯罪分子接入一个网络需要多少钱？"><a href="#犯罪分子接入一个网络需要多少钱？" class="headerlink" title="犯罪分子接入一个网络需要多少钱？"></a>犯罪分子接入一个网络需要多少钱？</h2><p>初始访问代理（Initial access brokers ）催生了勒索软件。犯罪分子在暗网购买数据或出售数据和访问权限。最主要的目标行业是零售、金融服务、工业品、医疗保健和技术部门。</p><p>研究人员正在研究各种非法市场。自2020年以来，他们已经看到了500个不同的网络访问权限的销售清单。这意味着，如果你有一个不安全的网络，可能会被出售。</p><p>根据数字风险保护公司Digital Shadows的数据，平均而言，网络犯罪分子进入一个网络要花费7200美元。</p><p>远程桌面协议（RDP）访问是列出的最常见的访问类型，平均价格为9,874美元。</p>]]></content>
    
    
    <summary type="html">犯罪分子进入一个网络需要多少钱？可能是7200美元


摘要
Verizon数据泄露调查报告（DBIR）显示，勒索软件是泄露事件当中的第三大热门行动。”报告的作者Phil Langlois在一次网络研讨会上说：”这很令人吃惊。平均而言，网络犯罪分子进入一个网络要花费7200美元。

正文
Verizon分析了来自全球88个国家的样本，近8万起事件，其中5,300起是确认的泄露事件。研究强调，事件和漏洞之间是有区别的。事件是指损害信息资产的完整性、保密性或可用性的安全事件，而漏洞是一个导致数据被确认披露给未授权方的事件。

三种最常见的入侵类型
研究人员将他们观察到的事件和漏洞归纳为八个核心模式</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://dianwoshishi.github.io/2021/07/12/%E9%BB%91%E5%AE%A2%E7%BB%84%E7%BB%87%E8%AF%95%E5%9B%BE%E4%BD%BF%E7%94%A8Go%E8%AF%AD%E8%A8%80%E6%94%BB%E5%87%BB%E6%A8%A1%E5%9D%97%EF%BC%8C%E8%BA%B2%E9%81%BF%E5%8F%8C%E5%9B%A0%E5%AD%90%E8%AE%A4%E8%AF%81/"/>
    <id>http://dianwoshishi.github.io/2021/07/12/%E9%BB%91%E5%AE%A2%E7%BB%84%E7%BB%87%E8%AF%95%E5%9B%BE%E4%BD%BF%E7%94%A8Go%E8%AF%AD%E8%A8%80%E6%94%BB%E5%87%BB%E6%A8%A1%E5%9D%97%EF%BC%8C%E8%BA%B2%E9%81%BF%E5%8F%8C%E5%9B%A0%E5%AD%90%E8%AE%A4%E8%AF%81/</id>
    <published>2021-07-12T00:22:02.558Z</published>
    <updated>2021-07-12T00:22:04.453Z</updated>
    
    <content type="html"><![CDATA[<h1 id="黑客组织试图使用Go语言攻击模块，躲避双因子认证"><a href="#黑客组织试图使用Go语言攻击模块，躲避双因子认证" class="headerlink" title="黑客组织试图使用Go语言攻击模块，躲避双因子认证"></a>黑客组织试图使用Go语言攻击模块，躲避双因子认证</h1><p><img src="https://www.cybersafe.news/wp-content/uploads/2021/07/indian-hackers.jpg" alt="img"></p><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>一个以印度政府官员为目标、使用新的定制远程访问特洛伊木马（RATs）的网络间谍组织被发现，使用go语言，试图“破解”双因子认证。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>这些攻击来自于黑客组织SideCopy，入侵导致了从文件枚举到浏览器凭证窃取和键盘记录（Xeytan和Lavao）的各种模块化插件的部署。</p><p>印度网络安全公司Quick Heal在2020年9月首次记录了SideCopy，它模仿Sidewinder APT的感染链，以提供自己的一套恶意软件，避免被发现，同时它还不断重新调整有效载荷，包括在侦察受害者的数据和环境后，在其武器中加入额外的漏洞等。</p><p>据研究人员Asheer Malhotra和Justin Thattil称，SideCopy活动中的目标策略和主题与同样针对印度的Transparent Tribe APT （又名APT36）非常相似，包括使用伪装成属于军方和智囊团的行动文件进行传播等。</p><h2 id="技术概述"><a href="#技术概述" class="headerlink" title="技术概述"></a>技术概述</h2><p>SideCopy部署了成熟的后门，还被发现利用插件在受感染的终端上执行特定的恶意任务，其中最主要的是一个名为 “Nodachi “的基于Golang的模块，旨在进行侦察和窃取文件，目标是一个名为Kavach的政府规定的双因素认证解决方案（这是访问电子邮件服务所必需的）。</p><p>主要目的是窃取印度政府雇员的访问凭证，重点是进行间谍活动。攻击者还为MargulasRAT开发了伪装成Windows上Kavach的安装程序的droppers。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>新的RAT恶意软件的发展表明，该组织正在迅速发展其恶意软件库和利用工具。这些行为表明正在努力将攻击链模块化，同时也表明了该组织战术的复杂性在增加。</p>]]></content>
    
    
    <summary type="html">黑客组织试图使用Go语言攻击模块，躲避双因子认证


摘要
一个以印度政府官员为目标、使用新的定制远程访问特洛伊木马（RATs）的网络间谍组织被发现，使用go语言，试图“破解”双因子认证。

正文
这些攻击来自于黑客组织SideCopy，入侵导致了从文件枚举到浏览器凭证窃取和键盘记录（Xeytan和Lavao）的各种模块化插件的部署。

印度网络安全公司Quick Heal在2020年9月首次记录了SideCopy，它模仿Sidewinder APT的感染链，以提供自己的一套恶意软件，避免被发现，同时它还不断重新调整有效载荷，包括在侦察受害者的数据和环境后，在其武器中加入额外的漏洞等。

据研</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://dianwoshishi.github.io/2021/07/12/%E7%8A%AF%E7%BD%AA%E5%88%86%E5%AD%90%E5%A6%82%E4%BD%95%E5%B0%86%E7%A7%81%E5%AF%86%E4%BF%A1%E6%81%AF%E9%80%9A%E8%BF%87%E5%9B%BE%E7%89%87%E7%AD%89%E6%96%87%E4%BB%B6%E5%A4%96%E5%B8%A6%E5%87%BA%E6%9D%A5%EF%BC%9F/"/>
    <id>http://dianwoshishi.github.io/2021/07/12/%E7%8A%AF%E7%BD%AA%E5%88%86%E5%AD%90%E5%A6%82%E4%BD%95%E5%B0%86%E7%A7%81%E5%AF%86%E4%BF%A1%E6%81%AF%E9%80%9A%E8%BF%87%E5%9B%BE%E7%89%87%E7%AD%89%E6%96%87%E4%BB%B6%E5%A4%96%E5%B8%A6%E5%87%BA%E6%9D%A5%EF%BC%9F/</id>
    <published>2021-07-12T00:19:13.326Z</published>
    <updated>2021-07-12T00:19:47.343Z</updated>
    
    <content type="html"><![CDATA[<h1 id="犯罪分子如何将私密信息通过图片等文件外带出来？"><a href="#犯罪分子如何将私密信息通过图片等文件外带出来？" class="headerlink" title="犯罪分子如何将私密信息通过图片等文件外带出来？"></a>犯罪分子如何将私密信息通过图片等文件外带出来？</h1><p><img src="https://thehackernews.com/images/-cJoAq5cCs1U/YOhaPTZLspI/AAAAAAAADJU/LYmgXTIn_nsBcMW1TGfJqqc0gL7KJ1q0wCLcBGAsYHQ/s728-e1000/credit-card-data.jpg" alt="Magecart hack"></p><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>隶属于Magecart的网络犯罪分子已经掌握了一种新的技术，即在评论区中混淆恶意软件代码，并将窃取的信用卡数据编码到服务器上托管的图像和其他文件中，这再次表明攻击者不断改进其感染链从而逃避检测。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>“Sucuri安全分析师Ben Martin在一篇文章中说：”一些Magecart 攻击者采用的一个策略是将刷卡的信用卡细节嵌入在服务器上的图像文件中，从而避免引起怀疑。”这些文件以后可以使用一个简单的HTTP GET请求下载。</p><p>MageCart是多个网络犯罪团伙的总称，他们以电子商务网站为目标，目的是通过注入恶意的JavaScript skimmers来掠夺信用卡号码，并在黑市上出售。</p><p>Sucuri根据威胁者采用的战术、技术和程序（TTPs）中的重叠部分，将这次攻击归于Magecart Group 7。</p><p><img src="https://thehackernews.com/images/-k_2b7TRsrTk/YOhV30KyJPI/AAAAAAAADJM/K_bbvEP4LqcS4ApmGi9Y-6X5ZdiUtxFNACLcBGAsYHQ/s728-e1000/code.jpg" alt="Magecart hack"></p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>在GoDaddy旗下的安全公司调查的一个Magento电子商务网站感染案例中，发现盗取器是以Base64编码的压缩字符串的形式插入到结账过程中的一个PHP文件中。</p><p>更重要的是，为了进一步掩盖恶意代码在PHP文件中的存在，据说对手使用了一种叫做concatenation的技术，其中代码与额外的注释块相结合，”在功能上不做任何事情，但它增加了一层混淆，使其在某种程度上更难以检测”。</p><p>最终，攻击的目的是在被攻击的网站上实时捕捉客户的支付卡细节，然后将其保存在服务器上的假样式表文件（.CSS）中，随后在威胁行为者的终端通过GET请求下载。</p><p>“马丁说：”MageCart对电子商务网站的威胁越来越大。”从攻击者的角度来看：回报太大，后果不存在，他们为什么不呢？通过在黑市上偷窃和出售被盗的信用卡，简直就是发了大财。”</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>信息不对称和高收益，使得越来越多的不发分子涌入网络犯罪，通过技术的发展，谋求利益。</p>]]></content>
    
    
    <summary type="html">犯罪分子如何将私密信息通过图片等文件外带出来？


摘要
隶属于Magecart的网络犯罪分子已经掌握了一种新的技术，即在评论区中混淆恶意软件代码，并将窃取的信用卡数据编码到服务器上托管的图像和其他文件中，这再次表明攻击者不断改进其感染链从而逃避检测。

正文
“Sucuri安全分析师Ben Martin在一篇文章中说：”一些Magecart 攻击者采用的一个策略是将刷卡的信用卡细节嵌入在服务器上的图像文件中，从而避免引起怀疑。”这些文件以后可以使用一个简单的HTTP GET请求下载。

MageCart是多个网络犯罪团伙的总称，他们以电子商务网站为目标，目的是通过注入恶意的JavaScrip</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://dianwoshishi.github.io/2021/07/07/favicon%20%E5%9B%BE%E6%A0%87%E8%A2%AB%E9%BB%91%E5%AE%A2%E7%94%A8%E6%9D%A5%E5%8A%A0%E8%BD%BD%E5%90%8E%E9%97%A8%E7%A8%8B%E5%BA%8F/"/>
    <id>http://dianwoshishi.github.io/2021/07/07/favicon%20%E5%9B%BE%E6%A0%87%E8%A2%AB%E9%BB%91%E5%AE%A2%E7%94%A8%E6%9D%A5%E5%8A%A0%E8%BD%BD%E5%90%8E%E9%97%A8%E7%A8%8B%E5%BA%8F/</id>
    <published>2021-07-07T01:41:03.000Z</published>
    <updated>2021-07-07T01:41:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="favicon-图标被黑客用来加载后门程序"><a href="#favicon-图标被黑客用来加载后门程序" class="headerlink" title="favicon 图标被黑客用来加载后门程序"></a>favicon 图标被黑客用来加载后门程序</h1><p><img src="https://www.cybersafe.news/wp-content/uploads/2021/05/magecart-640x400.jpg" alt="img"></p><p>网络犯罪分子正在分发伪装成favicon的恶意PHP web shells，以实现对被攻击服务器的远程访问，并将JavaScript skimmers注入在线购物平台，目的是窃取用户的财务信息。</p><p>Malwarebytes Jérôme Segura表示，这些被称为Smilodon或Megalodon的Web shells被用来通过服务器端请求动态加载JavaScript skimming代码到在线商店。这种技术很有趣，因为大多数客户端的安全工具将无法检测或阻挡盗取者。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Magecart，针对在线购物网站的黑客组织使用在电子商务网站上注入网络盗取器(web skimmers)的技术来窃取信用卡的详细信息。盗取器(skimmers )也被称为形式劫持攻击，盗取器采取JavaScript代码的形式，操作者秘密插入电子商务网站，通常是在支付页面，目的是实时捕捉客户的银行卡信息，并将其传输到远程服务器。</p><p>注入式盗刷器的工作原理是，当客户访问网店时，向托管在攻击者控制的域名上的外部JavaScript资源发出客户端请求。然而，最新的攻击有点不同，因为盗取代码是在服务器端动态引入商家网站的。</p><p>基于PHP的网络外壳恶意软件伪装成favicon（”Magento.png”），通过篡改HTML代码中的快捷图标标签指向假的PNG图像文件，将恶意软件插入到被攻击的网站。这个网络shell又被配置为从外部主机-获取下一阶段的有效载荷:一个信用卡盗刷器。</p><h2 id="恶意活动关联"><a href="#恶意活动关联" class="headerlink" title="恶意活动关联"></a>恶意活动关联</h2><p>基于TTPs( tactics, techniques, and procedures)的重叠，最新的活动被归结为Magecart Group 12。Malwarebytes补充说，他们发现的最新域名（zolo[.]pw）恰好与recaptcha-in[.]pw和google-statik[.]pw托管在同一个IP地址（217.12.204[.]185），这两个域名之前与Magecart Group 12有关。</p><p>在过去的几个月里，Magecart的行为者使用了几种攻击技术来避免被发现和渗出数据。</p>]]></content>
    
    
    <summary type="html">favicon 图标被黑客用来加载后门程序


网络犯罪分子正在分发伪装成favicon的恶意PHP web shells，以实现对被攻击服务器的远程访问，并将JavaScript skimmers注入在线购物平台，目的是窃取用户的财务信息。

Malwarebytes Jérôme Segura表示，这些被称为Smilodon或Megalodon的Web shells被用来通过服务器端请求动态加载JavaScript skimming代码到在线商店。这种技术很有趣，因为大多数客户端的安全工具将无法检测或阻挡盗取者。

原理
Magecart，针对在线购物网站的黑客组织使用在电子商务网站上注入</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://dianwoshishi.github.io/2021/07/07/%E6%89%93%E7%9D%80%E5%AE%89%E5%85%A8%E7%9A%84%E5%B9%8C%E5%AD%90%E5%85%AC%E7%84%B6%E7%BB%99%E5%AE%A2%E6%88%B7%E5%AE%89%E8%A3%85%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6/"/>
    <id>http://dianwoshishi.github.io/2021/07/07/%E6%89%93%E7%9D%80%E5%AE%89%E5%85%A8%E7%9A%84%E5%B9%8C%E5%AD%90%E5%85%AC%E7%84%B6%E7%BB%99%E5%AE%A2%E6%88%B7%E5%AE%89%E8%A3%85%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6/</id>
    <published>2021-07-07T01:33:41.000Z</published>
    <updated>2021-07-07T01:33:41.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="打着安全的幌子公然给客户安装恶意软件"><a href="#打着安全的幌子公然给客户安装恶意软件" class="headerlink" title="打着安全的幌子公然给客户安装恶意软件"></a>打着安全的幌子公然给客户安装恶意软件</h1><p><img src="https://cyware-ent.s3.amazonaws.com/image_bank/shutterstock_255112744.jpg" alt="Malicious Privacy Tools Advertised to Extract Private Data"></p><p>最近，来自Proofpoint的研究人员发现了一种新的网络安全威胁，它试图用一个看起来很专业的网站的虚假幌子来欺骗人们，声称可以提供更强的安全性。这种伪装可以说是一种讽刺，因为它实际上最终在受害者的机器上部署了信息窃取的恶意软件。</p><h1 id="发现了什么？"><a href="#发现了什么？" class="headerlink" title="发现了什么？"></a>发现了什么？</h1><p>一些威胁者开发了一个看起来合法的网站，伪装成隐私工具服务，声称提供实用工具来保护个人和商业数据。</p><ul><li>这个所谓的隐私工具服务被宣传为一个类似zip的实用工具，可以加密用户数据确保安全。</li><li>该网站提供了有关所谓服务的详细信息，包括指导用户下载和使用隐私工具的分步说明。</li><li>按照指示，受害者最终会安装Smoke Loader恶意软件，它是一个具有多种功能的模块化下载器。<br>Smoke Loader工具进一步下载了两个数据窃取的恶意软件：Redline和Raccoon Stealer。</li></ul><h1 id="最近的信息窃取者攻击"><a href="#最近的信息窃取者攻击" class="headerlink" title="最近的信息窃取者攻击"></a>最近的信息窃取者攻击</h1><p>在过去的一段时间里，有几个攻击者被观察到通过使用虚假的假装或其他方法来引诱他们的受害者来传播信息窃取恶意软件。</p><ul><li>在上个月，一些攻击者被发现滥用谷歌搜索结果中的一些点击付费（PPC）广告，会下载恶意的AnyDesk、Dropbox和Telegram软件包。这些假的应用程序最终会使受害者感染Redline、Taurus、Tesla和Amadey信息窃取者恶意软件。</li><li>早些时候，一些威胁者被发现滥用微软Build（MSBuild）引擎，用Remcos RAT和Quasar RAT以及RedLine Stealer感染受害者。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>最新的活动揭示了攻击者在使这种以隐私为主题的诱饵变得现实和有效方面所付出的越来越多的努力。此外，信息窃取越来越多，引起了人们对地下黑市中私人信息不断增长的需求的担忧。因此，建议用户通过使用可靠的反恶意软件解决方案提供保护。</p>]]></content>
    
    
    <summary type="html">打着安全的幌子公然给客户安装恶意软件


最近，来自Proofpoint的研究人员发现了一种新的网络安全威胁，它试图用一个看起来很专业的网站的虚假幌子来欺骗人们，声称可以提供更强的安全性。这种伪装可以说是一种讽刺，因为它实际上最终在受害者的机器上部署了信息窃取的恶意软件。

发现了什么？
一些威胁者开发了一个看起来合法的网站，伪装成隐私工具服务，声称提供实用工具来保护个人和商业数据。

 * 这个所谓的隐私工具服务被宣传为一个类似zip的实用工具，可以加密用户数据确保安全。
 * 该网站提供了有关所谓服务的详细信息，包括指导用户下载和使用隐私工具的分步说明。
 * 按照指示，受害者最终会安装S</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://dianwoshishi.github.io/2021/07/07/%E5%B7%A5%E4%B8%9A%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E6%88%90%E4%B8%BA%E7%BD%91%E7%BB%9C%E7%8A%AF%E7%BD%AA%E5%9B%A2%E4%BC%99%E7%9A%84%E2%80%9C%E6%91%87%E9%92%B1%E6%A0%91%E2%80%9D/"/>
    <id>http://dianwoshishi.github.io/2021/07/07/%E5%B7%A5%E4%B8%9A%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E6%88%90%E4%B8%BA%E7%BD%91%E7%BB%9C%E7%8A%AF%E7%BD%AA%E5%9B%A2%E4%BC%99%E7%9A%84%E2%80%9C%E6%91%87%E9%92%B1%E6%A0%91%E2%80%9D/</id>
    <published>2021-07-07T01:29:11.000Z</published>
    <updated>2021-07-07T01:29:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="工业控制系统成为网络犯罪团伙的“摇钱树”，需加强网络安全防范"><a href="#工业控制系统成为网络犯罪团伙的“摇钱树”，需加强网络安全防范" class="headerlink" title="工业控制系统成为网络犯罪团伙的“摇钱树”，需加强网络安全防范"></a>工业控制系统成为网络犯罪团伙的“摇钱树”，需加强网络安全防范</h2><p><img src="https://cyware-ent.s3.amazonaws.com/image_bank/shutterstock_305983283.jpg" alt="Attackers Accelerating Ransomware Attacks on ICS Networks"></p><p>在过去的一年中，勒索软件攻击正在以全世界的工业控制系统（ICS）终端为目标，迅速发展。Trend Micro的网络安全研究人员的一份报告强调了这一主导趋势。</p><h2 id="不断变化的威胁形势"><a href="#不断变化的威胁形势" class="headerlink" title="不断变化的威胁形势"></a>不断变化的威胁形势</h2><p>支持水和电力等重要公用事业的ICS网络需要完全运行以提供服务。这种网络瘫痪的时间越长，造成的破坏就越大。</p><ul><li>根据该报告，最近的勒索软件攻击只是出于经济上的动机，因为通过打击运营中的工厂和制造环境中的ICS网络有很高的机会迅速获得赎金。</li><li>网络犯罪分子使用了几种不同类型的针对ICS的勒索软件。其中，四个系列的勒索软件（Ryuk、Nefilm、Revil和LockBit）占这些攻击的一半以上。</li><li>根据该报告，美国是影响ICS的勒索软件案件最多的目标国家之一。其他受影响的国家包括印度和西班牙。</li></ul><h2 id="最近对ICS的攻击"><a href="#最近对ICS的攻击" class="headerlink" title="最近对ICS的攻击"></a>最近对ICS的攻击</h2><p>最近已经观察到一些针对主要行业的勒索软件攻击。这种对主要行业的OT和ICS系统的破坏导致了严重的结果和巨额资金的损失。</p><ul><li>美国水务公司WSSC Water在其网络上遭到勒索软件攻击，黑客可以访问内部文件。客户被警告要监控他们的金融交易。</li><li>上个月，一家食品加工公司JBS USA确认成为REvil勒索软件攻击的受害者，该攻击使其OT/ICS系统停止运行，造成严重损失。</li><li>最近对Colonial Pipeline的DarkSide勒索软件攻击表明，针对工业目标的勒索软件攻击可以对整个国家产生非常危险的后果。</li></ul><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>用于国家关键基础设施、制造业和其他设施的ICS一直是攻击者的软目标，因为许多这些系统仍在运行旧的操作系统版本和未修补的应用程序。因此，需要做更多的工作来保护工业设施的网络免受这种日益增长的威胁。</p>]]></content>
    
    
    <summary type="html">工业控制系统成为网络犯罪团伙的“摇钱树”，需加强网络安全防范


在过去的一年中，勒索软件攻击正在以全世界的工业控制系统（ICS）终端为目标，迅速发展。Trend Micro的网络安全研究人员的一份报告强调了这一主导趋势。

不断变化的威胁形势
支持水和电力等重要公用事业的ICS网络需要完全运行以提供服务。这种网络瘫痪的时间越长，造成的破坏就越大。

 * 根据该报告，最近的勒索软件攻击只是出于经济上的动机，因为通过打击运营中的工厂和制造环境中的ICS网络有很高的机会迅速获得赎金。
 * 网络犯罪分子使用了几种不同类型的针对ICS的勒索软件。其中，四个系列的勒索软件（Ryuk、Nefilm、R</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://dianwoshishi.github.io/2021/07/07/%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E6%8A%95%E6%94%BE%EF%BC%9A%E4%B8%8D%E5%AE%B9%E5%BF%BD%E8%A7%86%E7%9A%84%E4%BC%AA%E8%A3%85%E5%A8%81%E8%83%81/"/>
    <id>http://dianwoshishi.github.io/2021/07/07/%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E6%8A%95%E6%94%BE%EF%BC%9A%E4%B8%8D%E5%AE%B9%E5%BF%BD%E8%A7%86%E7%9A%84%E4%BC%AA%E8%A3%85%E5%A8%81%E8%83%81/</id>
    <published>2021-07-07T01:23:27.000Z</published>
    <updated>2021-07-07T01:23:27.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="恶意软件投放：不容忽视的伪装威胁"><a href="#恶意软件投放：不容忽视的伪装威胁" class="headerlink" title="恶意软件投放：不容忽视的伪装威胁"></a>恶意软件投放：不容忽视的伪装威胁</h1><p><img src="https://cyware-ent.s3.amazonaws.com/image_bank/6e20_shutterstock_667515631.jpg" alt="Malware Dropper: A Threat in Disguise That Cannot be Ignored"></p><p>企业正受到恶意软件投放器(dropper)的打击，这种投放器使得攻击者能够进行多阶段的攻击。这使得企业面临更高的恶意软件威胁、数据被盗和系统被破坏等风险。</p><h2 id="什么是恶意软件投放器"><a href="#什么是恶意软件投放器" class="headerlink" title="什么是恶意软件投放器"></a>什么是恶意软件投放器</h2><p>Droppers是特洛伊木马的一种类型。它们的标志性目的是，一旦它们出现在一个系统中，就安装其他恶意软件。事实上，它们被命名为投放器(droppers )，因为它们将恶意软件和恶意软件组件投放到一个被破坏的系统中。这种活动为投放者赢得了 “催生恶意软件的恶意软件 “的绰号。</p><p>为了更好地避免被发现，投放者通常不会保存到被攻击系统的磁盘上。相反，投放者通常在其目的达到后自行删除。它们在推进攻击目标的过程中经常执行不同的行动。</p><h2 id="传播方式"><a href="#传播方式" class="headerlink" title="传播方式"></a>传播方式</h2><p>droppers 程序可以通过多种方式传播。最常见的外挂程序传播方式包括。</p><ul><li>访问恶意网站</li><li>点击恶意链接</li><li>垃圾邮件的附件</li><li>插入受感染的可移动媒体</li><li>使用受感染的互联网代理</li><li>下载受感染的免费软件</li></ul><p>droppers 也可能通过受感染的应用程序传播–甚至是那个广泛使用的、看似合法的应用程序。研究人员最近发现，CamScanner，一个下载量超过1亿的流行的安卓应用，已经有一段时间在其中隐藏了一个droppers 程序。</p><h2 id="最新的恶意软件投放器活动"><a href="#最新的恶意软件投放器活动" class="headerlink" title="最新的恶意软件投放器活动"></a>最新的恶意软件投放器活动</h2><p>Proofpoint研究人员剖析了JSSLoader恶意软件的一个新变种，它为威胁者提供了躲避检测和加载额外有效载荷(payload)的机会。</p><ul><li>在另一项研究中，Proofpoint发现了一个新的Smoke Loader活动，该活动将Raccoon Stealer和RedLine等窃取数据的恶意软件作为最终的有效载荷。该活动的初始感染过程涉及将受害者引诱到一个提供商业和个人使用的隐私工具的虚假网站。</li><li>Sload，也被称为Starslord loader，在针对欧洲、英国和意大利的多个供应商的恶意活动中被发现。恶意软件创建者使用VBS和PowerShell等脚本作为其最初立足点(initial foothold)的一部分，诱使用户执行加载器。</li><li>一种名为Matanbuchus Loader的新恶意软件即服务，能够从C2基础设施中投放第二阶段的恶意软件，也被各种攻击者使用。</li></ul><h2 id="下载器的发展造成了更大的破坏"><a href="#下载器的发展造成了更大的破坏" class="headerlink" title="下载器的发展造成了更大的破坏"></a>下载器的发展造成了更大的破坏</h2><ul><li>不仅JSSLoader已经进化到为其操作者提供多阶段攻击的多种选择，而且另一个名为Buer Loader的恶意软件下载器也已被改造，以帮助在不被发现的情况下在被攻击的系统中获得立足点。</li><li>Proofpoint发现，名为RustyBuer的新变种已经影响到全球50多个垂直行业的200多个组织。</li></ul><h2 id="基于TLS的恶意流量"><a href="#基于TLS的恶意流量" class="headerlink" title="基于TLS的恶意流量"></a>基于TLS的恶意流量</h2><ul><li>在Sophos进行的一项研究中，研究人员发现，初始阶段的恶意软件，如加载器（loaders）、投放器（droppers）和基于文件的安装器（installers ），在很大程度上依赖于恶意的TLS流量，以确保他们对受害者机器的访问。</li><li>Sophos解释说，使用TLS是一种逃避基本有效载荷检查的方式。此外，在恶意软件投放器中利用该协议并不需要太复杂，因为支持TLS的基础设施可以有效提供恶意软件或恶意代码片段。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Droppers 是一种著名的恶意软件类型，从特洛伊木马的早期就已经存在了。除了下载和安装恶意软件外，人们还观察到攻击者表现出不同的行为，使其与其他恶意软件不同。这些行为包括搜索可用的安全控件，连接到可疑的网站，并试图隐藏与网站的连接。此外，随着勒索软件和持续的恶意电子邮件威胁的增加，预计加载器的存在越来越多，可能会见证一个上升。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://resources.infosecinstitute.com/topic/malware-spotlight-droppers/">https://resources.infosecinstitute.com/topic/malware-spotlight-droppers/</a></p>]]></content>
    
    
    <summary type="html">恶意软件投放：不容忽视的伪装威胁


企业正受到恶意软件投放器(dropper)的打击，这种投放器使得攻击者能够进行多阶段的攻击。这使得企业面临更高的恶意软件威胁、数据被盗和系统被破坏等风险。

什么是恶意软件投放器
Droppers是特洛伊木马的一种类型。它们的标志性目的是，一旦它们出现在一个系统中，就安装其他恶意软件。事实上，它们被命名为投放器(droppers )，因为它们将恶意软件和恶意软件组件投放到一个被破坏的系统中。这种活动为投放者赢得了 “催生恶意软件的恶意软件 “的绰号。

为了更好地避免被发现，投放者通常不会保存到被攻击系统的磁盘上。相反，投放者通常在其目的达到后自行删除。它</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://dianwoshishi.github.io/2021/07/07/%E7%BE%8E%E5%B0%86%E7%AB%8B%E6%B3%95%E5%BB%BA%E7%AB%8B%E6%A0%87%E5%87%86%E5%8C%96%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%B9%E8%AE%AD%EF%BC%8C%E9%98%B2%E8%8C%83%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%81/"/>
    <id>http://dianwoshishi.github.io/2021/07/07/%E7%BE%8E%E5%B0%86%E7%AB%8B%E6%B3%95%E5%BB%BA%E7%AB%8B%E6%A0%87%E5%87%86%E5%8C%96%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%B9%E8%AE%AD%EF%BC%8C%E9%98%B2%E8%8C%83%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%81/</id>
    <published>2021-07-07T01:05:10.000Z</published>
    <updated>2021-07-07T01:05:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《供应链安全培训法》-美将立法建立标准化网络安全培训，防范网络安全威胁"><a href="#《供应链安全培训法》-美将立法建立标准化网络安全培训，防范网络安全威胁" class="headerlink" title="《供应链安全培训法》:美将立法建立标准化网络安全培训，防范网络安全威胁"></a>《供应链安全培训法》:美将立法建立标准化网络安全培训，防范网络安全威胁</h1><p><img src="https://130e178e8f8ba617604b-8aedd782b7d22cfe0d1146da69a52436.ssl.cf1.rackcdn.com/senate-bill-proposes-cyber-training-for-federal-employees-showcase_image-5-a-16982.png" alt="Sen. Gary Peters, D-Mich. (left), 和 Sen. Ron Johnson, R-Wis."></p><p>美参议院提出的一项两党法案，将为采购技术服务(注：购买信息设备及服务)的联邦雇员创建一个标准化的网络安全培训计划。</p><p>支持该立法提案的立法者说，这将有助于美国政府防范安全威胁和其他供应链的脆弱性。</p><p>该法案名为《供应链安全培训法》( Supply Chain Security Training Act)，由担任参议院国土安全和政府事务委员会主席的密歇根州参议员加里-彼得斯和担任该委员会成员的威斯康星州议员罗恩-约翰逊提出。该法案将指示美国总务管理局与国土安全部、国防部和管理与预算办公室协调，为负有采购的联邦官员创建一个供应链安全培训。该法案还将要求管理和预算局为联邦机构采用和使用该计划制定指南。</p><h2 id="进入美政府系统的-“后门"><a href="#进入美政府系统的-“后门" class="headerlink" title="进入美政府系统的 “后门"></a>进入美政府系统的 “后门</h2><p>彼得斯强调了这项措施的国家安全重要性，告诫威胁者不要进入美国系统。</p><p>“彼得斯说：”最近针对美国网络的攻击表明，我们的外国对手和犯罪组织将不惜一切代价入侵网络，窃取信息并破坏我们的国家安全。”联邦雇员在购买软件和设备时，需要知道如何识别可能的威胁，因为这些软件和设备可能会让坏人有后门进入政府信息系统。”</p><p>彼得斯说，该法案将有助于加强政府的安全态势。</p><h2 id="最近的攻击"><a href="#最近的攻击" class="headerlink" title="最近的攻击"></a>最近的攻击</h2><p>拟议的立法是在最近一连串的攻击之后提出的，包括2020年12月检测到的SolarWinds供应链攻击。据报道，该活动导致9个美国机构（包括财政部和商务部）以及100家公司（包括微软、SolarWinds和VMWare）遭到后续攻击。</p><p>5月，Colonial Pipeline Co.的管道横跨东海岸，成为勒索软件攻击的受害者，导致该公司暂时停止运营。Colonial Pipeline随后向据说在东欧运作的犯罪集团DarkSide支付了440万美元的赎金，以获得一个解密器。联邦调查局后来追回了230万美元的赎金。</p><p>同样在5月，肉类加工巨头JBS遭受了勒索软件攻击，中断了在美国、加拿大和澳大利亚的业务。联邦调查局将这次攻击归咎于REvil，又称Sodinokibi，这是一个勒索软件即服务（ransomware-as-a-service）的操作。JBS后来表示，它向犯罪团伙支付了价值1100万美元的加密货币。</p><p>而在最近几天，出现了关于REvil供应链勒索软件攻击软件供应商Kaseya的细节，该攻击可能已经影响到全球多达1500个组织。</p><p>约翰逊在评论拟议的法案时说：”在我们的对手正在探测网络漏洞以破坏我们的系统和窃取信息的时候，对为政府购买和销售商品和服务的联邦工作人员进行反情报培训至关重要。这种类型的培训将有助于弥补我们在网络和物理安全防御方面的差距。”</p><p>彼得斯和约翰逊在2019年提出了类似的立法。那项法案得到了参议院的批准，但没有得到众议院的投票，其目的是让联邦人员做好准备，以识别和减轻在软件采购过程中出现的反情报威胁。</p><h2 id="建立在行政命令基础之上"><a href="#建立在行政命令基础之上" class="headerlink" title="建立在行政命令基础之上"></a>建立在行政命令基础之上</h2><p>新的提案希望建立在乔-拜登总统于5月12日发布的网络安全行政命令的基础上，该命令要求政府部门为软件建立基线安全标准–包括应用程序的可见性和对安全数据的访问。该指令还要求供应商在开发过程中纳入安全性。此外，将创建一个新的标签，类似于能源之星的标签，供政府和私营企业确定软件是否是安全开发的）。</p><p>在关于该行政命令的补充文件中，白宫指出：”我们有太多的软件，包括关键软件，存在严重的漏洞，被我们的对手所利用。” 利用联邦政府的购买力，政府希望 “从头开始在所有软件中建立安全”。</p>]]></content>
    
    
    <summary type="html">《供应链安全培训法》:美将立法建立标准化网络安全培训，防范网络安全威胁


美参议院提出的一项两党法案，将为采购技术服务(注：购买信息设备及服务)的联邦雇员创建一个标准化的网络安全培训计划。

支持该立法提案的立法者说，这将有助于美国政府防范安全威胁和其他供应链的脆弱性。

该法案名为《供应链安全培训法》( Supply Chain Security Training Act)，由担任参议院国土安全和政府事务委员会主席的密歇根州参议员加里-彼得斯和担任该委员会成员的威斯康星州议员罗恩-约翰逊提出。该法案将指示美国总务管理局与国土安全部、国防部和管理与预算办公室协调，为负有采购的联邦官员创建一个</summary>
    
    
    
    
  </entry>
  
</feed>
