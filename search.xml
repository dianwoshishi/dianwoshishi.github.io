<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>关于RFC文档有趣的事情</title>
    <url>/2021/05/27/%E5%85%B3%E4%BA%8ERFC%E6%96%87%E6%A1%A3%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8B%E6%83%85/</url>
    <content><![CDATA[<p>原文为知乎<a href="https://zhuanlan.zhihu.com/p/337997798">文章</a>， 现转移到个人博客。</p>
<h1 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h1><ol>
<li> <a href="#org34ce3f0">事情的起源</a></li>
<li><a href="#orgbd0ef9b">研究经过</a><ol>
<li> <a href="#orgd742468">查询相关资料</a></li>
<li> <a href="#org7b36c8c">查询相关RFC</a></li>
<li><a href="#orge2e0fc8">一个想法</a><ol>
<li> <a href="#org3061772">第一个发现</a></li>
<li> <a href="#org4e04c37">第二个发现</a></li>
<li> <a href="#org2636b5a">第三个发现</a></li>
<li> <a href="#org9ff55be">第四个发现</a></li>
</ol>
</li>
</ol>
</li>
<li> <a href="#org9564d4b">总结</a></li>
</ol>
<p><a id="org34ce3f0"></a></p>
<h1 id="事情的起源"><a href="#事情的起源" class="headerlink" title="事情的起源"></a>事情的起源</h1><p>一次被问起，为何TLSv1.0(RFC2246),TLSv1.1(RFC4346),TLSv1.2(RFC5246),TLSv1.3(RFC8446)中的RFC编号都是以64结尾。印象中关于RFC编号都是递增的，因为RFC写好之后就不允许再修改了，如果有新的标准出来，只能在其后某个编号出现，并且引用之前的RFC。<br>但是上述这个问题，TLS四个版本均以64结尾，也太凑巧了，确实很让人疑惑。本着好奇，去研究了研究这事。</p>
<p>&lt;！–more–&gt;</p>
<p><a id="orgbd0ef9b"></a></p>
<h1 id="研究经过"><a href="#研究经过" class="headerlink" title="研究经过"></a>研究经过</h1><p><a id="orgd742468"></a></p>
<h2 id="查询相关资料"><a href="#查询相关资料" class="headerlink" title="查询相关资料"></a>查询相关资料</h2><p>首先在网上搜索为什么TLS均以64结尾，网上的回答基本上来自如下解释</p>
<blockquote>
<p>In the IETF, protocols are called RFCs. TLS 1.0 was RFC 2246, TLS 1.1 was RFC 4346, and TLS 1.2 was RFC 5246. Today, TLS 1.3 was published as RFC 8446. RFCs are generally published in order, keeping 46 as part of the RFC number is a nice touch<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup>.</p>
</blockquote>
<p>显然，并没有解决我们的问题。</p>
<p><a id="org7b36c8c"></a></p>
<h2 id="查询相关RFC"><a href="#查询相关RFC" class="headerlink" title="查询相关RFC"></a>查询相关RFC</h2><p>思考是否会有某个RFC对这事做了说明吗？查询未果。<br>但是在此过程中，我发现了在RFC文档中，有相邻两个递增编号文档，但是RFC时间并不递增的现象。举个例子</p>
<blockquote>
<p>1478 An Architecture for Inter-Domain Policy Routing. M. Steenstrup. June</p>
<ol>
<li> (Format: TXT, HTML) (Status: HISTORIC) (DOI: 10.17487/RFC1478)</li>
</ol>
<p>1479 Inter-Domain Policy Routing Protocol Specification: Version 1. M.<br>     Steenstrup. July 1993. (Format: TXT, HTML) (Status: HISTORIC) (DOI:<br>     10.17487/RFC1479) </p>
<p>1480 The US Domain. A. Cooper, J. Postel. June 1993. (Format: TXT, HTML)<br>     (Obsoletes RFC1386) (Status: INFORMATIONAL) (DOI: 10.17487/RFC1480) </p>
</blockquote>
<p>其中RFC1478的时间为1993年6月，RFC1479的时间为1993年7月，但是RFC1480的时间为1993年6月，出现了非递增的情况。</p>
<p>虽然又发现，但好像并没有什么卵用。但是自然会想到，有可能时间上有大的反复吗？有年的反复现象吗？</p>
<p><a id="orge2e0fc8"></a></p>
<h2 id="一个想法"><a href="#一个想法" class="headerlink" title="一个想法"></a>一个想法</h2><p><a id="org3061772"></a></p>
<h3 id="第一个发现"><a href="#第一个发现" class="headerlink" title="第一个发现"></a>第一个发现</h3><p>所以就想分析分析RFC文档的编号的时间问题。第一想法是爬虫，但是工作量太复杂。左搜索右搜索，找到了官网提供的XML版列表<sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup>.超级开心。然后写了个python脚本，自动进行了分析(忽略并不想改的变量名，来自一个豆瓣电影爬虫)。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#!/usr/bin/python3</span>
<span class="token keyword">import</span> calendar
<span class="token keyword">from</span> xml<span class="token punctuation">.</span>dom<span class="token punctuation">.</span>minidom <span class="token keyword">import</span> parse
<span class="token keyword">import</span> xml<span class="token punctuation">.</span>dom<span class="token punctuation">.</span>minidom

<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np
<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt 

<span class="token comment"># 使用minidom解析器打开 XML 文档</span>
DOMTree <span class="token operator">=</span> xml<span class="token punctuation">.</span>dom<span class="token punctuation">.</span>minidom<span class="token punctuation">.</span>parse<span class="token punctuation">(</span><span class="token string">"rfc-index.xml"</span><span class="token punctuation">)</span>
collection <span class="token operator">=</span> DOMTree<span class="token punctuation">.</span>documentElement
<span class="token keyword">if</span> collection<span class="token punctuation">.</span>hasAttribute<span class="token punctuation">(</span><span class="token string">"shelf"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
   <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">"Root element : %s"</span> <span class="token operator">%</span> collection<span class="token punctuation">.</span>getAttribute<span class="token punctuation">(</span><span class="token string">"shelf"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment"># 在集合中获取所有电影</span>
movies <span class="token operator">=</span> collection<span class="token punctuation">.</span>getElementsByTagName<span class="token punctuation">(</span><span class="token string">"rfc-entry"</span><span class="token punctuation">)</span>

<span class="token comment"># 打印每部电影的详细信息</span>
<span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">"*****Movie*****"</span><span class="token punctuation">)</span>
x <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
years <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
months <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
total <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> movie <span class="token keyword">in</span> movies<span class="token punctuation">:</span>

   <span class="token builtin">type</span> <span class="token operator">=</span> movie<span class="token punctuation">.</span>getElementsByTagName<span class="token punctuation">(</span><span class="token string">'doc-id'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>childNodes<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>data

   <span class="token builtin">id</span> <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token builtin">type</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   x<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token builtin">id</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">#    print ("doc-id: %d" % id)</span>
<span class="token comment">#    author = movie.getElementsByTagName('author')[0]</span>
<span class="token comment">#    print ("author: %s" % author.childNodes[1].data)</span>
   date <span class="token operator">=</span> movie<span class="token punctuation">.</span>getElementsByTagName<span class="token punctuation">(</span><span class="token string">'date'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
   month <span class="token operator">=</span> date<span class="token punctuation">.</span>getElementsByTagName<span class="token punctuation">(</span><span class="token string">'month'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>childNodes<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">;</span>
   int_month <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token builtin">list</span><span class="token punctuation">(</span>calendar<span class="token punctuation">.</span>month_name<span class="token punctuation">)</span><span class="token punctuation">.</span>index<span class="token punctuation">(</span>month<span class="token punctuation">)</span><span class="token punctuation">)</span>
   months<span class="token punctuation">.</span>append<span class="token punctuation">(</span>int_month<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">#    print ("date month: %d" % int_month)</span>
   year <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>date<span class="token punctuation">.</span>getElementsByTagName<span class="token punctuation">(</span><span class="token string">'year'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>childNodes<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">#    print ("date year: %d" % year)</span>
   years<span class="token punctuation">.</span>append<span class="token punctuation">(</span>year<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">#    description = movie.getElementsByTagName('description')[0]</span>
<span class="token comment">#    print ("Description: %s" % description.childNodes[0].data)</span>
   total<span class="token punctuation">.</span>append<span class="token punctuation">(</span>year <span class="token operator">+</span> <span class="token number">10</span>  <span class="token operator">+</span> int_month  <span class="token punctuation">)</span>

plt<span class="token punctuation">.</span>rcParams<span class="token punctuation">[</span><span class="token string">'font.sans-serif'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'Arial Unicode MS'</span><span class="token punctuation">]</span>
plt<span class="token punctuation">.</span>rcParams<span class="token punctuation">[</span><span class="token string">'axes.unicode_minus'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">False</span>   <span class="token comment"># 解决保存图像是负号'-'显示为方块的问题</span>
plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">"Matplotlib"</span><span class="token punctuation">)</span> 
plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span><span class="token string">"RFC编号"</span><span class="token punctuation">)</span> 
plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span><span class="token string">"年份"</span><span class="token punctuation">)</span> 

plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x<span class="token punctuation">,</span>years<span class="token punctuation">,</span> label<span class="token operator">=</span><span class="token string">r'年'</span><span class="token punctuation">)</span> 
plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x<span class="token punctuation">,</span>total<span class="token punctuation">,</span> label<span class="token operator">=</span><span class="token string">r'年 + 月 + 10(向上平移10)'</span><span class="token punctuation">)</span> 
<span class="token comment"># plt.subplot(2,1,1)</span>
<span class="token comment"># plt.plot(x,years) </span>
<span class="token comment"># plt.subplot(2,1,2)</span>
<span class="token comment"># plt.plot(x,months) </span>
plt<span class="token punctuation">.</span>legend<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

plt<span class="token punctuation">.</span>grid<span class="token punctuation">(</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>经过经过分析有了如下所示图：<br><img src="/2021/05/27/%E5%85%B3%E4%BA%8ERFC%E6%96%87%E6%A1%A3%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8B%E6%83%85/%E5%B9%B4%E4%BB%BD%E5%9B%BE.png" alt="img"><br>果然有问题！！！！上图横坐标为RFC编号，纵坐标为RFC编号对应的年份。可以看出RFC文档从一九六几年到今天一共发表8000余份。有意思的是，其中有一些凸起的部分，就是一些异常点。例如2000年前有一个极高的凸起，这代表这个编号的年份远远超出这个编号附近的年份，这与我们的常识不符。实际上，查看这个异常点，如下图所示：<br><img src="/2021/05/27/%E5%85%B3%E4%BA%8ERFC%E6%96%87%E6%A1%A3%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8B%E6%83%85/image-20201218225458777.png" alt="img"><br>其中RFC1849的年份为2010年，但其附近的RFC文档编号均为1995年，其中相差15年，造成第一幅图中的凸起。</p>
<p><a id="org4e04c37"></a></p>
<h3 id="第二个发现"><a href="#第二个发现" class="headerlink" title="第二个发现"></a>第二个发现</h3><p>同时，我们还会发现另一个有意思的现象。如下图所示：<br><img src="/2021/05/27/%E5%85%B3%E4%BA%8ERFC%E6%96%87%E6%A1%A3%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8B%E6%83%85/%E6%95%B4%E6%95%B0%E9%97%B4%E9%9A%94%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="整数间隔示意图"><br>其中编号为1299，1399，1499，1599，1699,&#x2026;等，均出现凸起现象。并且实际上1299，1399，1499，1599，1699，1799，1899，1999的年份均为1997年。存在明显的人为痕迹。</p>
<p><a id="org2636b5a"></a></p>
<h3 id="第三个发现"><a href="#第三个发现" class="headerlink" title="第三个发现"></a>第三个发现</h3><p>年份和月份基本满足递增，但是有波动。如下图所示：<br><img src="/2021/05/27/%E5%85%B3%E4%BA%8ERFC%E6%96%87%E6%A1%A3%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8B%E6%83%85/%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="img"><br>放大后：<br><img src="/2021/05/27/%E5%85%B3%E4%BA%8ERFC%E6%96%87%E6%A1%A3%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8B%E6%83%85/%E7%A4%BA%E6%84%8F%E5%9B%BE%E6%94%BE%E5%A4%A7.png" alt="img"><br>为方便对比，将其中月份显示为（年+月，再向上平移10个单位(年)）。</p>
<p><a id="org9ff55be"></a></p>
<h3 id="第四个发现"><a href="#第四个发现" class="headerlink" title="第四个发现"></a>第四个发现</h3><p>TLS的主要作者，目前是Eric Rescorla。对TLS四个版本作者做简单统计，如下图：<br><img src="/2021/05/27/%E5%85%B3%E4%BA%8ERFC%E6%96%87%E6%A1%A3%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8B%E6%83%85/image-20201218231640006.png" alt="img"><br>可以看出，最开始Tim Dierks逐渐从第二作者，向第一作者上升，此时带了个徒弟。慢慢Tim Dierks开始退居二线，Eric Rescorla开始独挡一面（纯属胡说八道）。</p>
<p><a id="org9564d4b"></a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>虽然并没有直接的证据来回答开头提出的问题，但是我们可以发现以下现象：</p>
<ul>
<li>  RFC的编号并非严格的时间递增，而是存在一些波动</li>
<li>  RFC的编号中存在一些，小概率发生的现象，例如等间隔凸起</li>
</ul>
<p>基于以上现象呢，我们可以大胆猜测（hu shuo ba dao）：</p>
<ul>
<li>  RFC编号的审批机构，会因为某些原因，保留一些编号</li>
<li>  RFC的编号其实并没有想象中的那么严格</li>
<li>  大佬在RFC编号中具有一定的发言权，可以”预定“一些编号。如TLSv1，2，3，4以64结尾</li>
</ul>
<h1 id="Footnotes"><a href="#Footnotes" class="headerlink" title="Footnotes"></a>Footnotes</h1><p><sup><a id="fn.1" href="#fnr.1">1</a></sup> <a href="https://blog.cloudflare.com/rfc-8446-aka-tls-1-3/">https://blog.cloudflare.com/rfc-8446-aka-tls-1-3/</a></p>
<p><sup><a id="fn.2" href="#fnr.2">2</a></sup> <a href="https://www.rfc-editor.org/rfc-index.xml">https://www.rfc-editor.org/rfc-index.xml</a></p>
]]></content>
      <categories>
        <category>研究</category>
      </categories>
      <tags>
        <tag>RFC</tag>
        <tag>编号</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>区块链中的密码学知识</title>
    <url>/2021/05/28/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%AD%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>原文为<a href="https://zhuanlan.zhihu.com/p/304725930">知乎</a>，现转移到个人博客。<br><a href="https://zhuanlan.zhihu.com/p/304725930" target="_blank" class="LinkCard">知乎原文</a><br>转发微信公众号<a href="https://mp.weixin.qq.com/s/NkAWmPokc86Jc6nWtz4-yA">文章</a><br><a href="https://mp.weixin.qq.com/s/NkAWmPokc86Jc6nWtz4-yA" target="_blank" class="LinkCard">微信公众号原文</a></p>
<h1 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h1><ol>
<li> <a href="#org63a3294">BitCoin是什么</a></li>
<li> <a href="#org1839db4">密码学是什么</a></li>
<li><a href="#org44c3a48">BitCoin中的密码学知识</a><pre><code> 1.  [哈希(Hash)](#org87067ef)
     2.  [公钥密码体制](#orgb205e36)
</code></pre>
</li>
<li> <a href="#org60092e2">总结</a></li>
<li> <a href="#orga6c2764">Reference</a></li>
</ol>
<p><a id="org63a3294"></a></p>
<h1 id="BitCoin是什么"><a href="#BitCoin是什么" class="headerlink" title="BitCoin是什么"></a>BitCoin是什么</h1><p>BitCoin，又称比特币，是2009年中本聪提出了一种点对点的数字现金系统，是一种分布式、点对点的货币,允许在线的交易不用经过中心化机构（如银行，支付宝）的情况下，在网络合作支持下，直接由一个用户发往另一个用户,并且可以提供防篡改，可验证的能力。<br>Bitcoin是最早实现“加密货币”这一概念的系统，该设想最早由戴伟（Dai Wei<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup>,音译）于1998年在cypherpunks函件用户组首次提出的:货币可以是任何东西或记录，只要它在一个国家或社会经济体系内被接受为商品服务的支付方式，或是债务偿还的方式。<br>比特币的设计核心思想是以密码学难题(cryptography puzzle)答案作为货币，其发行权独立于任何中央机构之外。</p>
<p>比特币使用了公开密钥系统<sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup>. 每一个钱币都包括了其拥有者的公开秘钥。当钱币从用户A支付给用户B时, A将B的公开秘钥添加到钱币中, 然后这个钱币又被A用私人密码匙来签名。B现在即拥有了这个钱币并且可以将来使用，而A就不可能再次使用这个钱币，因为以前的交易记录以被全体网络计算机记录。在每笔交易前，钱币的有效性都必须经过检验确认。</p>
<p><a id="org1839db4"></a></p>
<h1 id="密码学是什么"><a href="#密码学是什么" class="headerlink" title="密码学是什么"></a>密码学是什么</h1><p>密码学是一种使用先进的数学原理以特定的形式存储和传输数据的方法，以便只有它的目标用户能够读取和处理数据。密码学已经被人们用来在不被发现的情况下转发信息。随着互联网及信息技术的飞速发展，密码学被赋予了新的含义。密码哈希，电子签名等被广泛使用在防篡改，身份认证等场合。当前有三种广泛使用的加密形式：对称加密、非对称加密和哈希。</p>
<p><a id="org44c3a48"></a></p>
<h1 id="BitCoin中的密码学知识"><a href="#BitCoin中的密码学知识" class="headerlink" title="BitCoin中的密码学知识"></a>BitCoin中的密码学知识</h1><p>在中本聪的Bitcoin: A Peer-to-Peer Electronic Cash System一文中我们可以看见如下一段话，从这段话中我们可以看出密码学在BitCoin中的应用：</p>
<blockquote>
<p>We define an electronic coin as a chain of <strong><strong>digital signatures</strong></strong>. Each owner transfers the coin to the next by digitally <strong><strong>signing</strong></strong> a <strong><strong>hash</strong></strong> of the previous transaction and the <strong><strong>public key</strong></strong> of the next owner and adding these to the end of the coin. A payee can <strong><strong>verify the signatures</strong></strong> to verify the chain of ownership.——Bitcoin: A Peer-to-Peer Electronic Cash System[1]</p>
</blockquote>
<p>下面就主要从哈希和 公钥密码体制两个方面介绍BitCoin中的密码学知识。</p>
<p><a id="org87067ef"></a></p>
<h3 id="哈希-Hash"><a href="#哈希-Hash" class="headerlink" title="哈希(Hash)"></a>哈希(Hash)</h3><p>哈希（有时称“摘要”,密码散列,Hashing）是文本或数据文件的经过压缩的一种”指纹”。 Hash函数是把任意长度的输入通过散列函数或者说是hash函数转化为固定长度的输出的一种算法。这个输入区间可以无穷大，但输出区间是固定的。比如输入可以是任意的，输出是一个3位数。<br>这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来确定唯一的输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。</p>
<p>BitCoin中的hash函数主要有SHA-256，RIPEME-160，hash的一个主要应用是Merkle树,其中算法前缀“SHA”和”RIPEMD”表示基础算法，数字后缀”256”和”160”表示输出的固定长度。 </p>
<p>在比特币协议中，SHA256和RIPEMD160一起用于保护数字签名中使用的公钥。SHA256方法也用于比特币挖掘中的工作函数证明，并作为数字签名算法的一部分。</p>
<ol>
<li><p>SHA-256</p>
<p> SHA就是安全哈希算法（Secure Hash Algorithm）的简写。SHA-256为文本生成几乎唯一的256位（32字节）签名。<br> 另外，比特币挖矿（mining）的cryptograph puzzle也是通过计算满足一定条件的hash来完成的，例如计算的满足256bit位hash前缀满足60个0(由区块链中区块内部的nonce决定)的hash。</p>
</li>
<li><p>RIPEME-160</p>
<p> RIPEMD（RIPE Message Digest）是1992年（原始RIPEMD）和1996年（其他变体）开发的一系列密码哈希函数。 该系列有五个功能：RIPEMD，RIPEMD-128，RIPEMD-160，RIPEMD-256和RIPEMD-320，其中RIPEMD-160是最常见的,也是比特币中使用的Hash算法之一。</p>
<p> 之所以使用RIPEMD，是因为它产生了最短的哈希,用于生成比特币地址,这允许比特币地址更短。同时，其唯一性仍得到了充分保证。 </p>
</li>
<li><p>Merkle Tree</p>
<p> Merkle树是一种哈希树，其中叶节点是根据数据块计算的加密哈希，而非叶节点是其直接子节点的哈希。根散列也称为数据的“摘要”。</p>
<p> o<br> 要验证一个记录，它需要一个数据“证明”，其中包含根路径上的节点。递归地重新计算新的根散列，并使用先前保存的摘要检查相等性。</p>
<p> 如下图：例如L4被修改，那么hash1-1，hash1，top hash 都会被重新计算，最终显示为Top hash的变化，只需要对比Top hash 就能够知道节点中的数据有没有被篡改。</p>
<p> <img src="/2021/05/28/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%AD%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9F%A5%E8%AF%86/Hash_Tree.jpg" alt="img" title="Merkle树"></p>
<p> Merkle 树将根存储在比特币区块中，验证者只用验证根的hash是否变化，就可以判断Merkle 树中的子节点是否被篡改，而不用验证全部的节点，极大的减少了验证的复杂度。</p>
<p> <img src="/2021/05/28/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%AD%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9F%A5%E8%AF%86/Merkle-Tree-representation-of-a-Block.png" alt="img" title="Merkle树表示"></p>
</li>
</ol>
<p><a id="orgb205e36"></a></p>
<h3 id="公钥密码体制"><a href="#公钥密码体制" class="headerlink" title="公钥密码体制"></a>公钥密码体制</h3><p>公钥密码体制使用*不同的加密密钥与解密密钥*，是一种“由已知加密密钥推导出解密密钥在计算上是不可行的”密码体制。</p>
<p>公钥密码体制使用的密钥分为公钥和私钥，两种密钥成对使用。使用公钥加密和私钥解密；使用私钥加密和公钥解密。</p>
<p>现有最著名的公钥密码体制是*RSA* 体制，它基于数论中大数分解问题，由美国三位科学家 Rivest, Shamir 和 Adleman 于 1976 年提出并在 1978 年正式发表的。</p>
<p>公钥密码体制根据使用秘钥的不同，可以分为两类：发送者使用发送者的私钥处理数据，接受者使用发送者的公钥逆向处理，为签名；发送者使用接受者的公钥处理数据，接受者使用接受者的私钥处理数据，为加密。下面分别讨论这两种方式：</p>
<ol>
<li><p>非对称加密</p>
<p> 非对称密码学利用两个密钥（公共密钥和私有密钥）来加密和解密特定数据。例如：我发消息给你，用你的公钥进行加密，而你用自己的私钥进行解密，你的公钥可以公开，但是你的私钥只有自己知道.这样每个人都可以给你发信息，但只有你自己能通过私钥解密查看。</p>
<p> 下图为正常的加密、解密流程：</p>
<p> <img src="/2021/05/28/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%AD%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9F%A5%E8%AF%86/68637037-67713000-0538-11ea-85c9-177b3b26aa5a.png" alt="img" title="密码体制及应用"></p>
<p> 两种常用的非对称加密算法：Rivest-Shamir-Adleman算法又称为RSA，椭圆曲线密码（ECC）。</p>
</li>
<li><p>数字签名</p>
<p> 比特币本身是不加密的，那么比特币不加密怎么安全呢？</p>
<p> 如果我要交易，把我的比特币给你，那么我在交易上，用我的私钥进行签名，大家都可以用我的公钥进行验证，这样大家都能知道确实是我进行的交易，证明币是你的，这就涉及到了数字签名。</p>
<p> 如下图所示：发送者用自己的private key 处理message 和 经过hash的message digest，然后通过信道发送个接受者，接受者通过发送者的public key逆向处理消息，得到message 和 message disgest，通过验证hash(message)是否与messagedigest相等，可以验证是否是发送者发来的消息。</p>
<p> <img src="/2021/05/28/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%AD%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9F%A5%E8%AF%86/image002.jpg" alt="img" title="数字签名"></p>
</li>
</ol>
<p><a id="org60092e2"></a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>随着互联网和公钥密码体制的发展，人们越来越关注安全和隐私，密码学在日常生活中处处可见，掌握必要的密码学知识至关重要。</p>
<p>bitcoin通过一系列密码算法的组合，实现了一个分布式、点对点、可信、可验证、不可篡改的加密数字货币，比特币种的密码学知识主要有哈希，公钥密码体制，数字签名。</p>
<p><a id="orga6c2764"></a></p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>[1] Wright, C. S. (2019). Bitcoin: A Peer-to-Peer Electronic Cash System. SSRN Electronic Journal, 1–9. <a href="https://doi.org/10.2139/ssrn.3440802">https://doi.org/10.2139/ssrn.3440802</a></p>
<h1 id="Footnotes"><a href="#Footnotes" class="headerlink" title="Footnotes"></a>Footnotes</h1><p><sup><a id="fn.1" href="#fnr.1">1</a></sup> <a href="https://en.bitcoin.it/wiki/Wei_Dai">https://en.bitcoin.it/wiki/Wei_Dai</a></p>
<p><sup><a id="fn.2" href="#fnr.2">2</a></sup> <a href="http://zh.wikipedia.org/wiki/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86">http://zh.wikipedia.org/wiki/公开密钥加密</a></p>
<p>欢迎关注我的微信公众号，扫描下方二维码，就可以找到我，我会持续为你分享 IT 技术和珠宝知识。</p>
<p><img src="https://pic1.zhimg.com/80/v2-8ff04a9934840c3c552ed41497bc4748_720w.jpg" alt="欢迎关注我的微信公众号，扫描下方二维码，就可以找到我，我会持续为你分享 IT 技术和珠宝知识"></p>
<p>也可以关注我的个人博客</p>
<p><a href="https://dianwoshishi.github.io/">点我试试的个人博客</a></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>比特币</tag>
        <tag>区块链</tag>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统下的系统资源和网络资源控制</title>
    <url>/2021/05/30/%E8%B5%84%E6%BA%90%E4%BF%9D%E9%9A%9C/</url>
    <content><![CDATA[<h2 id="今日珠宝"><a href="#今日珠宝" class="headerlink" title="今日珠宝"></a>今日珠宝</h2><p>宝格丽BVLGARI系列戒指</p>
<p>18K玫瑰金材质镶嵌7颗钻石，非常经典优雅的设计风格。指圈大小63号（正品实拍）</p>
<p><img src="https://pic1.zhimg.com/80/v2-a78042ef069ac261a2b24c645c26204c_720w.jpg" alt="宝格丽BVLGARI系列戒指"></p>
<p>原文为<a href="https://zhuanlan.zhihu.com/p/376501404">知乎</a>，现转移到个人博客。<br><a href="https://zhuanlan.zhihu.com/p/376501404" target="_blank" class="LinkCard">知乎原文</a></p>
<h1 id="Linux系统下的系统资源和网络资源控制"><a href="#Linux系统下的系统资源和网络资源控制" class="headerlink" title="Linux系统下的系统资源和网络资源控制"></a>Linux系统下的系统资源和网络资源控制</h1><p>众所周知，在互联网诞生之初都是各个高校和科研机构相互通讯，并没有网络流量控制方面的考虑和设计，IP协议的原则是尽可能好地为所有数据流服务，不同的数据流之间是平等的。然而多年的实践表明，这种原则并不是最理想的，有些数据流应该得到特别的照顾， 比如，远程登录的交互数据流应该比数据下载有更高的优先级。</p>
<p>同样，我们希望操作系统内的资源也是不平等的，我们总是希望某些进程占用更多的资源，以满足我们当前最迫切的需求，比如看电影的时候，我们希望视频播放器更多的资源，而不希望这个时候浏览器占用过多的资源。</p>
<p>因此细粒度的对操作系统资源的控制是我们每一个人都想做的事，自己的地盘自己做主。</p>
<h2 id="限制系统资源"><a href="#限制系统资源" class="headerlink" title="限制系统资源"></a>限制系统资源</h2><p>在Linux上限制系统资源主要使用的工具是<code>cgroup</code>.</p>
<p>基本语法不在赘述，相关文章很多<code>见参考资料</code>。我们想限制的系统资源主要是CPU，内存还有IO设备(例如，硬盘读写速度)。在Linux系统中，这些资源的分配和管理都由相应目录<code>/cgroup/cpu/,/cgroup/memory ,/cgroup/blkio</code>下配置。下面举例进行说明：例如你想建一个cpu控制策略，取名为<code>foo</code>,则你只需要在目录<code>/cgroup/cpu/</code>中<code>mkdir foo</code>，操作系统会为你创造一些列文件，就可以用操作文件的方式控制你的系统了。如下例：</p>
<h3 id="cpu限制实例"><a href="#cpu限制实例" class="headerlink" title="cpu限制实例"></a><strong>cpu限制实例</strong></h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">1. [root@localhost &#x2F;]# mkdir -p &#x2F;cgroup&#x2F;cpu&#x2F;foo&#x2F; 
2. [root@localhost &#x2F;]# mkdir -p &#x2F;cgroup&#x2F;cpuset&#x2F;foo&#x2F; 
3. [root@localhost &#x2F;]# echo 50000 &gt; &#x2F;cgroup&#x2F;cpu&#x2F;foo&#x2F;cpu.cfs_quota_us 
4. [root@localhost &#x2F;]# echo 100000 &gt; &#x2F;cgroup&#x2F;cpu&#x2F;foo&#x2F;cpu.cfs_period_us 
5. [root@localhost &#x2F;]# echo &quot;0&quot; &gt; &#x2F;cgroup&#x2F;cpuset&#x2F;foo&#x2F;cpuset.mems 
6. [root@localhost &#x2F;]# echo &quot;1&quot; &gt; &#x2F;cgroup&#x2F;cpuset&#x2F;foo&#x2F;cpuset.cpus 
7. [root@localhost &#x2F;]# echo 28819 &gt; &#x2F;cgroup&#x2F;cpu&#x2F;foo&#x2F;tasks  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="内存限制实例"><a href="#内存限制实例" class="headerlink" title="内存限制实例"></a><strong>内存限制实例</strong></h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">1. [root@localhost &#x2F;]# mkdir -p &#x2F;cgroup&#x2F;memory&#x2F;foo 
2. [root@localhost &#x2F;]# echo &gt; &#x2F;cgroup&#x2F;memory&#x2F;foo&#x2F;memory.limit_in_bytes 
3. [root@localhost &#x2F;]# echo 44476 &gt; &#x2F;cgroup&#x2F;memory&#x2F;foo&#x2F;tasks  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>内存参数</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">cgroup.event_control       #用于eventfd的接口
memory.usage_in_bytes      #显示当前已用的内存
memory.limit_in_bytes      #设置&#x2F;显示当前限制的内存额度
memory.failcnt             #显示内存使用量达到限制值的次数
memory.max_usage_in_bytes  #历史内存最大使用量
memory.soft_limit_in_bytes #设置&#x2F;显示当前限制的内存软额度
memory.stat                #显示当前cgroup的内存使用情况
memory.use_hierarchy       #设置&#x2F;显示是否将子cgroup的内存使用情况统计到当前cgroup里面
memory.force_empty         #触发系统立即尽可能的回收当前cgroup中可以回收的内存
memory.pressure_level      #设置内存压力的通知事件，配合cgroup.event_control一起使用
memory.swappiness          #设置和显示当前的swappiness
memory.move_charge_at_immigrate #设置当进程移动到其他cgroup中时，它所占用的内存是否也随着移动过去
memory.oom_control         #设置&#x2F;显示oom controls相关的配置
memory.numa_stat           #显示numa相关的内存<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


</blockquote>
<h3 id="IO限制实例"><a href="#IO限制实例" class="headerlink" title="IO限制实例"></a><strong>IO限制实例</strong></h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">1. [root@localhost ~]# mkdir -p &#x2F;cgroup&#x2F;blkio&#x2F;foo 
2. [root@localhost ~]# echo &#39;8:0  10485760&#39; &gt; &#x2F;cgroup&#x2F;blkio&#x2F;foo&#x2F;blkio.throttle.read_bps_device 
3. [root@localhost ~]# echo 45033 &gt; &#x2F;cgroup&#x2F;blkio&#x2F;foo&#x2F;tasks 
#  注2：8:0对应主设备号和副设备号，可以通过ls -l &#x2F;dev&#x2F;sda查看<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="一个限制内存和CPU的具体例子"><a href="#一个限制内存和CPU的具体例子" class="headerlink" title="一个限制内存和CPU的具体例子"></a>一个限制内存和CPU的具体例子</h3><p>之前在学习cgroup的时候，较多的都是减少原理和一些简单的例子，但这对直观的取理解cgroup还是有点障碍，所以学习的过程中，参考他人的博客结合自己的理解写了一个例子，供大家参考。</p>
<p>例子分为两个部分</p>
<h4 id="0x01-被限制应用"><a href="#0x01-被限制应用" class="headerlink" title="0x01 被限制应用"></a>0x01 被限制应用</h4><p>被限制应用是一个CPU消耗型，具体见下面代码</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> i<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>直接编译，假如这里编译出的程序名为<code>deadloop</code>, <code>top</code>查看如下：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"> PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND     
31404 root  20   0    4220    656    588 R  98.7  0.0   8:45.27 deadloop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<h4 id="0x02-限制规则"><a href="#0x02-限制规则" class="headerlink" title="0x02 限制规则"></a>0x02 限制规则</h4><p>这里我们做两个方面的工作：限制CPU使用率和限制内存。具体代码如下：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 增加规则代码
#!&#x2F;bin&#x2F;bash
# 规则集合在testdead
gname&#x3D;&#39;testdead&#39;
value&#x3D;50000
prog&#x3D;$1
mem_val&#x3D;1024000

rmdir &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu&#x2F;$&#123;gname&#125;;
rmdir &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memory&#x2F;$gname;

mkdir &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu&#x2F;$gname;
mkdir &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memory&#x2F;$gname;

echo $value | sudo tee &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu&#x2F;$gname&#x2F;cpu.cfs_quota_us;
echo $mem_val | sudo tee &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memory&#x2F;$gname&#x2F;memory.limit_in_bytes;

for x in $(pidof $prog)
do 
	echo $x  | sudo tee &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu&#x2F;$gname&#x2F;tasks;
	echo $x | sudo tee &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memory&#x2F;$gname&#x2F;tasks

	echo 0 | sudo tee &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memory&#x2F;$gname&#x2F;memory.swappiness
done<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 删除规则代码
#!&#x2F;bin&#x2F;bash

dname&#x3D;testdead

cgdelete cpu:$dname<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上述规则应用后，<code>top</code>查看如下：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">31404 root  20   0    4220    656    588 R  49.8  0.0   8:08.46 deadloop   <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>可以看出，两次的CPU使用率不一样，显示出了cgroup的限制效果。</p>
<h2 id="限制网络资源"><a href="#限制网络资源" class="headerlink" title="限制网络资源"></a>限制网络资源</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>Linux操作系统中，报文分组从输入网卡(入口)接收进来，经过路由的查找， 以确定是发给本机的，还是需要转发的。如果是发给本机的，就直接向上递交给上层的协议，比如TCP，如果是转发的， 则会从输出网卡(出口)发出。网络流量的控制通常发生在输出网卡处。虽然在路由器的入口处也可以进行流量控制，Linux也具有相关的功能， 但一般说来， 由于我们无法控制自己网络之外的设备， 入口处的流量控制相对较难。本文将集中介绍出口处的流量控制。</p>
<h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p>流量控制（<code>Traffic Control</code>， <code>tc</code>）是<code>Linux</code>内核提供的流量限速、整形和策略控制机制。它以<code>qdisc-class-filter</code>的树形结构来实现对流量的分层控制</p>
<p>在Linux中，流量控制都是通过TC这个工具来完成的。通常， 要对网卡进行流量控制的配置，需要进行如下的步骤:</p>
<ul>
<li><p>为网卡配置一个队列;</p>
</li>
<li><p>在该队列上建立分类;</p>
</li>
<li><p>根据需要建立子队列和子分类;</p>
</li>
<li><p>为每个分类建立过滤器。</p>
</li>
</ul>
<p><img src="/2021/05/30/%E8%B5%84%E6%BA%90%E4%BF%9D%E9%9A%9C/tc2.jpeg" alt="Traffic Control"></p>
<h3 id="基本组成"><a href="#基本组成" class="headerlink" title="基本组成"></a>基本组成</h3><p>从上图中可以看到，tc由<code>qdisc</code>、<code>fitler</code>和<code>class</code>三部分组成：</p>
<ul>
<li><p><code>qdisc</code>通过队列将数据包缓存起来，用来控制网络收发的速度</p>
<ul>
<li>常见的classless qdisc有：choke, codel, p/bfifo,fq, fq_codel, gred, hhf, ingress,mqprio, multiq, netem, pfifo_fast, pie, red, rr, sfb, sfq, tbf。linux默认使用的就是fifo_fast。</li>
<li>常见的classful qdisc有：ATM, CBQ, DRR, DSMARK, HFSC, HTB, PRIO, QFQ</li>
</ul>
</li>
<li><p><code>class</code>用来表示控制策略</p>
<ul>
<li><p>分类只存在于可分类排队规则（classful qdisc）（例如，HTB和CBQ）中。</p>
</li>
<li><blockquote>
<p><strong>default</strong> 这是HTB排队规则的一个可选参数，默认值为0， 当值为0时意味着会绕过所有和rootqdisc相关联的分类，然后以最大的速度出队任何未分类的流量。 </p>
<p><strong>rate</strong> 这个参数用来设置流量发送的最小期望速率。这个速率可以被当作承诺信息速率(CIR), 或者给某个叶子分类的保证带宽。 </p>
<p><strong>ceil</strong> 这个参数用来设置流量发送的最大期望速率。租借机制将会决定这个参数的实际用处。 这个速率可以被称作“突发速率”。 </p>
<p><strong>burst</strong> 这个参数是rate桶的大小(参见令牌桶这一节)。HTB将会在更多令牌到达之前将burst个字节的数据包出队。 </p>
<p><strong>cburst</strong> 这个参数是ceil桶的大小（参见令牌桶这一节）。HTB将会更多令牌(ctoken)到达之前将cburst个字节的数据包出队。 </p>
<p><strong>quantum</strong> 这个是HTB控制租借机制的关键参数。正常情况下，HTB自己会计算合适的quantum值，而不是由用户来设定。对这个值的轻微调整都会对租借和整形造成巨大的影响，因为HTB不仅会根据这个值向各个子分类分发流量(速率应高于rate，小于ceil)，还会根据此值输出各个子分类中的数据。 </p>
<p><strong>r2q</strong> 通常,quantum 的值由HTB自己计算，用户可以通过此参数设置一个值来帮助HTB为某个分类计算一个最优的quantum值。</p>
</blockquote>
</li>
</ul>
</li>
<li><p><code>filter</code>用来将数据包划分到具体的控制策略中</p>
<ul>
<li>包含了一个分类器实现，常见的分类器如u32，u32分类器可以允许用户基于数据包的属性来选择数据包。</li>
</ul>
</li>
</ul>
<p>语法不再赘述，相关参考资料里有。</p>
<h3 id="入流量调度"><a href="#入流量调度" class="headerlink" title="入流量调度"></a>入流量调度</h3><p>Linux中的QoS分为入口(Ingress)部分和出口(Egress)部分，入口部分主要用于进行入口流量限速(policing)，出口部分主要用于队列调度(queuing scheduling)。</p>
<p>大多数排队规则(qdisc)都是用于输出方向的，输入方向只有一个排队规则，即ingress qdisc。ingress qdisc本身的功能很有限，但可用于重定向incoming packets。通过Ingress qdisc把输入方向的数据包重定向到虚拟设备ifb，而ifb的输出方向可以配置多种qdisc，就可以达到对输入方向的流量做队列调度的目的。</p>
<p><img src="/2021/05/30/%E8%B5%84%E6%BA%90%E4%BF%9D%E9%9A%9C/1354528849_1019.png" alt="输入流量调度示意"></p>
<p>IFB说明：</p>
<blockquote>
<p>IFB — Intermediate Functional Block device。<br>Q: How can we use qdisc (e.g., netem) on incoming traffic?<br>A: You need to use IFB. This network device allows attaching queueing disciplines to incoming packets.<br>To use an IFB, you must have IFB support in your kernel (configuration option CONFIG_IFB). Assuming that you have a modular kernel, the name of the IFB module is ifb and may be loaded using the command <code>modprobe ifb</code> (if you have modprobe installed) or <code>insmod /path/to/module/ifb</code>.</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">ip link set ifb0 up
ip link set ifb1 up<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>By default, two IFB devices(ifb0 and ifb1) are created.<br>IFB allows for queueing incoming traffic for shaping instead of dropping.</p>
<p>参考资料:<a href="https://blog.csdn.net/eydwyz/article/details/53392227">https://blog.csdn.net/eydwyz/article/details/53392227</a></p>
</blockquote>
<h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#!&#x2F;bin&#x2F;bash
#fb驱动并创建ifb网卡(使用ifconfig -a 如果看到已有则无需该步骤)
#分别为出设备和入设备
outdevice&#x3D;ens33
indevice&#x3D;ifb0

modprobe ifb numifbs&#x3D;1
# up网卡
ip link set dev $indevice up

# ------
	# 清除原有的根队列(根据实际情况操作,非必要) 
	tc qdisc del dev $outdevice root 2&gt;&#x2F;dev&#x2F;null
	tc qdisc del dev $outdevice ingress 2&gt;&#x2F;dev&#x2F;null
	tc qdisc del dev $indevice root 2&gt;&#x2F;dev&#x2F;null
 
	#  将$outdevice的ingress流量全部重定向到 $indevice 处理
	tc qdisc add dev $outdevice handle ffff: ingress
	tc filter add dev $outdevice parent ffff: protocol ip u32 match u32 0 0 action mirred egress redirect dev $indevice
	 
	# $outdevice的出向限速:$outdevice添加根队列,使用htb,添加1:1类,使用htb 
	tc qdisc add dev $outdevice root handle 1: htb r2q 625 default 65
	tc class add dev $outdevice parent 1: classid 1:1 htb rate 1000Mbit
	 
	# $outdevice的入向限速:$indevice添加根队列,使用htb,添加1:1类,使用htb 
	tc qdisc add dev $indevice root handle 1: htb r2q 625 default 65
	tc class add dev $indevice parent 1: classid 1:1 htb rate 1000Mbit
	 
	# $outdevice的出向限速:$outdevice设备添加子类\对应的filter配置规则和子类的队列
	tc class add dev $outdevice parent 1:1 classid 1:10 htb rate 10Mbit
	tc filter add dev $outdevice parent 1: protocol all prio 1 u32 match ip dst 192.168.0.2 classid 1:10
	tc qdisc add dev $outdevice parent 1:10 handle 10: sfq
	 
	# $outdevice的出向限速:$outdevice设备添加子类\对应的filter配置规则和子类的队列 
	tc class add dev $outdevice parent 1:1 classid 1:11 htb rate 20Mbit
	tc filter add dev $outdevice parent 1: protocol all prio 1 u32 match ip dst 192.168.0.3 classid 1:11
	tc qdisc add dev $outdevice parent 1:11 handle 11: sfq
	 
	 
	# $outdevice的入向限速:$indevice设备添加子类\对应的filter配置规则和子类的队列
	tc class add dev $indevice parent 1:1 classid 1:10 htb rate 10Mbit
	tc filter add dev $indevice parent 1: protocol all prio 1 u32 match ip src 192.168.0.2 classid 1:10
	tc qdisc add dev $indevice parent 1:10 handle 10: sfq
	 
	 
	# $outdevice的入向限速:$indevice设备添加子类\对应的filter配置规则和子类的队列 
	tc class add dev $indevice parent 1:1 classid 1:11 htb rate 20Mbit
	tc filter add dev $indevice parent 1: protocol all prio 1 u32 match ip src 192.168.0.3 classid 1:11
	tc qdisc add dev $indevice parent 1:11 handle 11: sfq<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="网络压力测试"><a href="#网络压力测试" class="headerlink" title="网络压力测试"></a>网络压力测试</h3><p>压力测试工具使用<code>iperf网络测试工具</code></p>
<blockquote>
<p>常用参数指南（详见附录）：</p>
<p>-c/s：客户端模式/服务端模式</p>
<p>-p：指定iperf测试端口</p>
<p>-i：指定报告间隔</p>
<p>-b：设置UDP的发送带宽，单位bit/s</p>
<p>-t：设置测试的时长，单位为秒，不设置默认10s</p>
<p>-l：指定包大小，TCP默认8k，UDP默认1470字节</p>
</blockquote>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 针对TCP进行带宽性能测试
#服务端命令：
iperf -s -i 1 -p 3389
#
iperf -c 192.168.158.128 -p 3389 -i 1

#针对UDP进行带宽性能测试
#服务端命令
iperf -u -s -i 1 -p 3389
#客户端命令
iperf -u -c 192.168.158.128 -p 3389 -b 1500M -i 1 
# 参考资料：iperf网络测试工具， https:&#x2F;&#x2F;cloud.tencent.com&#x2F;developer&#x2F;article&#x2F;1688469<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>带宽查看使用工具<code>iftop</code></p>
<blockquote>
<pre><code>TX：发送流量
RX：接收流量
TOTAL：总流量
Cumm：运行iftop到目前时间的总流量
peak：流量峰值
rates：分别表示过去 2s 10s 40s 的平均流量
</code></pre>
</blockquote>
<p>执行脚本前后，对于网络带宽进行检测，发现流量带宽明显受到TC的控制。实验成功。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文通过对Linux操作系统中<code>cgroup</code>、<code>tc</code>的使用，实现了对Linux操作系统中系统资源和网络资源的控制。本文的方法和工具在写作过程中可能还有用到，但是没有写进来的，欢迎大家留言或通过微信公众号联系我，我会尽力为大家解答。</p>
<h2 id="其他补充"><a href="#其他补充" class="headerlink" title="其他补充"></a>其他补充</h2><h3 id="如何获取进程ID"><a href="#如何获取进程ID" class="headerlink" title="如何获取进程ID"></a>如何获取进程ID</h3><h4 id="根据进程名称获取pid"><a href="#根据进程名称获取pid" class="headerlink" title="根据进程名称获取pid"></a>根据进程名称获取pid</h4><p> 最简单的方法是使用 <strong>pidof</strong> 命令，用法：pidof  process_name，例如：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 查看初始进程的pid
pidof init
# <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>有事可能因为同一个名称的程序启动了多个进程，使用pidof时会返回多个pid，使用空格分开</p>
<h4 id="查找当前激活状态的网络链接及进程ID"><a href="#查找当前激活状态的网络链接及进程ID" class="headerlink" title="查找当前激活状态的网络链接及进程ID"></a>查找当前激活状态的网络链接及进程ID</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">lsof -i -n（不反向解析DNS）
# eg
lsof -i -n | awk   &#39;&#123;print $2, $9&#125;&#39;
# 输出为
#PID NAME
#29646 192.168.153.129:51044-&gt;13.250.177.223:https
#29646 192.168.153.129:52970-&gt;54.149.208.57:https<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p>Linux 资源隔离机制 – CGroup <a href="https://zhuanlan.zhihu.com/p/47590418">https://zhuanlan.zhihu.com/p/47590418</a></p>
<p><a href="https://www.cnblogs.com/caoxiaojian/p/5633430.html">CGroup 介绍、应用实例及原理描述</a> <a href="https://www.cnblogs.com/caoxiaojian/p/5633430.html">https://www.cnblogs.com/caoxiaojian/p/5633430.html</a></p>
<p>流量控制 <a href="https://tonydeng.github.io/sdn-handbook/linux/tc.html">https://tonydeng.github.io/sdn-handbook/linux/tc.html</a></p>
<p>Traffic Control HOWTO <a href="https://tldp.org/HOWTO/Traffic-Control-HOWTO/">https://tldp.org/HOWTO/Traffic-Control-HOWTO/</a></p>
<p>Linux TC(Traffic Control)框架原理解析， <a href="https://blog.csdn.net/dog250/article/details/40483627">https://blog.csdn.net/dog250/article/details/40483627</a></p>
<p> <a href="https://www.cnblogs.com/yulia/p/10346339.html">linux下使用tc(Traffic Control) 流量控制命令模拟网络延迟和丢包</a></p>
<p>TC流量控制 <a href="https://blog.csdn.net/who538592/article/details/79483323">https://blog.csdn.net/who538592/article/details/79483323</a></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>系统管理</tag>
        <tag>网络管理</tag>
      </tags>
  </entry>
  <entry>
    <title>基于netfilter的IP数据统计设计</title>
    <url>/2021/05/29/%E5%9F%BA%E4%BA%8Enetfilter%E7%9A%84IP%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E8%AE%BE%E8%AE%A1%E4%B8%8ELinux%E9%A9%B1%E5%8A%A8%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h1><ol>
<li> <a href="#orgab76e7a">背景</a></li>
<li><a href="#org02ac451">IP信息统计</a><ol>
<li> <a href="#org62d4d73">统计信息设计</a></li>
<li> <a href="#org44f97b2">存储数据结构</a></li>
</ol>
</li>
<li><a href="#orgde188bf">Linux驱动</a><ol>
<li> <a href="#orgc0bb933">网络型驱动设备</a></li>
<li> <a href="#org9e48264">字符型设备</a></li>
<li> <a href="#org8ee7f64">用户代码</a></li>
</ol>
</li>
<li><a href="#org3f4753d">总结</a><ol>
<li> <a href="#org01bad05">Linux 驱动</a></li>
<li> <a href="#orgd1e6a5e">Linux内核</a></li>
<li> <a href="#org4c6ff33">其他</a></li>
</ol>
</li>
<li> <a href="#orgfe8069d">参考资料</a></li>
</ol>
<p><a id="orgab76e7a"></a></p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>当今社会，没有都有自己的信息处理设备，如手机、计算机甚至可能是路由器。在使用这些设备的时候，我们想知道的一件事就是，我的电脑和那些设备有过通信，通信情况怎么样，以便在网络出现问题，如拥塞，或是自己主机被黑客控制出现异常数据的时候，能够通过上述统计信息快速定位问题所在。因此本文通过Linux驱动中的netfilter对IP数据报中的IP信息进行统计，通过字符型驱动实现用户态查看统计信息，达到了统计主机通信的目的，为进一步做好异常处理打下了基础。</p>
<p><a id="org02ac451"></a></p>
<h1 id="IP信息统计"><a href="#IP信息统计" class="headerlink" title="IP信息统计"></a>IP信息统计</h1><p><a id="org62d4d73"></a></p>
<h2 id="统计信息设计"><a href="#统计信息设计" class="headerlink" title="统计信息设计"></a>统计信息设计</h2><p>统计对象为源IP地址，信息内容目前设计为：IP出现频次，最后一个IP数据包出现时的时间戳。</p>
<pre><code>typedef struct IPData&#123;
  int timestamp;
  int count
&#125;ipdata;
</code></pre>
<p><a id="org44f97b2"></a></p>
<h2 id="存储数据结构"><a href="#存储数据结构" class="headerlink" title="存储数据结构"></a>存储数据结构</h2><p>由于在Linux Kernel中没有C++的set，map等数据结构，因此使用其提供的红黑树实现IP信息的快速存储和读取。其中红黑树节点的信息如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">   <span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">roc_node_s</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">struct</span> <span class="token class-name">rb_node</span> node<span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>ctx<span class="token punctuation">;</span>
    <span class="token keyword">int</span> key<span class="token punctuation">;</span>
    ipdata ipcount<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token class-name">roc_node_t</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>红黑树的实现使用Linux Kernel自带的rbtree数据结构，头文件为：</p>
<pre><code>#include &lt;linux/rbtree.h&gt;
</code></pre>
<p>红黑树插入，删除等代码参考链接为：<a href="https://blog.csdn.net/chn475111/article/details/52594457">https://blog.csdn.net/chn475111/article/details/52594457</a>.</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/**
 * filename: my_rbtree.h
 * @author lijk@.infosec.com.cn
 * @version 0.0.1
 * @date 2016-9-20 11:52:06
 */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/string.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/rbtree.h></span></span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">IPData</span><span class="token punctuation">&#123;</span>
  <span class="token keyword">int</span> timestamp<span class="token punctuation">;</span>
  <span class="token keyword">int</span> count
<span class="token punctuation">&#125;</span>ipdata<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">roc_node_s</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">struct</span> <span class="token class-name">rb_node</span> node<span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>ctx<span class="token punctuation">;</span>
    <span class="token keyword">int</span> key<span class="token punctuation">;</span>
    ipdata ipcount<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token class-name">roc_node_t</span><span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>roc_cb<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">roc_node_t</span><span class="token operator">*</span> <span class="token function">roc_search</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rb_root</span> <span class="token operator">*</span>root<span class="token punctuation">,</span> <span class="token keyword">int</span> key<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span>node <span class="token operator">=</span> root<span class="token operator">-></span>rb_node<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token class-name">roc_node_t</span> <span class="token operator">*</span>data <span class="token operator">=</span> <span class="token function">rb_entry</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> <span class="token class-name">roc_node_t</span><span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> result <span class="token operator">=</span> key <span class="token operator">-</span> data<span class="token operator">-></span>key<span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
            node <span class="token operator">=</span> node<span class="token operator">-></span>rb_left<span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>
            node <span class="token operator">=</span> node<span class="token operator">-></span>rb_right<span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            <span class="token keyword">return</span> data<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">roc_insert</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rb_root</span> <span class="token operator">*</span>root<span class="token punctuation">,</span> <span class="token class-name">roc_node_t</span> <span class="token operator">*</span>data<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span><span class="token operator">*</span>new <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span>root<span class="token operator">-></span>rb_node<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">*</span>parent <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">*</span>new<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token class-name">roc_node_t</span> <span class="token operator">*</span>this <span class="token operator">=</span> <span class="token function">rb_entry</span><span class="token punctuation">(</span><span class="token operator">*</span>new<span class="token punctuation">,</span> <span class="token class-name">roc_node_t</span><span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> result <span class="token operator">=</span> data<span class="token operator">-></span>key <span class="token operator">-</span> this<span class="token operator">-></span>key<span class="token punctuation">;</span>

        parent <span class="token operator">=</span> <span class="token operator">*</span>new<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
            new <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>new<span class="token punctuation">)</span><span class="token operator">-></span>rb_left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>
            new <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>new<span class="token punctuation">)</span><span class="token operator">-></span>rb_right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token function">rb_link_node</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>data<span class="token operator">-></span>node<span class="token punctuation">,</span> parent<span class="token punctuation">,</span> new<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">rb_insert_color</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>data<span class="token operator">-></span>node<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">roc_erase</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rb_root</span> <span class="token operator">*</span>root<span class="token punctuation">,</span> <span class="token keyword">int</span> key<span class="token punctuation">,</span> roc_cb cb<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token class-name">roc_node_t</span> <span class="token operator">*</span>data <span class="token operator">=</span> <span class="token function">roc_search</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">rb_erase</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>data<span class="token operator">-></span>node<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">RB_CLEAR_NODE</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>data<span class="token operator">-></span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>cb<span class="token punctuation">)</span> <span class="token function">cb</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">roc_destroy</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rb_root</span> <span class="token operator">*</span>root<span class="token punctuation">,</span> roc_cb cb<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token class-name">roc_node_t</span> <span class="token operator">*</span>pos <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span>node <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>node <span class="token operator">=</span> <span class="token function">rb_first</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        pos <span class="token operator">=</span> <span class="token function">rb_entry</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> <span class="token class-name">roc_node_t</span><span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">_DEBUG</span></span>
        <span class="token function">sprintf</span><span class="token punctuation">(</span>message<span class="token punctuation">,</span> <span class="token string">"key = %d\n"</span><span class="token punctuation">,</span> pos<span class="token operator">-></span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
        <span class="token function">rb_erase</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pos<span class="token operator">-></span>node<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">RB_CLEAR_NODE</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pos<span class="token operator">-></span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>cb<span class="token punctuation">)</span> <span class="token function">cb</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">roc_dump</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rb_root</span> <span class="token operator">*</span>root<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span>node <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> sip<span class="token punctuation">,</span> count<span class="token punctuation">,</span> timestamp<span class="token punctuation">;</span>
  <span class="token comment">//printk("roc_dump");</span>
    <span class="token function">memset</span><span class="token punctuation">(</span>message<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> MAX_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>node <span class="token operator">=</span> <span class="token function">rb_first</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">strlen</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span> <span class="token operator">&lt;</span> MAX_SIZE <span class="token operator">&amp;&amp;</span> node <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> node <span class="token operator">=</span> <span class="token function">rb_next</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>

  sip <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token function">rb_entry</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> <span class="token class-name">roc_node_t</span><span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token operator">-></span>key <span class="token punctuation">;</span>   
  count <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token function">rb_entry</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> <span class="token class-name">roc_node_t</span><span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token operator">-></span>ipcount<span class="token punctuation">.</span>count <span class="token punctuation">;</span>   
  timestamp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token function">rb_entry</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> <span class="token class-name">roc_node_t</span><span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token operator">-></span>ipcount<span class="token punctuation">.</span>timestamp <span class="token punctuation">;</span>  
  <span class="token function">sprintf</span><span class="token punctuation">(</span>message<span class="token punctuation">,</span> <span class="token string">"%s%d.%d.%d.%d|%d|%d,"</span><span class="token punctuation">,</span>message<span class="token punctuation">,</span> <span class="token function">NIPQUAD</span><span class="token punctuation">(</span> sip<span class="token punctuation">)</span><span class="token punctuation">,</span> count<span class="token punctuation">,</span> timestamp<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">//printk(message);</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">roc_free</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token class-name">roc_node_t</span> <span class="token operator">*</span>node <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">roc_node_t</span><span class="token operator">*</span><span class="token punctuation">)</span>ptr<span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">-></span>ctx<span class="token punctuation">)</span> <span class="token function">kfree</span><span class="token punctuation">(</span>node<span class="token operator">-></span>ctx<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">kfree</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token keyword">const</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">struct</span> <span class="token class-name">rb_root</span> root <span class="token operator">=</span> RB_ROOT<span class="token punctuation">;</span>

    <span class="token keyword">int</span> loop <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token class-name">roc_node_t</span> <span class="token operator">*</span>node <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>loop <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> loop <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> loop <span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        node <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">roc_node_t</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">kmalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token class-name">roc_node_t</span><span class="token punctuation">)</span><span class="token punctuation">,</span> GFP_KERNEL <span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        node<span class="token operator">-></span>ctx <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
        node<span class="token operator">-></span>key <span class="token operator">=</span> loop<span class="token punctuation">;</span>
        <span class="token function">roc_insert</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>root<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token number">0</span></span></span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>loop <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> loop <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> loop <span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token function">roc_erase</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>root<span class="token punctuation">,</span> loop<span class="token punctuation">,</span> roc_free<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>

    <span class="token function">roc_dump</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">roc_destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>root<span class="token punctuation">,</span> roc_free<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><a id="orgde188bf"></a></p>
<h1 id="Linux驱动"><a href="#Linux驱动" class="headerlink" title="Linux驱动"></a>Linux驱动</h1><p>考虑在内核实现的原因是目前Linux相关设备非常多，可能具有一定的参考价值和移植性。<br>笔者的内核环境为：</p>
<pre><code>  uname -r
4.15.0-142-generic
</code></pre>
<p><a id="orgc0bb933"></a></p>
<h2 id="网络型驱动设备"><a href="#网络型驱动设备" class="headerlink" title="网络型驱动设备"></a>网络型驱动设备</h2><p>netfilter的相关参考资料为：Linnux5.0.0下，基于Netlink与NetFilter对本机数据包进行筛选监控,<a href="https://blog.csdn.net/qq_40758751/article/details/105117750">https://blog.csdn.net/qq_40758751/article/details/105117750</a> , netfilter数据包过滤, <a href="https://blog.csdn.net/specialsun/article/details/84695519">https://blog.csdn.net/specialsun/article/details/84695519</a><br>因为本文为源Ip数据包信息统计，所以netfilter hook的层级在NF<sub>INET</sub><sub>LOCAL</sub><sub>IN</sub>.<br>Hook 函数为filter<sub>http</sub>(忽略函数名，粘贴过来，不想改了).</p>
<p><a id="org9e48264"></a></p>
<h2 id="字符型设备"><a href="#字符型设备" class="headerlink" title="字符型设备"></a>字符型设备</h2><p>内核态数据在用户态访问需要通过字符型设备驱动进行。因此建立一个字符型设备/dev/IPDataSet 使得用户态能够访问内核 态的数据信息。<br>参考资料：ubuntu 添加字符设备驱动程序, <a href="https://blog.csdn.net/ARAFATms/article/details/79397800">https://blog.csdn.net/ARAFATms/article/details/79397800</a><br>因为上述驱动需要自己手动添加字符设备，所以通过以下方法自动添加设备节点。<br>参考资料：linux驱动：自动创建设备节点, <a href="https://blog.csdn.net/u012247418/article/details/83684029">https://blog.csdn.net/u012247418/article/details/83684029</a></p>
<pre><code>// filename: filter_ip.c
#ifndef __KERNEL__
#define __KERNEL__
#endif  /* __KERNEL__ */

#include &lt;linux/module.h&gt;
#include &lt;linux/init.h&gt;
#include &lt;linux/types.h&gt;
#include &lt;linux/string.h&gt;
//#include &lt;asm/uaccess.h&gt;
#include &lt;linux/netdevice.h&gt;
#include &lt;linux/netfilter_ipv4.h&gt;  // ip4 netfilter,ipv6则需引入相应 linux/netfilter_ipv6.h
#include &lt;linux/ip.h&gt;
#include &lt;linux/tcp.h&gt;
#include &lt;linux/sched.h&gt;
#include &quot;linux/kernel.h&quot;
#include &quot;linux/fs.h&quot;
#include &quot;linux/errno.h&quot;
#include &quot;linux/uaccess.h&quot;
#include &quot;linux/kdev_t.h&quot;
#include &lt;linux/device.h&gt;
#include &lt;linux/time.h&gt;

#define NIPQUAD(addr) \  
((unsigned char *)&amp;addr)[0], \  
((unsigned char *)&amp;addr)[1], \  
((unsigned char *)&amp;addr)[2], \  
((unsigned char *)&amp;addr)[3]  

#define MAX_SIZE 1024 * 1024 * 8
char message[MAX_SIZE] = &quot;&quot;;  //打开设备时会显示的消息
#include &quot;my_rbtree.h&quot;

struct rb_root root = RB_ROOT;
int insert(int key, int timestamp)
&#123;

  roc_node_t *node = NULL;
  node = roc_search(&amp;root, key);
  if(node != NULL) &#123;
    node-&gt;ipcount.count++;
    node-&gt;ipcount.timestamp = timestamp;
    return 1;
  &#125;
  node = (roc_node_t*)kmalloc(sizeof(roc_node_t), GFP_KERNEL );
  node-&gt;ctx = NULL;
  node-&gt;key = key;
  node-&gt;ipcount.count = 1;
  node-&gt;ipcount.timestamp = timestamp;
  return roc_insert(&amp;root, node);

&#125;

struct timeval time;
// 过滤http数据包
unsigned int filter_http(char *type,struct sk_buff *pskb)
&#123;
  __be32 sip,dip;
  int retval = NF_ACCEPT;
  int ret, ms;
  struct sk_buff *skb = pskb;

  struct iphdr *iph = ip_hdr(skb);  // 获取ip头

  sip = iph-&gt;saddr;  
  dip = iph-&gt;daddr;  
  //printk(&quot;Packet for source address: %d.%d.%d.%d destination address: %d.%d.%d.%d\n&quot;, NIPQUAD(sip), NIPQUAD(dip));  

  //sprintf(message, &quot;Packet for source address: %d.%d.%d.%d destination address: %d.%d.%d.%d\n&quot;, NIPQUAD(sip), NIPQUAD(dip));


  do_gettimeofday(&amp;time);  /*第一次去获取时间*/  ms = time.tv_sec * 1000 + time.tv_usec / 1000;  ret = insert(sip, ms);  //if(ret == 1)&#123;      roc_dump(&amp;root);  printk(message);  //&#125;  return retval;&#125;


unsigned int NET_HookLocalIn(void *priv,     struct sk_buff *pskb,     const struct nf_hook_state *state)&#123;  return filter_http(&quot;in&quot;,pskb);&#125;


unsigned int NET_HookLocalOut(void *priv,     struct sk_buff *pskb,     const struct nf_hook_state *state)&#123;  //return filter_http(&quot;out&quot;,pskb);  return NF_ACCEPT;&#125;



unsigned int NET_HookPreRouting(void *priv,     struct sk_buff *pskb,     const struct nf_hook_state *state)&#123;  return NF_ACCEPT;&#125;





unsigned int NET_HookPostRouting(void *priv,     struct sk_buff *pskb,     const struct nf_hook_state *state)&#123;  return NF_ACCEPT;&#125;


unsigned int NET_HookForward(void *priv,     struct sk_buff *pskb,     const struct nf_hook_state *state)&#123;  return NF_ACCEPT;&#125;


// 钩子数组static struct nf_hook_ops net_hooks[] = &#123;  &#123;    .hook         = NET_HookLocalIn,        // 发往本地数据包    .pf            = PF_INET,    .hooknum    =    NF_INET_LOCAL_IN,    .priority    = NF_IP_PRI_FILTER-1,  &#125;,  &#123;    .hook         = NET_HookLocalOut,        // 本地发出数据包    .pf            = PF_INET,    .hooknum    =    NF_INET_LOCAL_OUT,    .priority    = NF_IP_PRI_FILTER-1,  &#125;,  &#123;    .hook         = NET_HookForward,        // 转发的数据包    .pf            = PF_INET,    .hooknum    =    NF_INET_FORWARD,    .priority    = NF_IP_PRI_FILTER-1,  &#125;,  &#123;    .hook        = NET_HookPreRouting,    // 进入本机路由前        .pf            = PF_INET,                    .hooknum    = NF_INET_PRE_ROUTING,            .priority    = NF_IP_PRI_FILTER-1,          &#125;,  &#123;    .hook        = NET_HookPostRouting,    // 本机发出包经路由后        .pf            = PF_INET,                    .hooknum    = NF_INET_POST_ROUTING,            .priority    = NF_IP_PRI_FILTER-1,          &#125;,&#125;;


int my_open(struct inode *inode, struct file *file);int my_release(struct inode *inode, struct file *file);ssize_t my_read(struct file *file, char __user *user, size_t t, loff_t *f);ssize_t my_write(struct file *file, const char __user *user, size_t t, loff_t *f);char* devName = &quot;IPDataSet&quot;;//设备名struct file_operations pStruct =&#123; open:my_open,      release:my_release,      read:my_read,      write:my_write, &#125;;//打开int my_open(struct inode *inode, struct file *file)&#123;  printk(&quot;open lgsDrive OK!\n&quot;);  try_module_get(THIS_MODULE);  return 0;&#125;//关闭int my_release(struct inode *inode, struct file *file)&#123;  printk(&quot;Device released!\n&quot;);  module_put(THIS_MODULE);  return 0;&#125;


//读设备里的信息ssize_t my_read(struct file *file, char __user *user, size_t t, loff_t *f)&#123;  roc_dump(&amp;root);  if(copy_to_user(user,message,t))  &#123;    return -2;  &#125;  return sizeof(message);&#125;//向设备里写信息ssize_t my_write(struct file *file, const char __user *user, size_t t, loff_t *f)&#123;  if(copy_from_user(message,user,t))  &#123;    return -3;  &#125;  return sizeof(message);&#125;


static struct class *drv_class = NULL;int major = 0;//设备号static int __init nf_init(void) &#123;  int ret = 0;  //char device  major = register_chrdev(0, &quot;ipdataset_drv&quot;, &amp;pStruct);  drv_class = class_create(THIS_MODULE, &quot;ipdataset_drv&quot;);  device_create(drv_class, NULL, MKDEV(major, 0), NULL, devName);  //    ret = register_chrdev(0, devName, &amp;pStruct);  //    if (ret &lt; 0)  //    &#123;  //        printk(&quot;failed to register_chrdev.\n&quot;);  //        return -1;  //    &#125;  //    else  //    &#123;  //        printk(&quot;the lgsDrive has been registered!\n&quot;);  //        printk(&quot;id: %d\n&quot;, ret);  //        device_num = ret;  //   //        return 0;  //    &#125;  //net device  ret = nf_register_net_hook(&amp;init_net, net_hooks);  //ret = nf_register_hooks(net_hooks,ARRAY_SIZE(net_hooks));    // 安装钩子  if(ret)  &#123;    printk(KERN_ERR &quot;register hook failed\n&quot;);    return -1;  &#125;  printk(&quot;Start...\n&quot;);  return 0;&#125;void close(void)&#123;  roc_destroy(&amp;root, roc_free);&#125;static void __exit nf_exit(void)&#123;  close();  unregister_chrdev(major, &quot;ipdataset_drv&quot;);  device_destroy(drv_class, MKDEV(major, 0));  class_destroy(drv_class);  //unregister_chrdev(device_num, devName);


  nf_unregister_net_hook(&amp;init_net, net_hooks);  //nf_unregister_hooks(net_hooks,ARRAY_SIZE(net_hooks));    // 卸载钩子  printk(&quot;Exit...\n&quot;);&#125;



module_init(nf_init);module_exit(nf_exit);





MODULE_LICENSE(&quot;Dual BSD/GPL&quot;);MODULE_AUTHOR(&quot;dianwoshishi&quot;);MODULE_DESCRIPTION(&quot;Netfilter IP Statistic&quot;);MODULE_VERSION(&quot;1.0.1&quot;);MODULE_ALIAS(&quot;Netfilter 01&quot;);
</code></pre>
<p><a id="org8ee7f64"></a></p>
<h2 id="用户代码"><a href="#用户代码" class="headerlink" title="用户代码"></a>用户代码</h2><p>上述字符型设备创建了一个字符节点为：/dev/IPDataSet， 在用户态程序中，我们通过Linux编程中提供的read函数对驱动中的数据message进行读取。<br>代码如下：</p>
<pre><code>   #include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#define MAX_SIZE 1024 char message[MAX_SIZE] ;  //打开设备时会显示的消息int main(int num, char *arg[])&#123;    if(2 != num)&#123;        printf(&quot;Usage: %s /dev/IPDataSet\n&quot;, arg[0]);        return -1;    &#125;    int fd = open(arg[1], O_RDWR);    if(0 &gt; fd)&#123;        perror(&quot;open&quot;);        return -1;    &#125;    int ret = read(fd, message, MAX_SIZE);    printf(&quot;read: ret = %d. %s\n&quot;, ret, message);    memset(message, 0, MAX_SIZE);    ret = write(fd, message, MAX_SIZE);    printf(&quot;write: ret = %d.\n&quot;, ret);    close(fd);    return 0;&#125;
</code></pre>
<p><a id="org3f4753d"></a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><a id="org01bad05"></a></p>
<h2 id="Linux-驱动"><a href="#Linux-驱动" class="headerlink" title="Linux 驱动"></a>Linux 驱动</h2><p>熟悉Linux驱动的编写流程。 了解了Linux内核代码与用户代码的不同，比较明显的就是缺少了类似C++ STL类似的好用的库，只能使用类似红黑树（rbtree)这样的数据结构来做一些set的操作，需要对红黑树有一定的了解。<br>网络设备驱动和字符型设备驱动的编写结构都差不多，但是目前也是一知半解，尤其是一些简单操作之外的特性还不了解，例如加锁？多线程？不知道</p>
<p><a id="orgd1e6a5e"></a></p>
<h2 id="Linux内核"><a href="#Linux内核" class="headerlink" title="Linux内核"></a>Linux内核</h2><p>Linux内核的设计模式还是比较令人佩服的，虽然不懂全貌，但是也能从局部出发，贡献一些力量。再一次感受到了设计的魅力。</p>
<p><a id="org4c6ff33"></a></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>一定要在虚拟机中编写、测试驱动，不知道有什么错出现，你就要重启你的电脑，boring！</p>
<p><a id="orgfe8069d"></a></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>linux驱动编写（总结篇）,<a href="https://blog.csdn.net/feixiaoxing/article/details/79913476?spm=1001.2014.3001.5506">https://blog.csdn.net/feixiaoxing/article/details/79913476?spm=1001.2014.3001.5506</a><br>智能路由器设备流量、网速统计及上下线提醒（基于netfilter编程）,<a href="https://blog.csdn.net/u012819339/article/details/50513387?spm=1001.2014.3001.5506">https://blog.csdn.net/u012819339/article/details/50513387?spm=1001.2014.3001.5506</a><br>利用Linux内核模块Netfilter hook UDP报文, <a href="https://blog.csdn.net/qq_41791640/article/details/104933006?spm=1001.2014.3001.5506">https://blog.csdn.net/qq_41791640/article/details/104933006?spm=1001.2014.3001.5506</a><br>Netfilter的使用和实现, <a href="https://blog.csdn.net/zhangskd/article/details/22678659?spm=1001.2014.3001.5506">https://blog.csdn.net/zhangskd/article/details/22678659?spm=1001.2014.3001.5506</a></p>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>netfilter</tag>
        <tag>内核</tag>
      </tags>
  </entry>
  <entry>
    <title>互联网发展简史(1)ARPANET的建立</title>
    <url>/2021/05/30/%E4%BA%92%E8%81%94%E7%BD%91%E5%8F%91%E5%B1%95%E7%AE%80%E5%8F%B2(1)/</url>
    <content><![CDATA[<p>原文为<a href="https://zhuanlan.zhihu.com/p/376627686">知乎</a>，现转移到个人博客。<br><a href="https://zhuanlan.zhihu.com/p/376627686" target="_blank" class="LinkCard">知乎原文</a></p>
<p>原文为<a href="https://mp.weixin.qq.com/s/eiYEhlHfRICdkzf2aXxCDg">微信公众号原文</a>，现转移到个人博客。<br><a href="https://mp.weixin.qq.com/s/eiYEhlHfRICdkzf2aXxCDg" target="_blank" class="LinkCard">微信公众号原文</a></p>
<h2 id="互联网发展简史-1-ARPANET的建立"><a href="#互联网发展简史-1-ARPANET的建立" class="headerlink" title="互联网发展简史(1)ARPANET的建立"></a>互联网发展简史(1)ARPANET的建立</h2><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>[TOC]</p>
<p>Internet发展简史（ARPANET的建立）</p>
<h3 id="1955年"><a href="#1955年" class="headerlink" title="1955年"></a>1955年</h3><p>要了解互联网的起源，我们必须回到1957年。这一年大家都致力于收集有关高层大气在一个强烈的太阳活动时期的信息。1955年，艾森豪威尔宣布，作为活动的一部分，美国希望发射一颗小型地球轨道卫星。克里姆林宫宣布也希望这样做。美国的计划集中在精密的三级火箭上，但在俄罗斯他们采取了更直接的方法。把四枚军用火箭绑在一起。苏联的行为似乎一夜之间消除了自13年前第一颗核弹爆炸以来，美国一直享有的无懈可击的感觉。立即的反应之一是在国防部内设立了高级研究计划局。它的任务是将最先进的技术应用于美国国防，并避免(再次)被敌人的技术进步吓到。在1958年10月美国国家航空航天局成立之前，它还被授予了美国卫星计划的临时控制权。</p>
<p>‌ARPA成为了美国国防努力的技术智囊团，直接雇佣了几百名顶级科学家，并拥有足够的预算将研究分包给美国其他顶级机构。尽管先进的计算技术将主导其工作，但ARPA最初的活动重点是空间、弹道导弹和核试验监测。即便如此，从一开始，ARPA就对它的操作基地和它的分包商之间的通信很感兴趣，最好是通过各种计算机之间的直接连接。</p>
<h3 id="1962年"><a href="#1962年" class="headerlink" title="1962年"></a>1962年</h3><p>1962年，ARPA启动了一个计算机研究项目，并任命麻省理工学院(MIT)的科学家约翰·利克利德(John Licklider)为负责人。利克里德刚刚发表了他关于“银河网络”概念的第一份备忘录<strong>……一个未来的愿景，电脑将联网，并将接近每个人。</strong>在ARPA内部，Leonard Klienrock已经在研究如何将信息分解成“数据包”，将它们分别发送到目的地，然后在另一端重新组装。这将比打开一行并通过该行发送信息更具灵活性。例如，系统将不依赖于单个路由，如果文件在传输前被破坏，将更难以被窃听……两者都有有用的安全优势。1965年，人们发现了电话网络在运行程序和传输数据方面的不足。当时，伯克利和麻省理工学院的计算机通过低速拨号电话线连接起来，成为有史以来第一个“广域网”(WAN)。</p>
<p>‌到1966/67年，研究工作已经发展到足以让计算机研究部的新主管伦纳德·罗伯茨(Leonard Roberts)发布了一个名为阿帕网(ARPANET)的计算机网络系统计划。当这些计划发表显然是彼此独立的,和无知的彼此的工作,团队在麻省理工学院,国家物理实验室(英国),兰德公司都致力于广泛的区域网络的可行性,及其最佳创意纳入阿帕网的设计。最后的要求是设计一个允许计算机发送和接收消息和数据的协议，称为接口消息处理器(IMPs)。这方面的工作在1968年完成。</p>
<h3 id="‌1969年"><a href="#‌1969年" class="headerlink" title="‌1969年"></a>‌1969年</h3><p>‌美军在ARPA（阿帕网，美国国防部研究计划署）制定的协定，该协定下将美国西南部的大学UCLA(加利福尼亚大学洛杉矶分校)、Stanford ResearchInstitute(斯坦福大学研究学院)、UCSB(加利福尼亚大学)和UniversityofUtah(犹他州大学)的四台主要计算机相连，形成了互联网最初的样子。</p>
<p><img src="https://www.let.leidenuniv.nl/history/ivh/arpanet.gif" alt="ARPANET(1969)"></p>
<h3 id="1971年"><a href="#1971年" class="headerlink" title="1971年"></a>1971年</h3><p>这个协定有剑桥大学的BBN和MA执行，在1969年12月开始联机。到1970年6月，MIT(麻省理工学院)、Harvard(哈佛大学)、BBN和SystemsDevelopmentCorpinSantaMonica(加州圣达莫尼卡系统发展公司)加入进来。到1972年1月，Stanford(斯坦福大学)、MIT’sLincolnLabs(麻省理工学院的林肯实验室)、Carnegie-Mellon(卡内基梅隆大学)和Case-WesternReserveU加入进来。紧接着的几个月内NASA/Ames(国家航空和宇宙航行局)、Mitre、Burroughs、RAND(兰德公司)和theUofIllinois(伊利诺利州大学)也加入进来。到1971年12月，阿帕网将23台主机相互连接起来。由此，<strong>ARPAnet成为现代计算机网络诞生的标志。</strong></p>
<p><img src="https://www.let.leidenuniv.nl/history/ivh/arpanet1.gif" alt="ARPANET(1971)"></p>
<p>自此第一个真正的计算机网络诞生。</p>
<p>‌</p>
<h3 id="参考连接："><a href="#参考连接：" class="headerlink" title="参考连接："></a>参考连接：</h3><p>‌[1] <a href="https://www.let.leidenuniv.nl/history/ivh/chap2.htm#The%20Creation%20of%20ARPANET">Chapter Two: From ARPANET to World Wide Web</a> , </p>
<p>[‌2] <a href="https://baijiahao.baidu.com/s?id=1639113082776464538&wfr=spider&for=pc">关于互联网的由来和发展简史</a></p>
<p>欢迎关注我的微信公众号，扫描下方二维码，就可以找到我，我会持续为你分享 IT 技术和珠宝知识。</p>
<p><img src="https://pic1.zhimg.com/80/v2-8ff04a9934840c3c552ed41497bc4748_720w.jpg" alt="欢迎关注我的微信公众号，扫描下方二维码，就可以找到我，我会持续为你分享 IT 技术和珠宝知识"></p>
<p>也可以关注我的个人博客</p>
<p><a href="https://dianwoshishi.github.io/">点我试试的个人博客</a></p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>互联网</tag>
        <tag>历史</tag>
      </tags>
  </entry>
  <entry>
    <title>互联网发展简史(2)从ARPANET到Internet</title>
    <url>/2021/06/01/%E4%BA%92%E8%81%94%E7%BD%91%E5%8F%91%E5%B1%95%E7%AE%80%E5%8F%B2(2)/</url>
    <content><![CDATA[<p><strong>今日珠宝</strong></p>
<p><img src="https://pic4.zhimg.com/80/v2-5b67214ba6baf09e996ae7954768f217_720w.jpg"></p>
<p>原文为知乎，现转移到个人博客。<br><a href="https://zhuanlan.zhihu.com/p/376893651" target="_blank" class="LinkCard">知乎原文</a></p>
<p>原文为微信公众号文章，现转移到个人博客。<br><a href="https://mp.weixin.qq.com/s/LH6PU0afKLVra6Kn6coemQ" target="_blank" class="LinkCard">微信公众号原文</a></p>
<h2 id="互联网发展简史-2-从ARPANET到Internet"><a href="#互联网发展简史-2-从ARPANET到Internet" class="headerlink" title="互联网发展简史(2) 从ARPANET到Internet"></a>互联网发展简史(2) 从ARPANET到Internet</h2><h3 id="ARPANET公开亮相"><a href="#ARPANET公开亮相" class="headerlink" title="ARPANET公开亮相"></a>ARPANET公开亮相</h3><p><strong>1972年10月，ARPANET公开亮相</strong>。在华盛顿举行的第一届国际计算机与通信会议上，ARPA的科学家们演示了这个系统：<strong>将来自40个不同地点的计算机连接在一起</strong>。</p>
<h3 id="ARPANET发展"><a href="#ARPANET发展" class="headerlink" title="ARPANET发展"></a>ARPANET发展</h3><p>与此同时，美国国防部高级研究计划局(ARPA)的科学家们正在改进该系统，扩大其能力。</p>
<ul>
<li><p>1972年，他们成功地采用了一种新的程序，即我们现在所称的<strong>电子邮件</strong>，允许在网上发送信息，允许人与人之间的直接交流。</p>
</li>
<li><p>同样在70年代早期，科学家们开发了主机(host)对主机的协议。 在此之前，系统只允许一个“远程终端”访问每个单独主机的文件。 新的协议允许访问主机的程序(在连接期间有效地将两台主机合并为一台)。  </p>
</li>
<li><p>1974年，ARPA的科学家们与斯坦福大学的专家们密切合作，开发出一种使不同的网络能够相互交流的“共同语言”。这被称为**传输控制协议/互联网协议(TCP/IP)**。</p>
<blockquote>
<p>TCP/IP的发展标志着网络发展的一个关键阶段，现如今使用最广泛的协议仍然是TCP/IP协议，其分层、解耦合的设计是他生命力所在。</p>
</blockquote>
</li>
</ul>
<h3 id="各种NET的”百家争鸣”"><a href="#各种NET的”百家争鸣”" class="headerlink" title="各种NET的”百家争鸣”"></a>各种NET的”百家争鸣”</h3><p>前面讲到ARPANET的公开亮相，激发了整个西方世界科学界对互联网的进一步的研究。很快其他的网络也出现了。在这个阶段，各类网络各自为战，提出了自己的技术和协议。华盛顿会议还成立了一个互联工作组(IWG，Internetworking Working Group)来协调正在进行的研究。例如：</p>
<ul>
<li>1974年，斯坦福大学开通了<strong>Telenet</strong>，这是第一个公开访问的公共“分组数据服务”(ARPANET的商业版本)。</li>
<li>上世纪70年代，美国能源部为磁性聚变能的研究人员建立了<strong>MFENet</strong>，这催生了致力于高能物理的HEPNet。这启发了NASA的物理学家们建立了空间物理学家<strong>SPAN</strong>。</li>
<li>1976年，美国电话电报公司贝尔实验室开发了一种<strong>Unix-to-Unix协议</strong>，并免费分发给所有使用Unix的计算机用户(因为Unix是大学使用的主要操作系统，这为学术界打开了网络的大门)。</li>
<li>在1979年<strong>Usenet</strong>建立，一个开放的系统专注于电子邮件通信和致力于“新闻组”的开放，并仍然蓬勃发展到今天。</li>
<li>在1981年，纽约城市大学开发了<strong>Bitnet</strong>，用来连接美国东部大学的科学家，使用IBM计算机，不管学科。</li>
<li><strong>CSNet</strong>由美国国家科学基金会资助，旨在促进大学、工业和政府计算机科学家的交流。</li>
<li>1982年，欧洲版本的Unix网络<strong>Eunet</strong>建立，连接了英国、斯堪的纳维亚和荷兰的网络。</li>
<li>1984年又建立了欧洲版本的Bitnet，称为<strong>EARN</strong>(欧洲学术和研究网络)。 </li>
</ul>
<p>在这一时期，世界仍然相当混乱，有过多的相互竞争的技术和协议。<strong>ARPANET仍然是整个系统的主干。</strong></p>
<p><img src="https://www.let.leidenuniv.nl/history/ivh/arpanet2.gif" alt="ARPANET (1980)"></p>
<h3 id="TCP-IP一统天下"><a href="#TCP-IP一统天下" class="headerlink" title="TCP/IP一统天下"></a>TCP/IP一统天下</h3><p>虽然1974年标志着TCP/IP协议的开始，但它需要经过几年的修改和重新设计，才得以竞争和普遍采用。例如，在20世纪70年代中期，已经设计了一个简化版，可以并入正在开发的新型微型计算机中。第二个设计挑战是开发一个与每个计算机网络(包括阿帕网本身)兼容的软件版本。</p>
<p>最终在1982年， TCP/IP 协议统一了天下，成为了标准，<strong>使用TCP/IP标准的互联网诞生了！</strong></p>
<p>下一期，我们将讲述：从Internet到WWW，从因特网到万维网。敬请关注</p>
<h3 id="参考连接："><a href="#参考连接：" class="headerlink" title="参考连接："></a>参考连接：</h3><p>‌[1] <a href="https://www.let.leidenuniv.nl/history/ivh/chap2.htm#The%20Creation%20of%20ARPANET">Chapter Two: From ARPANET to World Wide Web</a> , </p>
<p>[‌2] <a href="https://baijiahao.baidu.com/s?id=1639113082776464538&wfr=spider&for=pc">关于互联网的由来和发展简史</a></p>
<hr>
<p> 欢迎关注我的微信公众号，扫描下方二维码，就可以找到我，我会持续为你分享 IT 技术和珠宝知识。</p>
<p><img src="https://pic1.zhimg.com/80/v2-8ff04a9934840c3c552ed41497bc4748_720w.jpg" alt="欢迎关注我的微信公众号，扫描下方二维码，就可以找到我，我会持续为你分享 IT 技术和珠宝知识"></p>
<p>也可以关注我的个人博客</p>
<p><a href="https://dianwoshishi.github.io/">点我试试的个人博客</a></p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>互联网</tag>
        <tag>历史</tag>
      </tags>
  </entry>
  <entry>
    <title>互联网发展简史(3)从Internet到WWW</title>
    <url>/2021/06/01/%E4%BA%92%E8%81%94%E7%BD%91%E5%8F%91%E5%B1%95%E7%AE%80%E5%8F%B2(3)/</url>
    <content><![CDATA[<p>新品ISN潮流质感钻石G项链气质百搭款</p>
<p><img src="/2021/06/01/%E4%BA%92%E8%81%94%E7%BD%91%E5%8F%91%E5%B1%95%E7%AE%80%E5%8F%B2(3)/image-20210601204355672.png" alt="新品ISN潮流质感钻石G项链气质百搭款"></p>
<p>前文讲到，TCP/IP协议助力ARPANET统一了网络协议标准，自此使用TCP/IP协议标准的Internet诞生了。</p>
<p>到目前为止，网络的发展几乎完全是“科学主导的”，本节我们将讲述Internet到万维网(WWW)的发展。</p>
<h3 id="网络出现瓶颈"><a href="#网络出现瓶颈" class="headerlink" title="网络出现瓶颈"></a>网络出现瓶颈</h3><p>此前计算机能力和速度的并行进步使Internet得以扩张。但规模扩张的同时也带来了问题。</p>
<p>到20世纪80年代初，当互联网正式开始运营时</p>
<ul>
<li>连接到网络上的计算机“主机”比最初设想的要多(1984年主机的数量首次超过1000台);</li>
<li>每台主机的流量要大得多(主要是因为电子邮件的成功)。</li>
</ul>
<p>越来越多的人预言，整个网络最终会陷入瘫痪。</p>
<h3 id="解决网络瓶颈"><a href="#解决网络瓶颈" class="headerlink" title="解决网络瓶颈"></a>解决网络瓶颈</h3><p>这一时期产生了两个重要事件，有效的缓解了网络瓶颈，并促进了网络的发展：</p>
<p><strong>第一个重要的发展是1984年引入的域名服务器(Domain Name System)。</strong></p>
<ul>
<li>DNS系统使得主机的名称更容易记住，用户不用去记住每一个又数字组成的IP地址，如116.25.XXX.XXX，而是类似于<a href="http://www.example[.]com的容易记住的名字。">www.example[.]com的容易记住的名字。</a></li>
<li>DNS系统在互联网地址中引入了一些分层结构,更加利于组织众多域名和主机，如edu(教育),com(商业)、gov(政府)和org(组织)和一系列国家代码。</li>
</ul>
<p><strong>第二个是各国政府决定鼓励在整个高等教育系统中使用互联网，并制定了一系列利好政策，促进了互联网的进一步统一和繁荣。</strong></p>
<p>1984年，英国政府宣布建立JANET(联合学术网络)，为英国大学服务；1985年，基于同样的目的，美国国家科学基金会(National Science Foundation)建立了国家科学基金网(NSFNet)(为其提供资助的条件是，“校园内所有合格用户”都必须能够访问该网络)。美国的这项计划涉及了一系列对互联网发展至关重要的决定：</p>
<ul>
<li><p>所有参与者都必须使用TCP/IP协议</p>
</li>
<li><p>联邦机构将分担建立公共基础设施(如跨洋连接)的费用并支持网关</p>
</li>
<li><p>NSFNet与其他科学网络(包括阿帕网ARPANet)签署了共享基础设施的“no-metered-cost”协议，为所有后续协议做出了示范。</p>
</li>
<li><p>鼓励进一步国际合作</p>
</li>
<li><p>NSFNet同意为美国互联网服务提供“主干”，并提供5台“超级计算机”来服务通信。第一批计算机提供每秒56 000字节(56KB/s)的网络能力</p>
<blockquote>
<p>国家科学基金网（NSFNet）的建立对互联网产生了巨大的影响。</p>
<ul>
<li><p>首先，它打破了网络的容量瓶颈。</p>
</li>
<li><p>其次，它促进了互联网使用的激增。之前用了十年的时间，联网的主机数量才突破了千台大关；到1986年，主机的数量已经达到5000台，一年后这个数字攀升到28000台。</p>
</li>
</ul>
</blockquote>
</li>
</ul>
<p><img src="https://www.let.leidenuniv.nl/history/ivh/nsf_backbone.gif" alt="NSF骨干网"></p>
<p><img src="https://www.let.leidenuniv.nl/history/ivh/nsfnet.gif" alt="NSFnet1991"></p>
<h3 id="互联网商业化发展"><a href="#互联网商业化发展" class="headerlink" title="互联网商业化发展"></a>互联网商业化发展</h3><p>我们注意到，之前网络的参与者基本上没有商业用户，这是由于NSFNet将商业用户排除在其网络之外。</p>
<p>虽然NSFNet将商业用户排除在网络之外，但并不意味着他们的对互联网不感兴趣。多年来，硬件和软件供应商一直在将TCP/IP添加到他们的产品包中，但他们对产品如何工作缺乏经验，因此他们在提供满足需求的产品方面遇到了困难。这时，互联网活动委员会(IAB)迈出了一步：</p>
<p>1985年，IAB组织了第一个专门针对私营部门的研讨会，讨论TCP/IP协议的潜力(和目前的限制)， 这次讨论在在政府/学术科学家和私营部门之间，以及私营企业家之间进行。其中一个重要的内容就是：确保他们的产品的互操作性</p>
<h3 id="“晦涩难懂”的互联网"><a href="#“晦涩难懂”的互联网" class="headerlink" title="“晦涩难懂”的互联网"></a>“晦涩难懂”的互联网</h3><p>到1989年，主机的数量首次超过了10万，并在一年后攀升至30万。</p>
<p>但在这个阶段，<strong>互联网仍然只是少数人内行的网络</strong>，对外行来说仍然是一个相当令人生畏的地方。例如：查找数据的访问命令从复杂到难以理解，可用的文档大多是(高度)科学的，显示不吸引人(信使脚本，没有颜色)，寻找东西是一件棘手的事情，传输时间相对较慢)。对商业部门的主要吸引力是电子邮件设施和使用电子邮件、新闻组、“聊天”设施和电脑游戏。</p>
<h3 id="互联网发展的分界点"><a href="#互联网发展的分界点" class="headerlink" title="互联网发展的分界点"></a>互联网发展的分界点</h3><p>转眼来到了上世纪80年代末和90年代初，这个时间点是互联网发展的一个分界点，原因有几个：</p>
<ul>
<li>1990年，阿帕网(1983年被剥夺了军事研究功能)成为了自身成功的牺牲品。</li>
<li>1990年，蒙特利尔麦吉尔大学开发了第一个用于查找和检索计算机文件的互联网搜索引擎Archie。</li>
<li>1991年，美国国家科学基金会取消了对私人访问其骨干计算机的限制，</li>
<li>“信息高速公路”项目应运而生。这是为了普及戈尔的高性能计算法案而起的名字，该法案为进一步研究计算和改善美国互联网结构的基础设施提供了资金。</li>
<li>1992- 1996年期间，其最大拨款为国家科学基金15亿美元，NASA 6亿美元，能源部660美元。</li>
<li>1991年，万维网(WWW)问世</li>
</ul>
<p>下一节，我们将讲述WWW(万维网)的发展。敬请关注。</p>
<h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p>[1] <a href="https://www.let.leidenuniv.nl/history/ivh/chap2.htm">Chapter Two: From ARPANET to World Wide Web</a></p>
<p>欢迎关注我的微信公众号，扫描下方二维码，就可以找到我，我会持续为你分享 IT 技术和珠宝知识。</p>
<p><img src="https://pic1.zhimg.com/80/v2-8ff04a9934840c3c552ed41497bc4748_720w.jpg" alt="欢迎关注我的微信公众号，扫描下方二维码，就可以找到我，我会持续为你分享 IT 技术和珠宝知识"></p>
<p>也可以关注我的个人博客</p>
<p><a href="https://dianwoshishi.github.io/">点我试试的个人博客</a></p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>互联网</tag>
        <tag>历史</tag>
      </tags>
  </entry>
  <entry>
    <title>互联网发展简史(4) WWW</title>
    <url>/2021/06/03/%E4%BA%92%E8%81%94%E7%BD%91%E5%8F%91%E5%B1%95%E7%AE%80%E5%8F%B2(4)%20WWW/</url>
    <content><![CDATA[<h2 id="互联网发展简史-4-WWW"><a href="#互联网发展简史-4-WWW" class="headerlink" title="互联网发展简史(4) WWW"></a>互联网发展简史(4) WWW</h2><p><img src="https://pic3.zhimg.com/80/v2-c2cfb99f03d33c3f8fc20a95b220fe82_720w.jpg" alt="18k金ins气质风CD耳钉"></p>
<p>万维网(World Wide Web, WWW)是可以通过一种被称为超文本传输协议(HTTP)来搜索和检索网站。该协议简化了地址的书写（使用前面所说的DNS系统），自动在互联网上搜索指定的地址，并自动调出文件查看，正如你现在浏览本文时看到的一样，不过那时候可没有现在这么酷。</p>
<h3 id="万维网"><a href="#万维网" class="headerlink" title="万维网"></a>万维网</h3><p>万维网的概念是1989年由Tim Berners-Lee和CERN(日内瓦的欧洲高能物理中心)的科学家们设计(前文说过研究资料在网上开放，但是需要自己检索，但他们觉得检索文件太麻烦，为了简化检索程序，提出了万维网的概念)。1990年，他们开发了一个“浏览器/编辑器”程序，并命名为“万维网”(World Wide Web)。该程序在ftp网站上免费发布，这极大的简化了检索程序。 这个系统可以让链接隐藏在文本后面(使用超文本标记语言，HTML)，点击“鼠标”就可以激活。但这种新系统似乎并没有迅速应用起来，到1992年底，世界上只有50个网站，一年后这个数字仍然不超过150个。</p>
<p><img src="https://www.let.leidenuniv.nl/history/ivh/screen1994.gif" alt="An early WWW screen (1994)"></p>
<p>上面的图片显示了1994年浏览器技术的“最先进”(早期版本不支持颜色，徽号和图表也在不同的窗口中)。</p>
<h3 id="点燃Web"><a href="#点燃Web" class="headerlink" title="点燃Web"></a>点燃Web</h3><h4 id="Mosaic-马赛克"><a href="#Mosaic-马赛克" class="headerlink" title="Mosaic(马赛克)"></a>Mosaic(马赛克)</h4><p>1993年，NCSA(美国国家超级计算应用中心，伊利诺斯州)的Mark Andreesen推出了Mosaic x(没错，这就是后来的网景浏览器，中文翻译可以叫做马赛克… …互联网历史上第一个获普遍使用和能够显示图片的网页浏览器)。它易于安装、使用，而且有24小时的客户支持。它还极大地提高了图形功能和安装的许多我们现在熟悉的特性(被后来Netscape Navigator和比尔·盖茨的Internet Explorer继承)。像其他许多互联网创新一样，Mosaic的试用版也免费提供给教育社区。Mosaic x很快就成为了一个大热门。到1994年，在世界各地的计算机上安装了成千上万个版本。</p>
<blockquote>
<p>当时的Mosaic开发的中心人物Mark Andreesen(这哥们曾经说，在网景面前，Windows只是一堆设计拙劣的驱动程序)和Silicon Graphic(计算机绘图用的高性能计算机制造公司，简称为SGI)公司的创始人吉姆·克拉克设立了「MOSAIC Communication Corp.」，这家公司之后1994年11月改名为「Netscape Communication Corp.」，中译为<strong>网景</strong>。于1997年1月7日正式终止开发和支持</p>
<p>虽然网景消失了，但是从html的img标签开始，到创造javascript，开创SSL，奠定了未来几十年的互联网Web基础，当年的星星之火现已燎原。</p>
<p>第一次浏览器大战后，在1998年网景公开了浏览器源代码，并将其命名为Mozilla。2004年基于Mozilla源代码，另一个杰出的浏览器诞生了，它就是Firefox（火狐）</p>
<p>笔者认为，这个公司在互联网历史上真的是神一样的存在。</p>
</blockquote>
<p><img src="https://www.let.leidenuniv.nl/history/ivh/mosaic.gif" alt="An early opening screen for Mosaic and Netscape"></p>
<p><img src="https://www.let.leidenuniv.nl/history/ivh/netscape.gif" alt="An early opening screen for Mosaic and Netscape"></p>
<p>HTML可以创建具有吸引力的图形网站，这些网站可以通过新一代的浏览器轻松访问，这为全新的群体打开了Web。</p>
<p>到目前为止，Web已经服务于两个主要社区——科学界(访问在线文档)和更广泛的“网民”(网民)社区(访问电子邮件和新闻组设施)。现在商业网站开始大量涌现，紧随其后的是不远处的当地学校/俱乐部/家庭网站。功能更强大(也更便宜)的个人电脑(增加了网民数量和潜在的商业市场)的出现，以及通信基础设施容量的增加，加速了这些发展。</p>
<h4 id="蓬勃发展"><a href="#蓬勃发展" class="headerlink" title="蓬勃发展"></a>蓬勃发展</h4><p>1994年，有3,200万个主机和3,000个网站。12个月后，主机数量翻了一番，网站数量攀升至2.5万个。到第二年年底，主机的数量又翻了一番，网站的数量也增加了十倍以上。顺便提一下，在那一年，莱顿大学历史系建立了自己的网站，使其网站成为有史以来第一批的网站之一。<strong>第二年，我们开设了“历史学家的互联网”课程，在经济和社会历史板块内，我们开始开发“基于课程”的网站</strong>(云课堂？？？)。这一切都发生在1997年，当时集成到网络的主机数量已经达到了1,950万台，而网站的数量已经激增到1,200万台。据2001年1月的最新统计，主机数量达到1.1亿，网站数量达到3000万。</p>
<h3 id="互联网和网络之间的区别是什么"><a href="#互联网和网络之间的区别是什么" class="headerlink" title="互联网和网络之间的区别是什么?"></a>互联网和网络之间的区别是什么?</h3><p>Tim Berners-Lee(没错，就是提出万维网概念的那个哥们)经常被问到同样的问题，他的回答是:</p>
<ul>
<li>“互联网(‘Net’)是网络的网络。基本上它是由电脑和电缆制成的。Vint Cerf 和 Bob Khan所做的是弄清楚如何用它来发送小“包”的信息。正如Vint Cerf 指出的，数据包有点像明信片，上面有一个简单的地址。如果你把正确的地址放在一个数据包上，并把它交给任何一台作为网络一部分相连的计算机，每台计算机就会找出下一条电缆将它发送下去，这样它就能到达目的地。这就是互联网的作用。它可以在一秒钟之内将数据包发送到世界上的任何地方。</li>
<li>网络是一个抽象的(想象的)信息空间。<ul>
<li>在互联网上，你可以找到电脑——在Web上，你可以找到文件、声音、视频，….信息。</li>
<li>在互联网上，连接是计算机之间的电缆;在Web上，连接是超文本链接。</li>
<li>互联网的存在是由于网络上计算机之间通信的程序。没有互联网就没有Web。万维网使互联网变得有用（现在这个说法好像不太准确），因为人们对信息真的很感兴趣(更不用说知识和智慧了!)，而不是真的想知道关于计算机和电缆的知识。</li>
</ul>
</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>Chapter Two: From ARPANET to World Wide Web</p>
<p>欢迎关注我的微信公众号，扫描下方二维码，就可以找到我，我会持续为你分享 IT 技术和珠宝知识。</p>
<p><img src="https://pic1.zhimg.com/80/v2-8ff04a9934840c3c552ed41497bc4748_720w.jpg" alt="欢迎关注我的微信公众号，扫描下方二维码，就可以找到我，我会持续为你分享 IT 技术和珠宝知识"></p>
<p>也可以关注我的个人博客:<a href="https://dianwoshishi.github.io/">点我试试的个人博客</a></p>
<p><a href="https://dianwoshishi.github.io/" target="_blank" class="LinkCard">点我试试的个人博客</a></p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>互联网</tag>
        <tag>历史</tag>
      </tags>
  </entry>
</search>
