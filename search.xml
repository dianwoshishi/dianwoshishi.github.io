<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2021/05/29/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>基于netfilter的IP数据统计设计</title>
    <url>/2021/05/29/%E5%9F%BA%E4%BA%8Enetfilter%E7%9A%84IP%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E8%AE%BE%E8%AE%A1%E4%B8%8ELinux%E9%A9%B1%E5%8A%A8%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h1><ol>
<li> <a href="#orgab76e7a">背景</a></li>
<li><a href="#org02ac451">IP信息统计</a><ol>
<li> <a href="#org62d4d73">统计信息设计</a></li>
<li> <a href="#org44f97b2">存储数据结构</a></li>
</ol>
</li>
<li><a href="#orgde188bf">Linux驱动</a><ol>
<li> <a href="#orgc0bb933">网络型驱动设备</a></li>
<li> <a href="#org9e48264">字符型设备</a></li>
<li> <a href="#org8ee7f64">用户代码</a></li>
</ol>
</li>
<li><a href="#org3f4753d">总结</a><ol>
<li> <a href="#org01bad05">Linux 驱动</a></li>
<li> <a href="#orgd1e6a5e">Linux内核</a></li>
<li> <a href="#org4c6ff33">其他</a></li>
</ol>
</li>
<li> <a href="#orgfe8069d">参考资料</a></li>
</ol>
<p><a id="orgab76e7a"></a></p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>当今社会，没有都有自己的信息处理设备，如手机、计算机甚至可能是路由器。在使用这些设备的时候，我们想知道的一件事就是，我的电脑和那些设备有过通信，通信情况怎么样，以便在网络出现问题，如拥塞，或是自己主机被黑客控制出现异常数据的时候，能够通过上述统计信息快速定位问题所在。因此本文通过Linux驱动中的netfilter对IP数据报中的IP信息进行统计，通过字符型驱动实现用户态查看统计信息，达到了统计主机通信的目的，为进一步做好异常处理打下了基础。</p>
<p><a id="org02ac451"></a></p>
<h1 id="IP信息统计"><a href="#IP信息统计" class="headerlink" title="IP信息统计"></a>IP信息统计</h1><p><a id="org62d4d73"></a></p>
<h2 id="统计信息设计"><a href="#统计信息设计" class="headerlink" title="统计信息设计"></a>统计信息设计</h2><p>统计对象为源IP地址，信息内容目前设计为：IP出现频次，最后一个IP数据包出现时的时间戳。</p>
<pre><code>typedef struct IPData&#123;
  int timestamp;
  int count
&#125;ipdata;
</code></pre>
<p><a id="org44f97b2"></a></p>
<h2 id="存储数据结构"><a href="#存储数据结构" class="headerlink" title="存储数据结构"></a>存储数据结构</h2><p>由于在Linux Kernel中没有C++的set，map等数据结构，因此使用其提供的红黑树实现IP信息的快速存储和读取。其中红黑树节点的信息如下所示：</p>
<pre><code>   typedef struct roc_node_s
&#123;
    struct rb_node node;
    void *ctx;
    int key;
    ipdata ipcount;
&#125;roc_node_t;
</code></pre>
<p>红黑树的实现使用Linux Kernel自带的rbtree数据结构，头文件为：</p>
<pre><code>#include &lt;linux/rbtree.h&gt;
</code></pre>
<p>红黑树插入，删除等代码参考链接为：<a href="https://blog.csdn.net/chn475111/article/details/52594457">https://blog.csdn.net/chn475111/article/details/52594457</a>.</p>
<pre><code>/**
 * filename: my_rbtree.h
 * @author lijk@.infosec.com.cn
 * @version 0.0.1
 * @date 2016-9-20 11:52:06
 */
#include &lt;linux/string.h&gt;
#include &lt;linux/rbtree.h&gt;
typedef struct IPData&#123;
  int timestamp;
  int count
&#125;ipdata;
typedef struct roc_node_s
&#123;
    struct rb_node node;
    void *ctx;
    int key;
    ipdata ipcount;
&#125;roc_node_t;

typedef void (*roc_cb)(void*);

roc_node_t* roc_search(struct rb_root *root, int key)
&#123;
    struct rb_node *node = root-&gt;rb_node;
    while(node)
    &#123;
        roc_node_t *data = rb_entry(node, roc_node_t, node);
        int result = key - data-&gt;key;

        if (result &lt; 0)
            node = node-&gt;rb_left;
        else if (result &gt; 0)
            node = node-&gt;rb_right;
        else
            return data;
    &#125;
    return NULL;
&#125;

int roc_insert(struct rb_root *root, roc_node_t *data)
&#123;
    struct rb_node **new = &amp;(root-&gt;rb_node), *parent = NULL;
    while(*new)
    &#123;
        roc_node_t *this = rb_entry(*new, roc_node_t, node);
        int result = data-&gt;key - this-&gt;key;

        parent = *new;
        if (result &lt; 0)
            new = &amp;((*new)-&gt;rb_left);
        else if (result &gt; 0)
            new = &amp;((*new)-&gt;rb_right);
        else
            return 0;
    &#125;

    rb_link_node(&amp;data-&gt;node, parent, new);
    rb_insert_color(&amp;data-&gt;node, root);

    return 1;
&#125;

void roc_erase(struct rb_root *root, int key, roc_cb cb)
&#123;
    roc_node_t *data = roc_search(root, key);
    if(data)
    &#123;
        rb_erase(&amp;data-&gt;node, root);
        RB_CLEAR_NODE(&amp;data-&gt;node);
        if(cb) cb(data);
    &#125;
&#125;

void roc_destroy(struct rb_root *root, roc_cb cb)
&#123;
    roc_node_t *pos = NULL;
    struct rb_node *node = NULL;
    while((node = rb_first(root)))
    &#123;
        pos = rb_entry(node, roc_node_t, node);
    #ifdef _DEBUG
        sprintf(message, &quot;key = %d\n&quot;, pos-&gt;key);
    #endif
        rb_erase(&amp;pos-&gt;node, root);
        RB_CLEAR_NODE(&amp;pos-&gt;node);
        if(cb) cb(pos);
    &#125;
&#125;

void roc_dump(struct rb_root *root)
&#123;
    struct rb_node *node = NULL;
  int sip, count, timestamp;
  //printk(&quot;roc_dump&quot;);
    memset(message, 0, MAX_SIZE);
    for(node = rb_first(root); strlen(message) &lt; MAX_SIZE &amp;&amp; node != NULL; node = rb_next(node))&#123;

  sip = (unsigned int)rb_entry(node, roc_node_t, node)-&gt;key ;   
  count = (unsigned int)rb_entry(node, roc_node_t, node)-&gt;ipcount.count ;   
  timestamp = (unsigned int)rb_entry(node, roc_node_t, node)-&gt;ipcount.timestamp ;  
  sprintf(message, &quot;%s%d.%d.%d.%d|%d|%d,&quot;,message, NIPQUAD( sip), count, timestamp);
      //printk(message);
    &#125;
&#125;

void roc_free(void *ptr)
&#123;
    roc_node_t *node = (roc_node_t*)ptr;
    if(node)
    &#123;
        if(node-&gt;ctx) kfree(node-&gt;ctx);
        kfree(node);
    &#125;
&#125;

int test(int argc, char const *argv[])
&#123;
    struct rb_root root = RB_ROOT;

    int loop = 0;
    roc_node_t *node = NULL;
    for(loop = 0; loop &lt; 100; loop ++)
    &#123;
        node = (roc_node_t*)kmalloc(sizeof(roc_node_t), GFP_KERNEL );
        if(node == NULL)
            break;
        node-&gt;ctx = NULL;
        node-&gt;key = loop;
        roc_insert(&amp;root, node);
    &#125;

#if 0
    for(loop = 0; loop &lt; 100; loop ++)
        roc_erase(&amp;root, loop, roc_free);
#endif

    roc_dump(&amp;root);
    roc_destroy(&amp;root, roc_free);
    return 0;
&#125;
</code></pre>
<p><a id="orgde188bf"></a></p>
<h1 id="Linux驱动"><a href="#Linux驱动" class="headerlink" title="Linux驱动"></a>Linux驱动</h1><p>考虑在内核实现的原因是目前Linux相关设备非常多，可能具有一定的参考价值和移植性。<br>笔者的内核环境为：</p>
<pre><code>  uname -r
4.15.0-142-generic
</code></pre>
<p><a id="orgc0bb933"></a></p>
<h2 id="网络型驱动设备"><a href="#网络型驱动设备" class="headerlink" title="网络型驱动设备"></a>网络型驱动设备</h2><p>netfilter的相关参考资料为：Linnux5.0.0下，基于Netlink与NetFilter对本机数据包进行筛选监控,<a href="https://blog.csdn.net/qq_40758751/article/details/105117750">https://blog.csdn.net/qq_40758751/article/details/105117750</a> , netfilter数据包过滤, <a href="https://blog.csdn.net/specialsun/article/details/84695519">https://blog.csdn.net/specialsun/article/details/84695519</a><br>因为本文为源Ip数据包信息统计，所以netfilter hook的层级在NF<sub>INET</sub><sub>LOCAL</sub><sub>IN</sub>.<br>Hook 函数为filter<sub>http</sub>(忽略函数名，粘贴过来，不想改了).</p>
<p><a id="org9e48264"></a></p>
<h2 id="字符型设备"><a href="#字符型设备" class="headerlink" title="字符型设备"></a>字符型设备</h2><p>内核态数据在用户态访问需要通过字符型设备驱动进行。因此建立一个字符型设备/dev/IPDataSet 使得用户态能够访问内核 态的数据信息。<br>参考资料：ubuntu 添加字符设备驱动程序, <a href="https://blog.csdn.net/ARAFATms/article/details/79397800">https://blog.csdn.net/ARAFATms/article/details/79397800</a><br>因为上述驱动需要自己手动添加字符设备，所以通过以下方法自动添加设备节点。<br>参考资料：linux驱动：自动创建设备节点, <a href="https://blog.csdn.net/u012247418/article/details/83684029">https://blog.csdn.net/u012247418/article/details/83684029</a></p>
<pre><code>// filename: filter_ip.c
#ifndef __KERNEL__
#define __KERNEL__
#endif  /* __KERNEL__ */

#include &lt;linux/module.h&gt;
#include &lt;linux/init.h&gt;
#include &lt;linux/types.h&gt;
#include &lt;linux/string.h&gt;
//#include &lt;asm/uaccess.h&gt;
#include &lt;linux/netdevice.h&gt;
#include &lt;linux/netfilter_ipv4.h&gt;  // ip4 netfilter,ipv6则需引入相应 linux/netfilter_ipv6.h
#include &lt;linux/ip.h&gt;
#include &lt;linux/tcp.h&gt;
#include &lt;linux/sched.h&gt;
#include &quot;linux/kernel.h&quot;
#include &quot;linux/fs.h&quot;
#include &quot;linux/errno.h&quot;
#include &quot;linux/uaccess.h&quot;
#include &quot;linux/kdev_t.h&quot;
#include &lt;linux/device.h&gt;
#include &lt;linux/time.h&gt;

#define NIPQUAD(addr) \  
((unsigned char *)&amp;addr)[0], \  
((unsigned char *)&amp;addr)[1], \  
((unsigned char *)&amp;addr)[2], \  
((unsigned char *)&amp;addr)[3]  

#define MAX_SIZE 1024 * 1024 * 8
char message[MAX_SIZE] = &quot;&quot;;  //打开设备时会显示的消息
#include &quot;my_rbtree.h&quot;

struct rb_root root = RB_ROOT;
int insert(int key, int timestamp)
&#123;

  roc_node_t *node = NULL;
  node = roc_search(&amp;root, key);
  if(node != NULL) &#123;
    node-&gt;ipcount.count++;
    node-&gt;ipcount.timestamp = timestamp;
    return 1;
  &#125;
  node = (roc_node_t*)kmalloc(sizeof(roc_node_t), GFP_KERNEL );
  node-&gt;ctx = NULL;
  node-&gt;key = key;
  node-&gt;ipcount.count = 1;
  node-&gt;ipcount.timestamp = timestamp;
  return roc_insert(&amp;root, node);

&#125;

struct timeval time;
// 过滤http数据包
unsigned int filter_http(char *type,struct sk_buff *pskb)
&#123;
  __be32 sip,dip;
  int retval = NF_ACCEPT;
  int ret, ms;
  struct sk_buff *skb = pskb;

  struct iphdr *iph = ip_hdr(skb);  // 获取ip头

  sip = iph-&gt;saddr;  
  dip = iph-&gt;daddr;  
  //printk(&quot;Packet for source address: %d.%d.%d.%d destination address: %d.%d.%d.%d\n&quot;, NIPQUAD(sip), NIPQUAD(dip));  

  //sprintf(message, &quot;Packet for source address: %d.%d.%d.%d destination address: %d.%d.%d.%d\n&quot;, NIPQUAD(sip), NIPQUAD(dip));


  do_gettimeofday(&amp;time);  /*第一次去获取时间*/  ms = time.tv_sec * 1000 + time.tv_usec / 1000;  ret = insert(sip, ms);  //if(ret == 1)&#123;      roc_dump(&amp;root);  printk(message);  //&#125;  return retval;&#125;


unsigned int NET_HookLocalIn(void *priv,     struct sk_buff *pskb,     const struct nf_hook_state *state)&#123;  return filter_http(&quot;in&quot;,pskb);&#125;


unsigned int NET_HookLocalOut(void *priv,     struct sk_buff *pskb,     const struct nf_hook_state *state)&#123;  //return filter_http(&quot;out&quot;,pskb);  return NF_ACCEPT;&#125;



unsigned int NET_HookPreRouting(void *priv,     struct sk_buff *pskb,     const struct nf_hook_state *state)&#123;  return NF_ACCEPT;&#125;




unsigned int NET_HookPostRouting(void *priv,     struct sk_buff *pskb,     const struct nf_hook_state *state)&#123;  return NF_ACCEPT;&#125;


unsigned int NET_HookForward(void *priv,     struct sk_buff *pskb,     const struct nf_hook_state *state)&#123;  return NF_ACCEPT;&#125;


// 钩子数组static struct nf_hook_ops net_hooks[] = &#123;  &#123;    .hook         = NET_HookLocalIn,        // 发往本地数据包    .pf            = PF_INET,    .hooknum    =    NF_INET_LOCAL_IN,    .priority    = NF_IP_PRI_FILTER-1,  &#125;,  &#123;    .hook         = NET_HookLocalOut,        // 本地发出数据包    .pf            = PF_INET,    .hooknum    =    NF_INET_LOCAL_OUT,    .priority    = NF_IP_PRI_FILTER-1,  &#125;,  &#123;    .hook         = NET_HookForward,        // 转发的数据包    .pf            = PF_INET,    .hooknum    =    NF_INET_FORWARD,    .priority    = NF_IP_PRI_FILTER-1,  &#125;,  &#123;    .hook        = NET_HookPreRouting,    // 进入本机路由前        .pf            = PF_INET,                    .hooknum    = NF_INET_PRE_ROUTING,            .priority    = NF_IP_PRI_FILTER-1,          &#125;,  &#123;    .hook        = NET_HookPostRouting,    // 本机发出包经路由后        .pf            = PF_INET,                    .hooknum    = NF_INET_POST_ROUTING,            .priority    = NF_IP_PRI_FILTER-1,          &#125;,&#125;;


int my_open(struct inode *inode, struct file *file);int my_release(struct inode *inode, struct file *file);ssize_t my_read(struct file *file, char __user *user, size_t t, loff_t *f);ssize_t my_write(struct file *file, const char __user *user, size_t t, loff_t *f);char* devName = &quot;IPDataSet&quot;;//设备名struct file_operations pStruct =&#123; open:my_open,      release:my_release,      read:my_read,      write:my_write, &#125;;//打开int my_open(struct inode *inode, struct file *file)&#123;  printk(&quot;open lgsDrive OK!\n&quot;);  try_module_get(THIS_MODULE);  return 0;&#125;//关闭int my_release(struct inode *inode, struct file *file)&#123;  printk(&quot;Device released!\n&quot;);  module_put(THIS_MODULE);  return 0;&#125;


//读设备里的信息ssize_t my_read(struct file *file, char __user *user, size_t t, loff_t *f)&#123;  roc_dump(&amp;root);  if(copy_to_user(user,message,t))  &#123;    return -2;  &#125;  return sizeof(message);&#125;//向设备里写信息ssize_t my_write(struct file *file, const char __user *user, size_t t, loff_t *f)&#123;  if(copy_from_user(message,user,t))  &#123;    return -3;  &#125;  return sizeof(message);&#125;


static struct class *drv_class = NULL;int major = 0;//设备号static int __init nf_init(void) &#123;  int ret = 0;  //char device  major = register_chrdev(0, &quot;ipdataset_drv&quot;, &amp;pStruct);  drv_class = class_create(THIS_MODULE, &quot;ipdataset_drv&quot;);  device_create(drv_class, NULL, MKDEV(major, 0), NULL, devName);  //    ret = register_chrdev(0, devName, &amp;pStruct);  //    if (ret &lt; 0)  //    &#123;  //        printk(&quot;failed to register_chrdev.\n&quot;);  //        return -1;  //    &#125;  //    else  //    &#123;  //        printk(&quot;the lgsDrive has been registered!\n&quot;);  //        printk(&quot;id: %d\n&quot;, ret);  //        device_num = ret;  //   //        return 0;  //    &#125;  //net device  ret = nf_register_net_hook(&amp;init_net, net_hooks);  //ret = nf_register_hooks(net_hooks,ARRAY_SIZE(net_hooks));    // 安装钩子  if(ret)  &#123;    printk(KERN_ERR &quot;register hook failed\n&quot;);    return -1;  &#125;  printk(&quot;Start...\n&quot;);  return 0;&#125;void close(void)&#123;  roc_destroy(&amp;root, roc_free);&#125;static void __exit nf_exit(void)&#123;  close();  unregister_chrdev(major, &quot;ipdataset_drv&quot;);  device_destroy(drv_class, MKDEV(major, 0));  class_destroy(drv_class);  //unregister_chrdev(device_num, devName);


  nf_unregister_net_hook(&amp;init_net, net_hooks);  //nf_unregister_hooks(net_hooks,ARRAY_SIZE(net_hooks));    // 卸载钩子  printk(&quot;Exit...\n&quot;);&#125;



module_init(nf_init);module_exit(nf_exit);




MODULE_LICENSE(&quot;Dual BSD/GPL&quot;);MODULE_AUTHOR(&quot;dianwoshishi&quot;);MODULE_DESCRIPTION(&quot;Netfilter IP Statistic&quot;);MODULE_VERSION(&quot;1.0.1&quot;);MODULE_ALIAS(&quot;Netfilter 01&quot;);
</code></pre>
<p><a id="org8ee7f64"></a></p>
<h2 id="用户代码"><a href="#用户代码" class="headerlink" title="用户代码"></a>用户代码</h2><p>上述字符型设备创建了一个字符节点为：/dev/IPDataSet， 在用户态程序中，我们通过Linux编程中提供的read函数对驱动中的数据message进行读取。<br>代码如下：</p>
<pre><code>   #include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#define MAX_SIZE 1024 char message[MAX_SIZE] ;  //打开设备时会显示的消息int main(int num, char *arg[])&#123;    if(2 != num)&#123;        printf(&quot;Usage: %s /dev/IPDataSet\n&quot;, arg[0]);        return -1;    &#125;    int fd = open(arg[1], O_RDWR);    if(0 &gt; fd)&#123;        perror(&quot;open&quot;);        return -1;    &#125;    int ret = read(fd, message, MAX_SIZE);    printf(&quot;read: ret = %d. %s\n&quot;, ret, message);    memset(message, 0, MAX_SIZE);    ret = write(fd, message, MAX_SIZE);    printf(&quot;write: ret = %d.\n&quot;, ret);    close(fd);    return 0;&#125;
</code></pre>
<p><a id="org3f4753d"></a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><a id="org01bad05"></a></p>
<h2 id="Linux-驱动"><a href="#Linux-驱动" class="headerlink" title="Linux 驱动"></a>Linux 驱动</h2><p>熟悉Linux驱动的编写流程。 了解了Linux内核代码与用户代码的不同，比较明显的就是缺少了类似C++ STL类似的好用的库，只能使用类似红黑树（rbtree)这样的数据结构来做一些set的操作，需要对红黑树有一定的了解。<br>网络设备驱动和字符型设备驱动的编写结构都差不多，但是目前也是一知半解，尤其是一些简单操作之外的特性还不了解，例如加锁？多线程？不知道</p>
<p><a id="orgd1e6a5e"></a></p>
<h2 id="Linux内核"><a href="#Linux内核" class="headerlink" title="Linux内核"></a>Linux内核</h2><p>Linux内核的设计模式还是比较令人佩服的，虽然不懂全貌，但是也能从局部出发，贡献一些力量。再一次感受到了设计的魅力。</p>
<p><a id="org4c6ff33"></a></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>一定要在虚拟机中编写、测试驱动，不知道有什么错出现，你就要重启你的电脑，boring！</p>
<p><a id="orgfe8069d"></a></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>linux驱动编写（总结篇）,<a href="https://blog.csdn.net/feixiaoxing/article/details/79913476?spm=1001.2014.3001.5506">https://blog.csdn.net/feixiaoxing/article/details/79913476?spm=1001.2014.3001.5506</a><br>智能路由器设备流量、网速统计及上下线提醒（基于netfilter编程）,<a href="https://blog.csdn.net/u012819339/article/details/50513387?spm=1001.2014.3001.5506">https://blog.csdn.net/u012819339/article/details/50513387?spm=1001.2014.3001.5506</a><br>利用Linux内核模块Netfilter hook UDP报文, <a href="https://blog.csdn.net/qq_41791640/article/details/104933006?spm=1001.2014.3001.5506">https://blog.csdn.net/qq_41791640/article/details/104933006?spm=1001.2014.3001.5506</a><br>Netfilter的使用和实现, <a href="https://blog.csdn.net/zhangskd/article/details/22678659?spm=1001.2014.3001.5506">https://blog.csdn.net/zhangskd/article/details/22678659?spm=1001.2014.3001.5506</a></p>
]]></content>
  </entry>
  <entry>
    <title>关于RFC文档有趣的事情</title>
    <url>/2021/05/29/%E5%85%B3%E4%BA%8ERFC%E6%96%87%E6%A1%A3%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8B%E6%83%85/</url>
    <content><![CDATA[<h1 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h1><ol>
<li> <a href="#org34ce3f0">事情的起源</a></li>
<li><a href="#orgbd0ef9b">研究经过</a><ol>
<li> <a href="#orgd742468">查询相关资料</a></li>
<li> <a href="#org7b36c8c">查询相关RFC</a></li>
<li><a href="#orge2e0fc8">一个想法</a><ol>
<li> <a href="#org3061772">第一个发现</a></li>
<li> <a href="#org4e04c37">第二个发现</a></li>
<li> <a href="#org2636b5a">第三个发现</a></li>
<li> <a href="#org9ff55be">第四个发现</a></li>
</ol>
</li>
</ol>
</li>
<li> <a href="#org9564d4b">总结</a></li>
</ol>
<p><a id="org34ce3f0"></a></p>
<h1 id="事情的起源"><a href="#事情的起源" class="headerlink" title="事情的起源"></a>事情的起源</h1><p>一次被问起，为何TLSv1.0(RFC2246),TLSv1.1(RFC4346),TLSv1.2(RFC5246),TLSv1.3(RFC8446)中的RFC编号都是以64结尾。印象中关于RFC编号都是递增的，因为RFC写好之后就不允许再修改了，如果有新的标准出来，只能在其后某个编号出现，并且引用之前的RFC。<br>但是上述这个问题，TLS四个版本均以64结尾，也太凑巧了，确实很让人疑惑。本着好奇，去研究了研究这事。</p>
<p><a id="orgbd0ef9b"></a></p>
<h1 id="研究经过"><a href="#研究经过" class="headerlink" title="研究经过"></a>研究经过</h1><p><a id="orgd742468"></a></p>
<h2 id="查询相关资料"><a href="#查询相关资料" class="headerlink" title="查询相关资料"></a>查询相关资料</h2><p>首先在网上搜索为什么TLS均以64结尾，网上的回答基本上来自如下解释</p>
<blockquote>
<p>In the IETF, protocols are called RFCs. TLS 1.0 was RFC 2246, TLS 1.1 was RFC 4346, and TLS 1.2 was RFC 5246. Today, TLS 1.3 was published as RFC 8446. RFCs are generally published in order, keeping 46 as part of the RFC number is a nice touch<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup>.</p>
</blockquote>
<p>显然，并没有解决我们的问题。</p>
<p><a id="org7b36c8c"></a></p>
<h2 id="查询相关RFC"><a href="#查询相关RFC" class="headerlink" title="查询相关RFC"></a>查询相关RFC</h2><p>思考是否会有某个RFC对这事做了说明吗？查询未果。<br>但是在此过程中，我发现了在RFC文档中，有相邻两个递增编号文档，但是RFC时间并不递增的现象。举个例子</p>
<blockquote>
<p>1478 An Architecture for Inter-Domain Policy Routing. M. Steenstrup. June</p>
<ol>
<li> (Format: TXT, HTML) (Status: HISTORIC) (DOI: 10.17487/RFC1478)</li>
</ol>
<p>1479 Inter-Domain Policy Routing Protocol Specification: Version 1. M.<br>     Steenstrup. July 1993. (Format: TXT, HTML) (Status: HISTORIC) (DOI:<br>     10.17487/RFC1479) </p>
<p>1480 The US Domain. A. Cooper, J. Postel. June 1993. (Format: TXT, HTML)<br>     (Obsoletes RFC1386) (Status: INFORMATIONAL) (DOI: 10.17487/RFC1480) </p>
</blockquote>
<p>其中RFC1478的时间为1993年6月，RFC1479的时间为1993年7月，但是RFC1480的时间为1993年6月，出现了非递增的情况。</p>
<p>虽然又发现，但好像并没有什么卵用。但是自然会想到，有可能时间上有大的反复吗？有年的反复现象吗？</p>
<p><a id="orge2e0fc8"></a></p>
<h2 id="一个想法"><a href="#一个想法" class="headerlink" title="一个想法"></a>一个想法</h2><p><a id="org3061772"></a></p>
<h3 id="第一个发现"><a href="#第一个发现" class="headerlink" title="第一个发现"></a>第一个发现</h3><p>所以就想分析分析RFC文档的编号的时间问题。第一想法是爬虫，但是工作量太复杂。左搜索右搜索，找到了官网提供的XML版列表<sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup>.超级开心。然后写了个python脚本，自动进行了分析(忽略并不想改的变量名，来自一个豆瓣电影爬虫)。</p>
<pre><code>#!/usr/bin/python3
import calendar
from xml.dom.minidom import parse
import xml.dom.minidom

import numpy as np
import matplotlib.pyplot as plt 

# 使用minidom解析器打开 XML 文档
DOMTree = xml.dom.minidom.parse(&quot;rfc-index.xml&quot;)
collection = DOMTree.documentElement
if collection.hasAttribute(&quot;shelf&quot;):
   print (&quot;Root element : %s&quot; % collection.getAttribute(&quot;shelf&quot;))

# 在集合中获取所有电影
movies = collection.getElementsByTagName(&quot;rfc-entry&quot;)

# 打印每部电影的详细信息
print (&quot;*****Movie*****&quot;)
x = [];
years = [];
months = [];
total = [];
for movie in movies:

   type = movie.getElementsByTagName(&#39;doc-id&#39;)[0].childNodes[0].data

   id = int(type[3:]);
   x.append(id);
#    print (&quot;doc-id: %d&quot; % id)
#    author = movie.getElementsByTagName(&#39;author&#39;)[0]
#    print (&quot;author: %s&quot; % author.childNodes[1].data)
   date = movie.getElementsByTagName(&#39;date&#39;)[0]
   month = date.getElementsByTagName(&#39;month&#39;)[0].childNodes[0].data;
   int_month = int(list(calendar.month_name).index(month))
   months.append(int_month);
#    print (&quot;date month: %d&quot; % int_month)
   year = int(date.getElementsByTagName(&#39;year&#39;)[0].childNodes[0].data);
#    print (&quot;date year: %d&quot; % year)
   years.append(year);
#    description = movie.getElementsByTagName(&#39;description&#39;)[0]
#    print (&quot;Description: %s&quot; % description.childNodes[0].data)
   total.append(year + 10  + int_month  )

plt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Arial Unicode MS&#39;]
plt.rcParams[&#39;axes.unicode_minus&#39;] = False   # 解决保存图像是负号&#39;-&#39;显示为方块的问题
plt.title(&quot;Matplotlib&quot;) 
plt.xlabel(&quot;RFC编号&quot;) 
plt.ylabel(&quot;年份&quot;) 

plt.plot(x,years, label=r&#39;年&#39;) 
plt.plot(x,total, label=r&#39;年 + 月 + 10(向上平移10)&#39;) 
# plt.subplot(2,1,1)
# plt.plot(x,years) 
# plt.subplot(2,1,2)
# plt.plot(x,months) 
plt.legend();

plt.grid()
plt.show()
</code></pre>
<p>经过经过分析有了如下所示图：<br><img src="/2021/05/29/%E5%85%B3%E4%BA%8ERFC%E6%96%87%E6%A1%A3%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8B%E6%83%85/%E5%B9%B4%E4%BB%BD%E5%9B%BE.png" alt="img"><br>果然有问题！！！！上图横坐标为RFC编号，纵坐标为RFC编号对应的年份。可以看出RFC文档从一九六几年到今天一共发表8000余份。有意思的是，其中有一些凸起的部分，就是一些异常点。例如2000年前有一个极高的凸起，这代表这个编号的年份远远超出这个编号附近的年份，这与我们的常识不符。实际上，查看这个异常点，如下图所示：<br><img src="/2021/05/29/%E5%85%B3%E4%BA%8ERFC%E6%96%87%E6%A1%A3%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8B%E6%83%85/image-20201218225458777.png" alt="img"><br>其中RFC1849的年份为2010年，但其附近的RFC文档编号均为1995年，其中相差15年，造成第一幅图中的凸起。</p>
<p><a id="org4e04c37"></a></p>
<h3 id="第二个发现"><a href="#第二个发现" class="headerlink" title="第二个发现"></a>第二个发现</h3><p>同时，我们还会发现另一个有意思的现象。如下图所示：<br><img src="/2021/05/29/%E5%85%B3%E4%BA%8ERFC%E6%96%87%E6%A1%A3%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8B%E6%83%85/%E6%95%B4%E6%95%B0%E9%97%B4%E9%9A%94%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="整数间隔示意图"><br>其中编号为1299，1399，1499，1599，1699,&#x2026;等，均出现凸起现象。并且实际上1299，1399，1499，1599，1699，1799，1899，1999的年份均为1997年。存在明显的人为痕迹。</p>
<p><a id="org2636b5a"></a></p>
<h3 id="第三个发现"><a href="#第三个发现" class="headerlink" title="第三个发现"></a>第三个发现</h3><p>年份和月份基本满足递增，但是有波动。如下图所示：<br><img src="/2021/05/29/%E5%85%B3%E4%BA%8ERFC%E6%96%87%E6%A1%A3%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8B%E6%83%85/%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="img"><br>放大后：<br><img src="/2021/05/29/%E5%85%B3%E4%BA%8ERFC%E6%96%87%E6%A1%A3%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8B%E6%83%85/%E7%A4%BA%E6%84%8F%E5%9B%BE%E6%94%BE%E5%A4%A7.png" alt="img"><br>为方便对比，将其中月份显示为（年+月，再向上平移10个单位(年)）。</p>
<p><a id="org9ff55be"></a></p>
<h3 id="第四个发现"><a href="#第四个发现" class="headerlink" title="第四个发现"></a>第四个发现</h3><p>TLS的主要作者，目前是Eric Rescorla。对TLS四个版本作者做简单统计，如下图：<br><img src="/2021/05/29/%E5%85%B3%E4%BA%8ERFC%E6%96%87%E6%A1%A3%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8B%E6%83%85/image-20201218231640006.png" alt="img"><br>可以看出，最开始Tim Dierks逐渐从第二作者，向第一作者上升，此时带了个徒弟。慢慢Tim Dierks开始退居二线，Eric Rescorla开始独挡一面（纯属胡说八道）。</p>
<p><a id="org9564d4b"></a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>虽然并没有直接的证据来回答开头提出的问题，但是我们可以发现以下现象：</p>
<ul>
<li>  RFC的编号并非严格的时间递增，而是存在一些波动</li>
<li>  RFC的编号中存在一些，小概率发生的现象，例如等间隔凸起</li>
</ul>
<p>基于以上现象呢，我们可以大胆猜测（hu shuo ba dao）：</p>
<ul>
<li>  RFC编号的审批机构，会因为某些原因，保留一些编号</li>
<li>  RFC的编号其实并没有想象中的那么严格</li>
<li>  大佬在RFC编号中具有一定的发言权，可以”预定“一些编号。如TLSv1，2，3，4以64结尾</li>
</ul>
<h1 id="Footnotes"><a href="#Footnotes" class="headerlink" title="Footnotes"></a>Footnotes</h1><p><sup><a id="fn.1" href="#fnr.1">1</a></sup> <a href="https://blog.cloudflare.com/rfc-8446-aka-tls-1-3/">https://blog.cloudflare.com/rfc-8446-aka-tls-1-3/</a></p>
<p><sup><a id="fn.2" href="#fnr.2">2</a></sup> <a href="https://www.rfc-editor.org/rfc-index.xml">https://www.rfc-editor.org/rfc-index.xml</a></p>
]]></content>
  </entry>
</search>
