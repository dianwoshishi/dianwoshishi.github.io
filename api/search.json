[{"id":"3b90117533ae5e7d7401814a79808610","title":"Python的for_else结构你使用过吗","content":"大家好，我是明说网络的小明同学。\n今天学到了一个Python的非常有用的新知识，在这分享给大家，相信能让大家的代码更加简洁。\n在编写程序的过程中，一种常见的运行流程是：运行for循环，直到找到某个对象，然后跳出循环。\n这里有个问题，如果我跳出循环或循环结束，我需要确定发生了什么情况。一种方法是创建一个标志或存储变量，让我进行第二次测试，查看循环是如何退出的。\n例如，假设我需要搜索一个列表并处理每个项目，直到找到一个标志项目，然后停止处理。如果缺少标志项，则需要引发异常。\n像这样\nflagfound = False\nfor i in mylist:\n    if i == theflag:\n        flagfound = True\n        break\n    process(i)\n\nif not flagfound:\n    raise ValueError(\"List argument missing terminal flag.\")\n\n所以就出现了上面代码中的flagfound变量。但是维护这个flagfound超难受！\n如果你有这个问题，那么恭喜你，for...else能够结束你的痛苦。\n但是使用for...else结构，却能使你的代码更加的简洁，看下面的代码，是否更加简洁？\nfor i in mylist:\n    if i == theflag:\n        break\n    process(i)\nelse:\n    raise ValueError(\"List argument missing terminal flag.\")\n\nfor...else你学会了吗?\n参考资料\nif statement - Why does python use &#39;else&#39; after for and while loops? - Stack Overflow\n","slug":"Python的for_else结构你使用过吗","date":"2022-03-01T13:42:31.591Z","categories_index":"编程开发","tags_index":"python,技巧","author_index":"明说网络"},{"id":"3ec2f930090650c3a17b37084a336b7a","title":"程序性能测试方法和工具","content":"程序性能测试方法和工具在开发的过程中，对于编码是一个部分，但同时写出来的代码怎么样，在操作系统上的表现怎么样，是需要进行测试的。这里就给出一些性能测试的方法和工具\npython CProfilepython3 -m cProfile test_python_profiling.py\npython3 -m cProfile -o profiling.out test_python_profiling.py\npython3 -m pstats profiling.out\nprofiling.out% help\n\nDocumented commands (type help &lt;topic&gt;):\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nEOF  add  callees  callers  help  quit  read  reverse  sort  stats  strip\n\npython line_profilinghttps://github.com/pyutils/line_profiler\nhttps://missing.csail.mit.edu/2020/debugging-profiling/\n","slug":"程序性能测试","date":"2022-02-28T02:49:38.000Z","categories_index":"编程开发,性能测试","tags_index":"性能工具,系统资源","author_index":"明说网络"},{"id":"6023b30c6d91b2a1a20f944e565f66cb","title":"提升你的工作效率：Linux工具推荐","content":"提升你的工作效率：Linux工具推荐变更管理比较目录差异A lesser known similar feature is process substitution, &lt;( CMD ) will execute CMD and place the output in a temporary file and substitute the &lt;() with that file’s name. This is useful when commands expect values to be passed by file instead of by STDIN. For example, diff &lt;(ls foo) &lt;(ls bar) will show differences between files in dirs  foo and bar.\n查找工具GitHub - sharkdp&#x2F;fd: A simple, fast and user-friendly alternative to &#39;find&#39;\n命令行历史搜索工具GitHub - zsh-users&#x2F;zsh-history-substring-search: 🐠 ZSH port of Fish history search (up arrow)\n宇宙级神奇tmuxhttps://www.hamvocke.com/blog/a-quick-and-easy-guide-to-tmux/\n","slug":"提升你的工作效率_Linux工具推荐","date":"2022-02-28T01:31:44.000Z","categories_index":"编程开发,效率提升","tags_index":"Linux,tool,efficency","author_index":"明说网络"},{"id":"539d7e3c6416254efb27a55300bee170","title":"docker中单容器开启多服务时systemctl引发的血案及破案过程","content":"docker中单容器开启多服务时systemctl引发的血案及破案过程问题的起源来源于，想要将一个运行在centos7上的项目，移植到docker上，实现快速部署。原项目，我们暂且称之为Myproject， 提供了install_centos7.sh和Vagrant的构建文件。Vagrant 文件工作的很好，但是笔者是在虚拟机中完成的vagrant构建的验证，也遇见了不少问题，例如嵌套虚拟化的问题\n但，虚拟机里面搞总感觉不得劲，又加上vagrant比较小众，我就盯上了Docker。本来想着这不是很简单吗，pull一个centos7的image，然后run一个container，bash install一下就完了呗。\n没想到这就开始了，痛苦的采坑之旅。\ndocker安装Myproject出现的的问题由于docker的设计原则是一个container只运行一个服务，所以像Myproject这样的需要多个服务的(redis, httpd, psql, mongo, rabbitmq等)，想要在一个容器中使用，存在很多限制。\n问题包括，但不限于docker中执行systemctl命令问题记录和解决_WELTest的专栏-CSDN博客_docker systemctl\nNot able to use systemd on ubuntu docker container - Stack Overflow\n问题有：Failed to get D-Bus connection: Operation not permitted解决这个问题的一个方法是使用--privileged和/usr/sbin/init\n\nprivileged的作用是使得docker的环境以管理员角色运行\n\n&#x2F;usr&#x2F;sbin&#x2F;init是\n\n\n\n\n\n\n\n\n\n\n\n&#x2F;usr&#x2F;sbin&#x2F;init 启动容器之后可以使用systemctl方法-privileged&#x3D;true 获取宿主机root权限（特殊权限-）\ndocker -privileged和&#x2F;usr&#x2F;sbin&#x2F;init - lvph - 博客园\n但是这个方法使用后出现了以下问题：\n ~  docker run -itd --privileged --name centos7 centos:7 &#x2F;usr&#x2F;sbin&#x2F;init\na2f71d42e0f4c5c13b06a607da719df40e428305188c1a3154889a1bc4991f6d\n ~  docker exec -it centos7 ps aux\nUSER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND\nroot         1  0.4  0.1  42716  3888 ?        Ss   10:44   0:00 &#x2F;usr&#x2F;sbin&#x2F;init\nroot         8  0.0  0.1  51748  3400 pts&#x2F;1    Rs+  10:44   0:00 ps aux\n ~  docker exec -it centos7 &#x2F;bin&#x2F;bash\n[root@a2f71d42e0f4 &#x2F;]# systemctl\nFailed to get D-Bus connection: No such file or directory\n\n还有一种方法是：run docker image with docker run --privileged -v /sys/fs/cgroup:/sys/fs/cgroup:ro &lt;image&gt; and systemctl works fine\n经过试验，也解决不了我的问题\n ~  docker run --privileged -itd  -v &#x2F;sys&#x2F;fs&#x2F;cgroup:&#x2F;sys&#x2F;fs&#x2F;cgroup:ro --name centos7 centos:7 &#x2F;usr&#x2F;sbin&#x2F;init\n7ff1b85e7c9fecf17c889e0c2a25ab73203131ecdcb629180798fa1c07b4ee22\n ~  docker exec -it centos7 ps aux\nUSER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND\nroot         1  1.0  0.1  42716  3944 ?        Ss   10:49   0:00 &#x2F;usr&#x2F;sbin&#x2F;init\nroot         8  0.0  0.1  51748  3456 pts&#x2F;1    Rs+  10:49   0:00 ps aux\n ~  docker exec -it centos7 &#x2F;bin&#x2F;bash\n[root@7ff1b85e7c9f &#x2F;]# systemctl\nFailed to get D-Bus connection: No such file or directory\n\n\n ~  docker run -it \\\n    --volume &#x2F;sys&#x2F;fs&#x2F;cgroup:&#x2F;sys&#x2F;fs&#x2F;cgroup:ro \\\n    --rm centos:7 &#x2F;bin&#x2F;bash\n[root@9c3b2edf75ff &#x2F;]# systemctl\nFailed to get D-Bus connection: Operation not permitted\n[root@9c3b2edf75ff &#x2F;]#\n\nFailed to connect to bus: No such file or directory在搜索资料的过程中发现了这篇文章， 对这个问题的解释比较到位：如何在Docker里面使用systemctl - Ehds\n容器里面是没有systemd进程的，而很多进程管理工具都需要和systemd通信，这里面就有我们这里的主角systemctl。docker只是提供了进程隔离，不是操作系统的虚拟。\n\n\n\n\n\n\n\n\n\nThat’s because “systemctl” talks to the systemd daemon by using the d-bus. In a container there is no systemd-daemon. Asking for a start will probably not quite do what you expect - the dev-mapping need to be a bit longer.This is by design. Docker should be running a process in the foreground in your container and it will be spawned as PID 1 within the container’s pid namespace. Docker is designed for process isolation, not for OS virtualization, so there are no other OS processes and daemons running inside the container (like systemd, cron, syslog, etc), only your entrypoint or command you run.If they included systemd commands, you’d find a lot of things not working since your entrypoint replaces init. Systemd also makes use to cgroups which docker restricts inside of containers since the ability to change cgroups could allow a process to escape the container’s isolation. Without systemd running as init inside your container, there’s no daemon to process your start and stop commands.\n给出解决方案，确实能work\n\n\n\n\n\n\n\n\n\n  解决方案\n\n我们可以在启动容器的时候将在启动参数加上 &#x2F;sbin&#x2F;init 来让其生效。以centos为例：docker run -d -v /sys/fs/cgroup/:/sys/fs/cgroup:ro --cap-add SYS_ADMIN --name systemd_websrv centos /sbin/init就可以正常使用systemd了但是如果容器重启，那么就可能导致失效。\n\n替换systemctl使用 docker-systemctl-replacement替换容器中的systemctl。以ubuntu镜像为例：1). 安装python2sudo apt install python2). 替换systemcl (注意路径，可以使用whereis systemctl查看当前默认路径)wget https://raw.githubusercontent.com/gdraheim/docker-systemctl-replacement/master/files/docker/systemctl.py -O /bin/systemctl3). 给定权限sudo chmod a+x /bin/systemctl这样接可以使用非systemd的systemctl，但是因为是非官方的systemcl所以可能存在一些未知问题。\n\n\n最好还是建议将docker作为进程隔离环境，single app single container， 但是遇到非常特殊的情况下，可以上述两个解决方案，如果有更好的方案，欢迎提出。\n上面这些在单容器单服务下都工作的很好，但是在笔者的场景下呢？情况不是太好\n事情还没有完当我们想要像在虚拟机上一样，在一个容器中运行多个container，比如一般网站的配置，redis，httpd，mongo，rabbitmq等等，这该怎么搞？不要问我为什么不把容器拆分，要问就是配置起来太麻烦了。\n笔者遇到一个问题就是，按照上述copy的方法对container中所有服务安装完毕之后，一切非常正常，但问题发生在，重启container，systemctl就再也启动不起来某些服务，例如httpd，psql等。\n经过一番周折，以及和systemctl.py的作者进行沟通，最后发现：其实这个问题的根源还是在systemctl上.\n在centos系统中，systemctl需要使用d-bus来与systemd通信，完成服务的启动。但是在docker的容器中并没有systemd-daemon的守护进程，所以上述通信是不会完成的。这就导致了前面所说的两个问题:D-Bus connection: Operation not permitted以及No such file or directory的问题\n下面举个例子\n一般我们启动容器的过程一般使用docker run -t -i centos:7 /bin/bash, 那么容器中一号进程就是/bin/bash, 而不是我们熟悉的systemd。\n ~  docker pull centos:7\n7: Pulling from library&#x2F;centos\n2d473b07cdd5: Downloading\n7: Pulling from library&#x2F;centos\n2d473b07cdd5: Pull complete\nDigest: sha256:c73f515d06b0fa07bb18d8202035e739a494ce760aa73129f60f4bf2bd22b407\nStatus: Downloaded newer image for centos:7\ndocker.io&#x2F;library&#x2F;centos:7\n ~  docker run -itd --name centos7 centos:7\nc625bedacd894f9db6ca065839e413bb02e46cf6b602822f26baebfab745982a\n ~  docker exec -it centos7 ps aux\nUSER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND\nroot         1  0.4  0.1  11844  2944 pts&#x2F;0    Ss+  10:41   0:00 &#x2F;bin&#x2F;bash\nroot        14  0.0  0.1  51748  3448 pts&#x2F;1    Rs+  10:41   0:00 ps aux\n\n对象都没有了，所以暴d-bus的错误，就很容易解释了。\n上述描述是对这个问题的通俗解释，想要了解关于这个问题的根本原因可以看下面两个链接，进一步了解，基本都是在解释一号进程的问题\nlinux - how to solve Docker issue Failed to connect to bus: No such file or directory - Stack Overflow\nNot able to use systemd on ubuntu docker container - Stack Overflow\n解决方案问题的根源找到了，解决这个问题的思路就非常的清晰了，就是使服务的管理不依赖于systemd。\n\n\n\n\n\n\n\n\n\nDo not rely on systemd as a process manager but have the docker container run your desired application in the foreground.\n有一款工具，就能够实现执行systemctl而不依赖于systemd，他就是GitHub - gdraheim&#x2F;docker-systemctl-replacement: docker systemctl replacement - allows to deploy to systemd-controlled containers without starting an actual systemd daemon (e.g. centos7, ubuntu16)， 这个github仓库专门在处理这个问题。同时，如果你不想写一些dockerfile来实现上述过程，你也可以使用该作者的另一个仓库，docker-systemctl-images&#x2F;centos-httpd.dockerfile at master · gdraheim&#x2F;docker-systemctl-images · GitHub\n在这里，作者给出了很多版本的可以使用systemctl的镜像，非常的有用。\n在使用systemctl的过程中，其实也踩了很多坑第一个问题是，什么时候拷贝的问题？\n最最朴素的想法是，拷贝一次就行了呗，当初我也是这样想的，结果，水很深。\n\n\n\n\n\n\n\n\n\nMost os packages with a systemd service have declared a dependency on systemd. When you install an os package it updates systemd which overwrites &#x2F;usr&#x2F;bin&#x2F;systemctl which in turn kills the replacement functionality. The next “systemctl” is again executed by systemd which does not work in a container easily as you know. So after a os package install it helps to just drop-in the replacement script again.\ncan not start the service when reboot? · Issue #137 · gdraheim&#x2F;docker-systemctl-replacement · GitHub\n这是与作者沟通时候，作者的解释，很容易懂，大致就是，安装软件时会更新systemctl，那么我们之前一次的拷贝不就失效了嘛。所以安装了软件之后，就拷贝一下吧！！！\n时机：\n\n\n\n\n\n\n\n\n\nAfter “yum install” and before the next “systemctl” execution.\ncan not start the service when reboot? · Issue #137 · gdraheim&#x2F;docker-systemctl-replacement · GitHub\n第二个问题是，启动点设为systemctl还是&#x2F;bin&#x2F;bash&#x2F;还是&#x2F;usr&#x2F;sbin&#x2F;init.\n首先给出答案，需要设置成systemctl，因为它负责移除对systemd的依赖，所以要让它成为一号进程。\n这个可以看看作者给出的dockerfile\nFROM centos:7.7.1908\n\nLABEL __copyright__&#x3D;&quot;(C) Guido Draheim, licensed under the EUPL&quot; \\\n      __version__&#x3D;&quot;1.4.4147&quot;\nEXPOSE 80\n\nCOPY files&#x2F;docker&#x2F;systemctl.py &#x2F;usr&#x2F;bin&#x2F;systemctl\nRUN yum install -y httpd httpd-tools\nCOPY files&#x2F;docker&#x2F;systemctl.py &#x2F;usr&#x2F;bin&#x2F;systemctl\n\nRUN echo TEST_OK &gt; &#x2F;var&#x2F;www&#x2F;html&#x2F;index.html\n\nRUN systemctl enable httpd\nCMD &#x2F;usr&#x2F;bin&#x2F;systemctl\n\n关于entrypoint 和cmd的区别，可以看看这篇文章，讲的很透彻，也有案例。ENTRYPOINT vs CMD: Back to Basics\n看了这篇不过瘾的话，在第一篇的基础上再看这篇就可以了\nhttps://www.ctl.io/developers/blog/post/dockerfile-entrypoint-vs-cmd/\n总结\n问题的根源在systemctl,它需要像docker容器中的systemd通信，但是却没有对象\n解决问题的方法在于，解除systemctl与systemd的依赖关系，这里我们用到了一个systemctl.py的工具\n使用systemctl.py需要注意拷贝的时机，以及设置systemctl作为容器一号进程\n\n参考资料及备注一号进程有什么作用？Docker 的 stop 和 kill 命令都是用来向容器发送信号的。注意，只有容器中的 1 号进程能够收到信号，这一点非常关键！究竟谁是 1 号进程则主要由 EntryPoint, CMD, RUN 等指令的写法决定，所以这些指令的使用是很有讲究的。在 docker 容器中捕获信号 - sparkdev - 博客园\nCMD 和 ENTRYPOINT 指令都支持 exec 模式和 shell 模式的写法，所以要理解 CMD 和 ENTRYPOINT 指令的用法，就得先区分 exec 模式和 shell 模式。这两种模式主要用来指定容器中的不同进程为 1 号进程。\n使用 exec 模式时，容器中的任务进程就是容器内的 1 号进程，exec 模式是建议的使用模式\n使用 shell 模式时，docker 会以 &#x2F;bin&#x2F;sh -c “task command” 的方式执行任务命令。也就是说容器中的 1 号进程不是任务进程而是 bash 进程\nCMD 指令的目的是：为容器提供默认的执行命令。CMD 指令有三种使用方式，其中的一种是为 ENTRYPOINT 提供默认的参数：CMD [“param1”,”param2”]另外两种使用方式分别是 exec 模式和 shell 模式：CMD [“executable”,”param1”,”param2”]    &#x2F;&#x2F; 这是 exec 模式的写法，注意需要使用双引号。CMD command param1 param2                  &#x2F;&#x2F; 这是 shell 模式的写法。\n注意命令行参数可以覆盖 CMD 指令的设置，但是只能是重写，却不能给 CMD 中的命令通过命令行传递参数。\nENTRYPOINT 指令的目的也是为容器指定默认执行的任务。ENTRYPOINT 指令有两种使用方式，就是我们前面介绍的 exec 模式和 shell 模式：ENTRYPOINT [“executable”, “param1”, “param2”]   &#x2F;&#x2F; 这是 exec 模式的写法，注意需要使用双引号。ENTRYPOINT command param1 param2                   &#x2F;&#x2F; 这是 shell 模式的写法。\n指定 ENTRYPOINT  指令为 exec 模式时，命令行上指定的参数会作为参数添加到 ENTRYPOINT 指定命令的参数列表中\n命令行参数被 ENTRYPOINT  指令的 shell 模式忽略了。\n其他参考资料Not able to use systemd on ubuntu docker container - Stack Overflow\n","slug":"docker中单容器开启多服务时systemctl引发的血案及破案过程","date":"2022-02-27T11:09:52.000Z","categories_index":"编程开发,运维管理","tags_index":"docker,systemd,systemctl","author_index":"明说网络"},{"id":"0c2ff1774a3302abe71d90a3ee55138c","title":"Markdown相关语法学习记录","content":"markdown 中流程图详解https://blog.csdn.net/suoxd123/article/details/84992282\ngraph TB\nA[Apple]--&gt;B&#123;Boy&#125;\nA---C(Cat)\nB.-&gt;D((Dog))\nC&#x3D;&#x3D;喵&#x3D;&#x3D;&gt;D\nstyle A fill:#2ff,fill-opacity:0.1,stroke:#faa,stroke-width:4px\nstyle D stroke:#000,stroke-width:8px;\n\n\nsequenceDiagram\nparticipant 张 as 张三\nparticipant 李 as 李四\nparticipant 王 as  王五   \n张 -&gt;&gt; +李: 你好！李四, 最近怎么样?\n李--&gt;&gt; 王: 你最近怎么样，王五？\n李--x -张: 我很好，谢谢!\nactivate 王\n李-x 王: 我很好，谢谢!   \nNote over 李,王: 李四想了很长时间, 文字太长了&lt;br&#x2F;&gt;不适合放在一行.\ndeactivate 王\nloop 李四再想想\n李--&gt;&gt;王: 我还要想想\n王--&gt;&gt;李: 想想吧\nend\n李--&gt;&gt;张: 打量着王五...\n张-&gt;&gt;王: 很好... 王五, 你怎么样?\n\n\n\n\n实测，在本博客系统中不支持流程图特性，不过typora支持，这。。。反正不影响。先这么用着吧\n","slug":"Markdown相关语法学习记录","date":"2022-02-27T04:15:30.000Z","categories_index":"编程语言,笔记记录","tags_index":"markdown,流程图","author_index":"明说网络"},{"id":"422918ab17fac2b9611905dfbc28c6cc","title":"从hello world开始，拆解函数栈结构","content":"从hello world开始，拆解函数栈结构第一个程序helloworld编写程序首先我们有如下程序：main.c\n//main.c\n#include&lt;stdio.h>\nint test_stack()&#123;\n\tchar name[25] = &#123;0&#125;;\n\tscanf(\"%s\", name);\n\tputs(name);\n\treturn 0;\n&#125;\nint main()&#123;\n\ttest_stack();\n\treturn 0;\n&#125;\n\n上述程序实现的功能很简单，就是从scanf输入一个字符串，赋值到name，并且通过puts打印。\n是不是很简单！\n程序编译makefile为了便于说明，我们使用makefile文件进行编译。创建文件名为makefile的文件，内容如下：\n# makefile\nOBJ=stack\n\n$(OBJ):\n\tgcc main.c -o $@\n\nclean:\n\t-rm -rf $(OBJ)\n\n我们生成的文件名为stack，这里你可以改为你喜欢的任意名称。\n使用make命令进行编译，会生成最终文件。运行后就可以看见输出。\n提出问题C语言中函数栈是如何组织的呢？都有哪些元素呢？\n分析问题首先，我们通过汇编代码，理解上述C语言代码，我们能更加清晰的看出一个test_stack函数到底干了什么。相关内容我们在其后直接进行了注释。\n# objdump -d .&#x2F;stack\n.&#x2F;stack:     file format elf64-x86-64\n\n00000000004005f6 &lt;test_stack&gt;:\n  4005f6:\t55                   \tpush   %rbp\n  4005f7:\t48 89 e5             \tmov    %rsp,%rbp\n  4005fa:\t48 83 ec 30          \tsub    $0x30,%rsp #栈上开辟了0x30&#x3D;48的空间，注意我们的局部变量只需要25的空间\n  4005fe:\t64 48 8b 04 25 28 00 \tmov    %fs:0x28,%rax # 从%fs:0x28取了一个值，放在了栈底之上，这就是canary，一种栈溢出的保护措施\n  400605:\t00 00 \n  400607:\t48 89 45 f8          \tmov    %rax,-0x8(%rbp)\n  40060b:\t31 c0                \txor    %eax,%eax\n  40060d:\t48 c7 45 d0 00 00 00 \tmovq   $0x0,-0x30(%rbp) #char name[25] &#x3D; &#123;0&#125;;\n  400614:\t00 \n  400615:\t48 c7 45 d8 00 00 00 \tmovq   $0x0,-0x28(%rbp)\n  40061c:\t00 \n  40061d:\t48 c7 45 e0 00 00 00 \tmovq   $0x0,-0x20(%rbp)\n  400624:\t00 \n  400625:\tc6 45 e8 00          \tmovb   $0x0,-0x18(%rbp)\n  400629:\t48 8d 45 d0          \tlea    -0x30(%rbp),%rax\n  40062d:\t48 89 c6             \tmov    %rax,%rsi\n  400630:\tbf 04 07 40 00       \tmov    $0x400704,%edi #’%s&#39;\n  400635:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  40063a:\te8 a1 fe ff ff       \tcallq  4004e0 &lt;__isoc99_scanf@plt&gt;\n  40063f:\t48 8d 45 d0          \tlea    -0x30(%rbp),%rax\n  400643:\t48 89 c7             \tmov    %rax,%rdi\n  400646:\te8 65 fe ff ff       \tcallq  4004b0 &lt;puts@plt&gt;\n  40064b:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  400650:\t48 8b 55 f8          \tmov    -0x8(%rbp),%rdx\n  400654:\t64 48 33 14 25 28 00 \txor    %fs:0x28,%rdx #检查canary\n  40065b:\t00 00 \n  40065d:\t74 05                \tje     400664 &lt;test_stack+0x6e&gt;\n  40065f:\te8 5c fe ff ff       \tcallq  4004c0 &lt;__stack_chk_fail@plt&gt;\n  400664:\tc9                   \tleaveq \n  400665:\tc3                   \tretq   \n\n0000000000400666 &lt;main&gt;:\n  400666:\t55                   \tpush   %rbp\n  400667:\t48 89 e5             \tmov    %rsp,%rbp\n  40066a:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  40066f:\te8 82 ff ff ff       \tcallq  4005f6 &lt;test_stack&gt;\n  400674:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  400679:\t5d                   \tpop    %rbp\n  40067a:\tc3                   \tretq   \n  40067b:\t0f 1f 44 00 00       \tnopl   0x0(%rax,%rax,1)\n\n主要进行了以下操作：\n\ncallq操作。我们需要注意一个隐含操作，就是上述第40行callq  4005f6 &lt;test_stack&gt;,这个操作隐含将下一条指令地址压栈，即0x400674\n开辟栈空间。开辟了大小为48的栈空间，这里注意，我们的局部变量name只需要25大小的空间\ncanary值。从%fs:0x28取了一个值，放在了栈底之上，这就是canary，一种栈溢出的保护措施，最后对其检查\n初试化操作。使用3个movq和1个movb对name变量进行了初始化。name变量的起始地址为$rbp-0x30$即$rsp$栈顶\n赋值。使用scanf函数，对name变量进行了赋值\n\n其中，初始化，赋值通过汇编代码都很容易看出。下面我们通过gdb主要来看看栈结构吧。\n实验使用gdb+pwngdb插件进行解释，如不清楚，可私信我或加我公众号。\ncallq操作![image-20210721000901757](从hello world开始，拆解函数栈结构&#x2F;image-20210721000901757.png)\n在进行callq操作之前，rbp和rsp为同一地址，说明栈空间大小为0.\n![image-20210721001254187](从hello world开始，拆解函数栈结构&#x2F;image-20210721001254187.png)\n注意箭头部分，当我们进入test_stack函数时，callq操作，进行了隐含操作，callq的下一条指令地址压栈，在这里我们可以看出，其内容为0x400674，与我们静态分析汇编代码一致。验证了callq操作对栈的影响。\n开辟栈空间此操作中，注意rsp和rbp的变化。\n\npush指令，将栈底压栈。\n\n![image-20210721001715969](从hello world开始，拆解函数栈结构&#x2F;image-20210721001715969.png)\n\n将栈底和栈顶地址设为相同（可通过栈底的上一条内容01：0008，恢复上一个栈底）。\n\n![image-20210721001827503](从hello world开始，拆解函数栈结构&#x2F;image-20210721001827503.png)\n\n开辟栈空间，大小为0x30&#x3D;48。\n\n![image-20210721002102212](从hello world开始，拆解函数栈结构&#x2F;image-20210721002102212.png)\n红框中[00:0000-06:0030)之间，为当前test_stack栈帧中的结构，大小为0x30&#x3D;48字节。中间的数据为一些初始化函数执行过程中残留的栈数据，暂时不用管它。(s + buffer + canary)\nrbp为test_stack函数的第一个push rbp的操作压入的栈底（saved ebp)\n07:0038为test_stack函数执行完毕后的返回地址。(return address)\n示意图如下：\n\ncanary值如下图，我们继续执行两步，该函数在fs:[0x28]处取了一个值，然后放入了rbp-8的位置，即图中画线的位置，值为：0x92cb97cb6f51ae00，这个数就是我们所谓的canary，金丝雀。主要用来检测栈溢出。\n![image-20210721003510355](从hello world开始，拆解函数栈结构&#x2F;image-20210721003510355.png)\n然后我们查看栈顶开始的48个字节，即栈的内容\n![image-20210721004153415](从hello world开始，拆解函数栈结构&#x2F;image-20210721004153415.png)\ns: 0x7fffffffddd0:    （0x00000000    0x00000000    0x00000000    0x000000000x7fffffffdde0:    0x00000000    0x00000000    0x00）s表示我们局部变量填充的空间         \nbuffer: (000000    0x000000000x7fffffffddf0:    0x00400680    0x00000000)buffer    代表补齐8字节所占用的空间\ncanary: (0x6f51ae00    0x92cb97cb)canary 代表栈溢出检测指标。\n\n通过IDA pro验证我们的想法：\n![image-20210721010044515](从hello world开始，拆解函数栈结构&#x2F;image-20210721010044515.png)\n缓冲区溢出分析实际上我们花了大量的篇幅去讲栈的结构，其实目的就是这么一张图\n\n栈溢出其实就是使得字符串长度达到return address的位置，使得在函数执行完毕retn时，return address的地址弹出给rip寄存器，从而使得CPU按照rip寄存的内容执行下一条指令。这里面要非常清楚的就是栈的结构，栈空间的计算真正要做到”一字不差“！\n当然了，这里的canary对栈进行了保护，是一个随机生成的数。当然还有很多办法来绕过甚至是猜出canary，实现栈溢出，这不在本篇文章的范畴之内，留给下一次机会吧。\n总结对通过一个最简单的程序对栈的结构进行了静态和动态的分析，得出了一张刻画栈帧空间的图。对于栈的计算要十分的仔细，这样在pwn题中才能做到心中有数，一招制敌。\n","slug":"从hello world开始，拆解函数栈结构","date":"2022-02-27T03:25:34.000Z","categories_index":"","tags_index":"C语言,汇编,Linux","author_index":"明说网络"},{"id":"be2aefd6df4ec3bf22d97c5c151af3ce","title":"在你的hexo博客中使用nodeppt，一款迄今为止最好的网页版演示库","content":"大家好，我是明说网络的小明同学。\n今天我和大家分享一个非常酷的网页PPT工具，NODEPPT\nNODEPPT这可能是迄今为止最好的网页版演示库一开始看到这个库的时候，我就喜欢上了。因为他效果非常的棒，而且能够非常好的和hexo结合。这样我们能够一次生成，到哪都可以演示PPT，还能配上相应的技术文档，是不是很酷啊！\nNODEPPT Demo项目的演示网址在这：https://nodeppt.js.org/#slide=1\n\n主要说明了这个库包含什么样的功能\nNODE PPT Github官网地址：https://github.com/ksky521/nodeppt\nHexo中使用PPT Demo以下是我使用官网的demo制作的一个PPT，注意它是嵌入在我这个网页中的，以下网页你可以左右滑动。\n\n\n\n\n如果你觉得这个功能很酷，想要添加到你的站点里面去，那么就和我一起往下走吧。\n如何在Hexo中添加Nodeppt前提，确保你的noteppt能够正常使用。这是前提，至于怎么熟练的玩好nodeppt，额…… 还是去官网吧，这里不误导人了。\n整体的思路是，两步走：\n\n第一步先使用nodeppt在相应的public目录生成相应的文件,如html,js,img等等\n在post中引用相应的文件\n\n首先熟悉nodeppt的build方法输入nodeppt build --help\nUsage: nodeppt build [options] [entry]\n\nbuild html file\n\nOptions:\n  -m, --map         Release sourcemap\n  -d, --dest &lt;dir&gt;  output directory\n  -h, --help        output usage information\n  Examples:\n\n    nodeppt build slide.md\n\n我们需要使用的就是这个-d参数。目的是将生成的文件放入网站的public目录下\n源文件目录说明存放源文件的目录结构如下所示\nroot&#x2F;public\n\t\t├──nodeppt\nroot&#x2F;source\n├── slideshare\n│   ├── another.md\n│   ├── build.sh\n│   ├── buildlist.txt\n│   ├── makefile\n│   └── slides.md\n\n\nbuildlist.txt 代表等待生成的ppt文件列表\n\nslides.md\nanother.md%\n\n\nbuild.sh \n在slideshare目录下运行本文件，作用是使用nodeppt按上面文件内容的顺序构建，输出目录为public/nodeppt\n\n\nNODEPPT&#x3D;&#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;node&#x2F;17.5.0&#x2F;bin&#x2F;nodeppt\nDestination&#x3D;..&#x2F;..&#x2F;public&#x2F;nodeppt&#x2F;\nbuild_files&#x3D;$(cat buildlist.txt | xargs)\nfor file in $build_files\ndo\n    # echo $file\n    $NODEPPT build .&#x2F;$file -d $Destination\ndone\n\n\nmakefile 本文件主要用于使用一个脚本完成所有的工作\n\nall:\n        bash build.sh\n\n至此，你使用在当前目录make就能将生成好的PPT网页放入public目录的noteppt目录中。\n那么怎么使用呢？在上一步中，我们生成了ppt文件，放在了public/nodeppt/中，假设文件名为slides.html\n那么我们可以在hexo的post中简单的使用如下命令，就可以引用我们的PPT\n&lt;iframe src=\"../nodeppt/slides.html\" width=\"100%\" height=\"500\" name=\"topFrame\" scrolling=\"yes\" noresize=\"noresize\" frameborder=\"0\" id=\"topFrame\">&lt;/iframe>\n\n需要修改的部分就是iframe中的src部分。\n最后放下一个一键上线部署的脚本\nall:\n\tmake nodeppt\n\thexo g \n\thexo d \n\nnodeppt:\n\t$(MAKE) -C source/slideshare/\n\ntest:\n\tmake nodeppt\n\thexo g\n\thexo s\n\ndeploy:\n\tmake nodeppt\n\thexo g \n\thexo d\n\t\n\n最后附上本次示例的PPT试试看左右滑动\n\n\n参考资料静态压缩https://hasaik.com/posts/495d0b23.html\n使用Hexo-Neat成功https://github.com/rozbo/hexo-neat\nHexo静态资源压缩https://www.jianshu.com/p/5e48e532ae58\nhttps://rye-catcher.github.io/2019/10/21/Nodeppt-%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97/\n给博客文章嵌入 PPT 演示https://hexo.fluid-dev.com/posts/hexo-nodeppt/\n添加自定义网页https://www.jianshu.com/p/524b073f9b37\n","slug":"NODEPPT这可能是迄今为止最好的网页版演示库","date":"2022-02-26T09:25:15.461Z","categories_index":"","tags_index":"","author_index":"明说网络"},{"id":"e7a0c4de13a6bfb607295b456c1a63ce","title":"VSCode Markdown Snippet插件的使用问题备注","content":"VSCode Markdown Snippet插件的使用问题备注官方给出的使用帮助https://code.visualstudio.com/docs/editor/userdefinedsnippets\n一个简短的示例https://www.jianshu.com/p/a87e9ca2d208\n记得在配置文件中添加相应的配置，不仅仅是相关语言的配置哦，setting中也记得\nhttps://blog.csdn.net/serryuer/article/details/89393760\n代码备注\"hexo title\": &#123;\n\t\t\"prefix\": \"hexo\",\n\t\t\"body\": [\n\t\t\t\"---\",\n\t\t\t\"title: $CLIPBOARD\",\n\t\t\t\"date: $&#123;3:$CURRENT_YEAR&#125;-$&#123;4:$CURRENT_MONTH&#125;-$&#123;5:$CURRENT_DATE&#125; $&#123;6:$CURRENT_HOUR&#125;:$&#123;7:$CURRENT_MINUTE&#125;:$&#123;8:$CURRENT_SECOND&#125;\",\n\t\t\t// \"categories: $&#123;9|咨询, 编程开发, 网络空间, 学习笔记, 科普|&#125;\",\n\t\t\t// \"tags: [$&#123;10:tags&#125;]\",\n\t\t\t\"---\",\n\t\t\t\"$11\"\n\t\t],\n\t\t\"description\": \"Front-Matter\"\n\t&#125;\n\n效果如下所示：\n---\ntitle: 大家好，我是明说网络的小明同学\ndate: 2022-02-26 17:20:22\n---\n\n","slug":"VSCode Markdown Snippet插件的使用问题备注","date":"2022-02-26T09:22:13.000Z","categories_index":"","tags_index":"","author_index":"明说网络"},{"id":"bc80ff236e2a1555d11b2ba09309eece","title":"一个github快速建站主题推荐GitHub+Hexo+AURORA","content":"\ntitle: 大家好，我是明说网络的小明同学date: 2022-02-26 17:20:22\n\n大家好，我是明说网络的小明同学\n今天给大家推荐一块非常快速的建站工具Github + AURORA\nGithub建站github免费建站就不说了，网上有很多教程。\nHexo快速生成可以用Markdown协作写作的网站如果你还没有使用过Hexo，那么从官方文档里可以快速学会使用。https://hexo.io/zh-cn/docs/\nHexo一个比较吸引我的功能就是，能够以极少的代价，完成网站主题的切换。\n必备评论插件GitTalk，可以看这篇文章\nhttps://blog.csdn.net/qq_33384402/article/details/107200465\n推荐一块比较好的主题AURORA插件主题长这个样子\n\n插件具有详细的说明文档 https://aurora.tridiamond.tech/zh/guide/\n该主题的网址：https://github.com/auroral-ui/hexo-theme-aurora\n关于图片显示的问题关于图片显示，建议看这篇文章，https://moeci.com/posts/hexo-typora/\n描述了，怎么结合hexo和typora来实现markdown无缝衔接，并且还能深入了解图片出错到底是什么原因\n不过该博主的插件最终也没有让我成功，还是hexo-asset-image救了我https://github.com/xcodebuild/hexo-asset-image\n最后给自己打个广告吧发现大家都好牛啊！\n\n大家可以通过主页的相关链接在你喜欢的平台找到我！\n","slug":"一个github快速建站主题推荐","date":"2022-02-26T07:22:13.000Z","categories_index":"","tags_index":"","author_index":"明说网络"},{"id":"80d7880307bc3e28a3dae58ad9de77ec","title":"从一个hello world说起","content":"从一个hello world说起大家好，我是明说网络的小明同学。今天我们从C语言的Hello World说起，和大家一起温习一下C语言中一个Hello World怎么运行起来的，以及C语言如何组织栈缓冲区等。本文不适用于C语言初学者，需要具备有一定的汇编基础。好了下面，我们开始吧。\n工具本文的工具为：\n操作系统：Ubuntu16.04， 4.15.0-142-generic\n\n编译器：gcc version 5.4.0 20160609 (Ubuntu 5.4.0-6ubuntu1~16.04.12)\n\nmake工具GNU Make 4.1\n\n反汇编查看器：objdump\n\nelf文件查看器：readelf\n\ngdb，pwngdb\n\n\n\nC语言介绍C 语言是一种通用的高级语言，最初是由丹尼斯·里奇在贝尔实验室为开发 UNIX 操作系统而设计的。UNIX 操作系统，C编译器，和几乎所有的 UNIX 应用程序都是用 C 语言编写的。由于各种原因，C 语言现在已经成为一种广泛使用的专业语言。\n同时，C语言是一门大学期间基本上都会开设的课程。作为一门入门编程课程，C语言有着独特的魅力和不可替代的作用。虽然当前python火热，C语言好像显得不那么重要了，“python难道不香吗”的疑问开始出现。但是我的观点是：每种语言有每种语言的优势，python永远也取代不了C语言。像我独爱指针，能够带来自由的感觉。\n下面就开始我们的探索之旅吧。\n第一个程序helloworld编写程序首先我们有如下程序：main.c\n//main.c\n#include &lt;stdio.h>\nint display(char *name)&#123;\n\t\n\tprintf(\"hello world! %s\\n\", name);\n&#125;\n\nint \nmain()&#123;\n\tchar name[256] = \"I'm a string\";\n\tdisplay(name);\n\treturn 0;\n&#125;\n\n上述程序实现的功能很简单，就是输出一句话hello world! I&#39;m a string，为了便于说明，其中故意使用了一个函数调用int display(char *)。\n函数的逻辑为，main函数–&gt; display()函数(一个参数)–&gt;printf函数(两个参数)。\n是不是很简单！\n程序编译makefile为了便于说明，我们使用makefile文件进行编译。创建文件名为makefile的文件，内容如下：\n# makefile\nOBJ=printf.main\n\n$(OBJ):\n\tgcc main.c -o $@\n\nclean:\n\t-rm $(OBJ)\n\n我们生成的文件名为printf.main，这里你可以改为你喜欢的任意名称。\n使用make命令进行编译，会生成最终文件。运行后就可以看见hello world! I&#39;m a string\n小结到这里我们就完成了一个helloworld程序的编写和编译，并且运行。是不是很简单。对于初学者，其实到这里就完了，姑且可以认为main函数就是一个程序的开始和结束（我曾经就一直这么认为）。但是对于有过一定经验的人来说，就知道：main函数并不是一个程序的开始，也不是一个程序的结束。\n咦，这么神奇的吗？就让我们来看看吧。\nHello world 的背后首先让我们来认识一下我们生成的printf.main。\nfile .&#x2F;printf.main \n.&#x2F;printf.main: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter &#x2F;lib64&#x2F;ld-linux-x86-64.so.2, for GNU&#x2F;Linux 2.6.32, BuildID[sha1]&#x3D;5c389a402866aaa012b8b8ab992fed778eb989b0, not stripped\n\n\n\nELF是执行和链接格式（Execurable and Linking Format）的缩略词。它是UNIX系统的几种可执行文件格式中的一种。\n使用命令readelf -h ./printf.main &gt; elf_head.txt\nELF Header:\n  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 \n  Class:                             ELF64\n  Data:                              2&#39;s complement, little endian\n  Version:                           1 (current)\n  OS&#x2F;ABI:                            UNIX - System V\n  ABI Version:                       0\n  Type:                              EXEC (Executable file)\n  Machine:                           Advanced Micro Devices X86-64\n  Version:                           0x1\n  Entry point address:               0x4004a0 &#x2F;&#x2F;注意这一行\n  Start of program headers:          64 (bytes into file)\n  Start of section headers:          6712 (bytes into file)\n  Flags:                             0x0\n  Size of this header:               64 (bytes)\n  Size of program headers:           56 (bytes)\n  Number of program headers:         9\n  Size of section headers:           64 (bytes)\n  Number of section headers:         31\n  Section header string table index: 28\n\n这里面，我们注意第11行，Entry point address:               0x4004a0,显示，入口点地址为address，说明操作系统在运行这个printf.main程序时，首先从这个地址开始运行。那么我们看看这个地址到底是什么吧\n汇编使用命令objdump -d printf.main &gt; objdump.txt将程序的汇编代码提取出来（删除了一些当前没有必要说明的内容），如下所示：\n\nprintf.main:     file format elf64-x86-64\n\n\nDisassembly of section .init:\n\n0000000000400428 &lt;_init&gt;:\n  400428:\t48 83 ec 08          \tsub    $0x8,%rsp\n  40042c:\t48 8b 05 c5 0b 20 00 \tmov    0x200bc5(%rip),%rax        # 600ff8 &lt;_DYNAMIC+0x1d0&gt;\n  400433:\t48 85 c0             \ttest   %rax,%rax\n  400436:\t74 05                \tje     40043d &lt;_init+0x15&gt;\n  400438:\te8 53 00 00 00       \tcallq  400490 &lt;__libc_start_main@plt+0x10&gt;\n  40043d:\t48 83 c4 08          \tadd    $0x8,%rsp\n  400441:\tc3                   \tretq   \n\nDisassembly of section .plt:\n\n\n0000000000400470 &lt;printf@plt&gt;:\n  400470:\tff 25 aa 0b 20 00    \tjmpq   *0x200baa(%rip)        # 601020 &lt;_GLOBAL_OFFSET_TABLE_+0x20&gt;\n  400476:\t68 01 00 00 00       \tpushq  $0x1\n  40047b:\te9 d0 ff ff ff       \tjmpq   400450 &lt;_init+0x28&gt;\n\n0000000000400480 &lt;__libc_start_main@plt&gt;:\n  400480:\tff 25 a2 0b 20 00    \tjmpq   *0x200ba2(%rip)        # 601028 &lt;_GLOBAL_OFFSET_TABLE_+0x28&gt;\n  400486:\t68 02 00 00 00       \tpushq  $0x2\n  40048b:\te9 c0 ff ff ff       \tjmpq   400450 &lt;_init+0x28&gt;\n\nDisassembly of section .plt.got:\n\n0000000000400490 &lt;.plt.got&gt;:\n  400490:\tff 25 62 0b 20 00    \tjmpq   *0x200b62(%rip)        # 600ff8 &lt;_DYNAMIC+0x1d0&gt;\n  400496:\t66 90                \txchg   %ax,%ax\n\nDisassembly of section .text:\n\n00000000004004a0 &lt;_start&gt;:\n  4004a0:\t31 ed                \txor    %ebp,%ebp\n  4004a2:\t49 89 d1             \tmov    %rdx,%r9\n  4004a5:\t5e                   \tpop    %rsi\n  4004a6:\t48 89 e2             \tmov    %rsp,%rdx\n  4004a9:\t48 83 e4 f0          \tand    $0xfffffffffffffff0,%rsp\n  4004ad:\t50                   \tpush   %rax\n  4004ae:\t54                   \tpush   %rsp\n  4004af:\t49 c7 c0 b0 06 40 00 \tmov    $0x4006b0,%r8 &#x2F;&#x2F;00000000004006b0 &lt;__libc_csu_fini&gt;:\n  4004b6:\t48 c7 c1 40 06 40 00 \tmov    $0x400640,%rcx &#x2F;&#x2F;0000000000400640 &lt;__libc_csu_init&gt;:\n  4004bd:\t48 c7 c7 bb 05 40 00 \tmov    $0x4005bb,%rdi &#x2F;&#x2F;00000000004005bb &lt;main&gt;:\n  4004c4:\te8 b7 ff ff ff       \tcallq  400480 &lt;__libc_start_main@plt&gt;\n  4004c9:\tf4                   \thlt    \n  4004ca:\t66 0f 1f 44 00 00    \tnopw   0x0(%rax,%rax,1)\n\n0000000000400596 &lt;display&gt;:\n  400596:\t55                   \tpush   %rbp\n  400597:\t48 89 e5             \tmov    %rsp,%rbp\n  40059a:\t48 83 ec 10          \tsub    $0x10,%rsp\n  40059e:\t48 89 7d f8          \tmov    %rdi,-0x8(%rbp)\n  4005a2:\t48 8b 45 f8          \tmov    -0x8(%rbp),%rax\n  4005a6:\t48 89 c6             \tmov    %rax,%rsi\n  4005a9:\tbf c4 06 40 00       \tmov    $0x4006c4,%edi\n  4005ae:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  4005b3:\te8 b8 fe ff ff       \tcallq  400470 &lt;printf@plt&gt;\n  4005b8:\t90                   \tnop\n  4005b9:\tc9                   \tleaveq \n  4005ba:\tc3                   \tretq   \n\n00000000004005bb &lt;main&gt;:\n  4005bb:\t55                   \tpush   %rbp\n  4005bc:\t48 89 e5             \tmov    %rsp,%rbp\n  4005bf:\t48 81 ec 10 01 00 00 \tsub    $0x110,%rsp\n  4005c6:\t64 48 8b 04 25 28 00 \tmov    %fs:0x28,%rax\n  4005cd:\t00 00 \n  4005cf:\t48 89 45 f8          \tmov    %rax,-0x8(%rbp)\n  4005d3:\t31 c0                \txor    %eax,%eax\n  4005d5:\t48 b8 49 27 6d 20 61 \tmovabs $0x74732061206d2749,%rax\n  4005dc:\t20 73 74 \n  4005df:\t48 89 85 f0 fe ff ff \tmov    %rax,-0x110(%rbp)\n  4005e6:\t48 c7 85 f8 fe ff ff \tmovq   $0x676e6972,-0x108(%rbp)\n  4005ed:\t72 69 6e 67 \n  4005f1:\t48 8d 95 00 ff ff ff \tlea    -0x100(%rbp),%rdx\n  4005f8:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  4005fd:\tb9 1e 00 00 00       \tmov    $0x1e,%ecx\n  400602:\t48 89 d7             \tmov    %rdx,%rdi\n  400605:\tf3 48 ab             \trep stos %rax,%es:(%rdi)\n  400608:\t48 8d 85 f0 fe ff ff \tlea    -0x110(%rbp),%rax\n  40060f:\t48 89 c7             \tmov    %rax,%rdi\n  400612:\te8 7f ff ff ff       \tcallq  400596 &lt;display&gt;\n  400617:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  40061c:\t48 8b 75 f8          \tmov    -0x8(%rbp),%rsi\n  400620:\t64 48 33 34 25 28 00 \txor    %fs:0x28,%rsi\n  400627:\t00 00 \n  400629:\t74 05                \tje     400630 &lt;main+0x75&gt;\n  40062b:\te8 30 fe ff ff       \tcallq  400460 &lt;__stack_chk_fail@plt&gt;\n  400630:\tc9                   \tleaveq \n  400631:\tc3                   \tretq   \n  400632:\t66 2e 0f 1f 84 00 00 \tnopw   %cs:0x0(%rax,%rax,1)\n  400639:\t00 00 00 \n  40063c:\t0f 1f 40 00          \tnopl   0x0(%rax)\n\n0000000000400640 &lt;__libc_csu_init&gt;:\n  400640:\t41 57                \tpush   %r15\n  400642:\t41 56                \tpush   %r14\n  400644:\t41 89 ff             \tmov    %edi,%r15d\n  400647:\t41 55                \tpush   %r13\n  400649:\t41 54                \tpush   %r12\n  40064b:\t4c 8d 25 be 07 20 00 \tlea    0x2007be(%rip),%r12        # 600e10 &lt;__frame_dummy_init_array_entry&gt;\n  400652:\t55                   \tpush   %rbp\n  400653:\t48 8d 2d be 07 20 00 \tlea    0x2007be(%rip),%rbp        # 600e18 &lt;__init_array_end&gt;\n  40065a:\t53                   \tpush   %rbx\n  40065b:\t49 89 f6             \tmov    %rsi,%r14\n  40065e:\t49 89 d5             \tmov    %rdx,%r13\n  400661:\t4c 29 e5             \tsub    %r12,%rbp\n  400664:\t48 83 ec 08          \tsub    $0x8,%rsp\n  400668:\t48 c1 fd 03          \tsar    $0x3,%rbp\n  40066c:\te8 b7 fd ff ff       \tcallq  400428 &lt;_init&gt;\n  400671:\t48 85 ed             \ttest   %rbp,%rbp\n  400674:\t74 20                \tje     400696 &lt;__libc_csu_init+0x56&gt;\n  400676:\t31 db                \txor    %ebx,%ebx\n  400678:\t0f 1f 84 00 00 00 00 \tnopl   0x0(%rax,%rax,1)\n  40067f:\t00 \n  400680:\t4c 89 ea             \tmov    %r13,%rdx\n  400683:\t4c 89 f6             \tmov    %r14,%rsi\n  400686:\t44 89 ff             \tmov    %r15d,%edi\n  400689:\t41 ff 14 dc          \tcallq  *(%r12,%rbx,8)\n  40068d:\t48 83 c3 01          \tadd    $0x1,%rbx\n  400691:\t48 39 eb             \tcmp    %rbp,%rbx\n  400694:\t75 ea                \tjne    400680 &lt;__libc_csu_init+0x40&gt;\n  400696:\t48 83 c4 08          \tadd    $0x8,%rsp\n  40069a:\t5b                   \tpop    %rbx\n  40069b:\t5d                   \tpop    %rbp\n  40069c:\t41 5c                \tpop    %r12\n  40069e:\t41 5d                \tpop    %r13\n  4006a0:\t41 5e                \tpop    %r14\n  4006a2:\t41 5f                \tpop    %r15\n  4006a4:\tc3                   \tretq   \n  4006a5:\t90                   \tnop\n  4006a6:\t66 2e 0f 1f 84 00 00 \tnopw   %cs:0x0(%rax,%rax,1)\n  4006ad:\t00 00 00 \n\n00000000004006b0 &lt;__libc_csu_fini&gt;:\n  4006b0:\tf3 c3                \trepz retq \n\nDisassembly of section .fini:\n\n00000000004006b4 &lt;_fini&gt;:\n  4006b4:\t48 83 ec 08          \tsub    $0x8,%rsp\n  4006b8:\t48 83 c4 08          \tadd    $0x8,%rsp\n  4006bc:\tc3                   \tretq   \n\n\n\n这里我们注意第45，46，47，48行，注意其中\n4004af:\t49 c7 c0 b0 06 40 00 \tmov    $0x4006b0,%r8 &#x2F;&#x2F;00000000004006b0 &lt;__libc_csu_fini&gt;:\n4004b6:\t48 c7 c1 40 06 40 00 \tmov    $0x400640,%rcx &#x2F;&#x2F;0000000000400640 &lt;__libc_csu_init&gt;:\n4004bd:\t48 c7 c7 bb 05 40 00 \tmov    $0x4005bb,%rdi &#x2F;&#x2F;00000000004005bb &lt;main&gt;:\n4004c4:\te8 b7 ff ff ff       \tcallq  400480 &lt;__libc_start_main@plt&gt;\n\n__libc_start_main@plt包含了三个参数，__libc_csu_fini,__libc_csu_init,main显然，从名称上就可以看出这四个函数的作用。\n__libc_start_main是libc.so.6中的一个函数。它的原型是这样的：\nextern int BP_SYM (__libc_start_main) (int (*main) (int, char **, char **),\n\t\tint argc,\n\t\tchar *__unbounded *__unbounded ubp_av,\n\t\tvoid (*init) (void),\n\t\tvoid (*fini) (void),\n\t\tvoid (*rtld_fini) (void),\n\t\tvoid *__unbounded stack_end)\n__attribute__ ((noreturn));\n\n这个函数需要做的是建立&#x2F;初始化一些数据结构&#x2F;环境然后调用我们的main()。\n程序启动的过程应该：_start -&gt; __libc_start_main -&gt; __libc_csu_init -&gt; _init -&gt; main -&gt; _fini.\n这篇文章有详细的说明：linux编程之main()函数启动过程\n栈缓冲区及结构\n\n\n\n\n\n\n\n\n汇编基础x86_64有16个64位寄存器，分别是：\n%rax，%rbx，%rcx，%rdx，%esi，%edi，%rbp，%rsp，%r8，%r9，%r10，%r11，%r12，%r13，%r14，%r15。\n其中：\n%rax 作为函数返回值使用。%rsp 栈指针寄存器，指向栈顶%rdi，%rsi，%rdx，%rcx，%r8，%r9 用作函数参数，依次对应第1参数，第2参数%rbx，%rbp，%r12，%r13，%14，%15 用作数据存储，遵循被调用者使用规则，简单说就是随便用，调用子函数之前要备份它，以防他被修改%r10，%r11 用作数据存储，遵循调用者使用规则，简单说就是使用之前要先保存原值\n64位与32位的不同在于64位不用压栈来存储下一个函数参数，而是放在了%rdi，%rsi，%rdx，%rcx，%r8，%r9六个寄存器中，超出部分再压栈。\n\n\n\n首先，我们将main.c文件进行汇编，使用命令gcc -S main.c，在当前目录下回生成main.s的汇编文件，内容如下：\n\t.file\t&quot;main.c&quot;\n\t.section\t.rodata\n.LC0:\n\t.string\t&quot;hello world! %s\\n&quot;\n\t.text\n\t.globl\tdisplay\n\t.type\tdisplay, @function\ndisplay:\n.LFB0:\n\t.cfi_startproc\n\tpushq\t%rbp\n\t.cfi_def_cfa_offset 16\n\t.cfi_offset 6, -16\n\tmovq\t%rsp, %rbp\n\t.cfi_def_cfa_register 6\n\tsubq\t$16, %rsp\n\tmovq\t%rdi, -8(%rbp)\n\tmovq\t-8(%rbp), %rax\n\tmovq\t%rax, %rsi\n\tmovl\t$.LC0, %edi\n\tmovl\t$0, %eax\n\tcall\tprintf\n\tnop\n\tleave\n\t.cfi_def_cfa 7, 8\n\tret\n\t.cfi_endproc\n.LFE0:\n\t.size\tdisplay, .-display\n\t.globl\tmain\n\t.type\tmain, @function\nmain:\n.LFB1:\n\t.cfi_startproc\n\tpushq\t%rbp\n\t.cfi_def_cfa_offset 16\n\t.cfi_offset 6, -16\n\tmovq\t%rsp, %rbp\n\t.cfi_def_cfa_register 6\n\tsubq\t$272, %rsp\n\tmovq\t%fs:40, %rax\n\tmovq\t%rax, -8(%rbp)\n\txorl\t%eax, %eax\n\tmovabsq\t$8391086132249306953, %rax &#x2F;&#x2F;0x74732061206d2749 (&quot;I&#39;m a st&quot;)\n\tmovq\t%rax, -272(%rbp)\n\tmovq\t$1735289202, -264(%rbp)\n\tleaq\t-256(%rbp), %rdx\n\tmovl\t$0, %eax\n\tmovl\t$30, %ecx\n\tmovq\t%rdx, %rdi\n\trep stosq\n\tleaq\t-272(%rbp), %rax\n\tmovq\t%rax, %rdi &#x2F;&#x2F;使用%rdi寄存器压入参数\n\tcall\tdisplay &#x2F;&#x2F;调用函数\n\tmovl\t$0, %eax\n\tmovq\t-8(%rbp), %rsi\n\txorq\t%fs:40, %rsi\n\tje\t.L4\n\tcall\t__stack_chk_fail\n.L4:\n\tleave\n\t.cfi_def_cfa 7, 8\n\tret\n\t.cfi_endproc\n.LFE1:\n\t.size\tmain, .-main\n\t.ident\t&quot;GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.12) 5.4.0 20160609&quot;\n\t.section\t.note.GNU-stack,&quot;&quot;,@progbits\n\nmain函数在53，54行，使用rdi压入了一个参数，参数的地址在-272(%rbp)（即rdi）, 可以看出正好是字符串”I’m a string”的地址。如下所示：![image-20210719112214862](从一个hello world说起&#x2F;image-20210719112214862.png)\n其中，函数调用栈缓冲区backtrace显示当前栈缓冲区为main，再上一层为__libc_start_main，再次印证了上一节的说法。\ndisplay函数下面我们进入display函数，可以看出printf的两个参数分别放在rdi,rsi两个寄存器当中。\n![image-20210719112513484](从一个hello world说起&#x2F;image-20210719112513484.png)其中，函数调用栈缓冲区backtrace显示当前栈缓冲区为display，再上一层为main，__libc_start_main，再次印证了上一节的说法。\n小结通过对main函数中display函数的参数，display函数中的printf函数的参数进行实验，说明了C语言在函数调用时的栈缓冲区的组织。\n结语对于一个普普通通的C语言程序，其实其背后是一堆复杂的操作系统预备好的操作，执行完毕之后，就开始执行我们的main函数。main函数并不是程序执行的第一个函数，当然也不是最后一个。我们编写的程序的main函数，仅仅是操作系统在加载elf文件时候调用的函数而已，仅仅是函数而已。\n栈缓冲区的组织，一定要动手自己调一调，理解栈缓冲区，有助于理解pwn题中的栈缓冲的利用。\n这就是我喜欢C语言的原因，因为他能让我更加清晰的看到程序运行的背后，而像python这类语言，我也使用，因为真的方便，但是对于理解计算机、理解背后的故事非常的不利。\n关注我，学习更多系统的知识！\n","slug":"从一个hello world说起","date":"2022-02-26T06:14:18.000Z","categories_index":"","tags_index":"","author_index":"明说网络"},{"id":"9807e6187d5c7b84b8bf1e1617776da6","title":"IT、制造业和医疗卫生部门成为网络攻击的重点目标","content":"IT、制造业和医疗卫生部门成为网络攻击的重点目标\n医疗保健和制造业受到主动的网络攻击，这已经不是什么秘密。威胁形势已经发生了巨大的变化，而且事情正在变得越来越糟糕。除了这两个行业，IT行业也已成为网络攻击的最主要目标之一。\n一些统计数字Avanan公司最近的一份报告对今年上半年的网络攻击趋势作了说明。\n\nIT行业的公司见证了9000多封钓鱼邮件，其次是医疗保健和制造业，每10,000名用户每30天大约有6000封钓鱼邮件。\n在所有网络钓鱼攻击中，凭证收集占54%，BEC攻击占20.7%，敲诈占2.2%。\n黑客已经开始瞄准非行政人员，而不是C级行政人员，占据了77%的份额。\n\n为什么这很重要？当医疗机构受到勒索软件攻击者的攻击，制造业公司不断遭受供应链中断的影响时，黑客已经诉诸于最基本的战术–钓鱼邮件来进行未经授权的访问。这些行业非常容易受到网络攻击，因为它们管理着有价值的信息，而这些信息在暗网市场上需求很大。此外，设施设备仍然使用过时的技术，再加上缺乏适当的员工培训和基本的网络安全防护知识，使这些部门被攻击者盯上。\n底线现在，我们已经意识到网络犯罪分子为实现其邪恶的意图会不惜一切代价。诸如网络钓鱼和社会工程等经久不衰的方法，以及诸如供应链攻击等独特而复杂的方法，都被用来获得对未受保护或保护不力的系统的访问。如果没有适当的防御措施，这些部门将继续成为网络攻击的目标。\n","slug":"IT、制造业和医疗卫生部门成为网络攻击的重点目标","date":"2022-02-26T06:11:30.000Z","categories_index":"","tags_index":"","author_index":"明说网络"},{"id":"8708e15dc4de03655a3a2a73c34a0509","title":"favicon 图标被黑客用来加载后门程序","content":"favicon 图标被黑客用来加载后门程序\n网络犯罪分子正在分发伪装成favicon的恶意PHP web shells，以实现对被攻击服务器的远程访问，并将JavaScript skimmers注入在线购物平台，目的是窃取用户的财务信息。\nMalwarebytes Jérôme Segura表示，这些被称为Smilodon或Megalodon的Web shells被用来通过服务器端请求动态加载JavaScript skimming代码到在线商店。这种技术很有趣，因为大多数客户端的安全工具将无法检测或阻挡盗取者。\n原理Magecart，针对在线购物网站的黑客组织使用在电子商务网站上注入网络盗取器(web skimmers)的技术来窃取信用卡的详细信息。盗取器(skimmers )也被称为形式劫持攻击，盗取器采取JavaScript代码的形式，操作者秘密插入电子商务网站，通常是在支付页面，目的是实时捕捉客户的银行卡信息，并将其传输到远程服务器。\n注入式盗刷器的工作原理是，当客户访问网店时，向托管在攻击者控制的域名上的外部JavaScript资源发出客户端请求。然而，最新的攻击有点不同，因为盗取代码是在服务器端动态引入商家网站的。\n基于PHP的网络外壳恶意软件伪装成favicon（”Magento.png”），通过篡改HTML代码中的快捷图标标签指向假的PNG图像文件，将恶意软件插入到被攻击的网站。这个网络shell又被配置为从外部主机-获取下一阶段的有效载荷:一个信用卡盗刷器。\n恶意活动关联基于TTPs( tactics, techniques, and procedures)的重叠，最新的活动被归结为Magecart Group 12。Malwarebytes补充说，他们发现的最新域名（zolo[.]pw）恰好与recaptcha-in[.]pw和google-statik[.]pw托管在同一个IP地址（217.12.204[.]185），这两个域名之前与Magecart Group 12有关。\n在过去的几个月里，Magecart的行为者使用了几种攻击技术来避免被发现和渗出数据。\n","slug":"favicon 图标被黑客用来加载后门程序","date":"2022-02-26T06:11:22.000Z","categories_index":"","tags_index":"","author_index":"明说网络"},{"id":"f96ed811fade379654328c338b87a284","title":"网络电子身份标识(eID) -你的网络空间身份证","content":"网络电子身份标识(eID) -你的网络空间身份证在现实世界中，你的唯一身份由身份证标识。那么网络空间中呢？一起来看看吧\n什么是身份标识在物理世界中，《居民身份证法》的规定 ，“公民身份号码是每个公民唯一的、终身不变的身份代 码，由公安机关按照公民身份号码国家标准编制。”\n什么是网络电子身份标识eID数字身份是实体社会中的自然人身份在数字空间的映射。在网络空间，数字身份同样具有唯一性特征，其作用是要在一定范围内识别某 一主体，使之与其他主体区分开来。\n国际上，eID通常是由政府颁发给公民用于线上和线下识别身份的证件。欧盟多个国家已经颁发了eID来替代传统的身份证件，使eID既具备了线下身份识别的功能，又具备了网络远程身份识别功能。目前已经发行eID的国家有德国、法国、西班牙、意大利、俄罗斯、比利时、爱沙尼亚、奥地利、丹麦、芬兰、葡萄牙、斯洛文尼亚、立陶宛、马耳他、卢森堡、荷兰、瑞典、冰岛、阿联酋以及我国香港特别行政区等。其中，德国、西班牙、意大利、比利时、爱沙尼亚和奥地利已经普及，广泛用于电子政务、电子商务、社交网络等各个领域。\n\n为什么需要数字身份证我国网络发展至今，一直延用了物理空间的公民身份号码作为线上公民数字身 份的区分职能。但是存在诸多问题\n\n容易造成个人信息泄露。\n\n，由于公民身份号码隐含了个人户籍所在地、出生日期、性别 等个人信息，在开放的互联网上直接使用公民身份号码，无疑会对个人信息安全带 来极大的隐患和危害。多年来的实践反复证明，仅仅使用姓名＋公民身份号码代表公民的线 上身份，造成了大量的个人信息泄露。\n\n个人信息比对正确并不能代表本人真实意愿，无法防范个人身份被冒用或盗用的风险\n\n与线下环 境身份认证方式（身份证要求本人出示，由核验方查实证件真伪及判断是否“人证 合一”）不同的是，在线上填写公民身份号码既无法验证身份的真伪、也难以证明 是出自本人意愿。\n作为个人信息的重要代表，公民身份号 码不宜直接作为数字身份来使用：它只起到了唯一区分的作用，而无法对个人信息 进行保护。因此，结合我国现有身份管理的成就以及网络社会个人信息保护的现实 需求，有必要以公民身份号码为根（唯一性），建设既能保护个人信息安全又能适 应网络社会数据开放和流通需求的统一数字身份体系。\n公安部第三研究所于十二五期间承担了国家863计划“网域空间身份管理”等信息安全重大专项，研发了“网络电子身份标识（elD）”技术并形成了相关标准体系。\neID 数字身份基本概念eID 数字身份eID 数字身份是以公民身份号码为根，由“公民网络身份识别系统”基于密码算法(国密sm2，公钥密码体制)统一为中国公民生成的数字标记。 eID 数字身份既可以保证签发给每个公民的数字标记的唯一识别性，又可以减 少公民身份明文信息在互联网上的传播，又可以实现不同应用中公民 eID 数字身份 有条件的互通。\neID 数字身份特性eID依据《居民身份证法》《电子签名法》和《网络安全法》等相关法律要求，既可以解决数字空间由于数据的虚拟性、易复制性、易重构性等特性所带来的主体识别、数据确权授权、行为抗抵赖和隐私保护等难题，也可以在物理空间解决传统离线证件难以有效挂失的缺陷，具备便捷、安全、唯一、规范和跨域的特点。\n\n便捷性：分钟级空中开通、秒级认证，兼具线上身份认证和线下身份证明功能；\n\n安全性：基于国密算法、智能安全芯片，借助现场活体人脸检测和身份证内置照片识别保证人证同一；\n\n唯一性：一人同时只能有一个eID，可有效挂失或注销；\n\n规范性：相关格式、载体、机具和验证等国家标准已于2019年5月起正式实施；\n\n跨域性：可实现跨应用、跨行业、跨地区的无差别使用。\n\n\neID 数字身份特点eID 数字身份有以下特点： \n\neID 数字身份以公民身份号码为根生成；\n\neID 数字身份基于密码算法产生，从 eID 数字身份无法逆推出公民身份号码原文； \n\neID 数字身份采用碎片化方法生成：对于不同的 CSP，同一注册用户的 eID 数字身份并不相同；对于同一 CSP 的不同 RP，同一注册用户的 eID 数字 身份也不相同；\n\neID 数字身份由“公民网络身份识别系统”统一管理，碎片化处理后的 eID 数字身份在“公民网络身份识别系统”内可实现与公民身份号码的关联。\n\n\n\neID功能eID具有\n\n在线身份认证\n签名验签\n线下身份认证\n\n等功能，能够在保护公民个人信息安全的前提下准确识别自然人主体身份，可以运用在网上签约授权、交易支付、航旅服务、酒店住宿等多种场景。\n数字身份的认证如何认证数字身份，既是一个技术问题也是一个法律问题。技术上，目前通用 的数字身份认证技术有许多，例如，基于口令的认证方式，OTP（One Time Password） 和银行 U 盾的认证技术等。世界各国基于各自的电子签名相关法律推广可靠的数字身份认证，大多采用基于 PKI 的数字签名技术。\neID的技术原理eID以智能安全芯片为载体，芯片内部拥有独立的处理器、安全存储单元和密码运算协处理器，只能运行专用安全芯片操作系统，其内建芯片安全机制可以抵抗各种物理和逻辑攻击，确保芯片内部数据无法被非法读取、篡改或使用。\n用户开通eID时，智能安全芯片内部会采用非对称密钥算法(国密SM2)生成一组公私钥对，这组公私钥对可用于电子签名，基本原理是：用户可以使用自己的eID私钥对信息进行电子签名后发送给其他人，其他人可以使用用户的eID公钥对签名信息进行验签。\n用户使用eID私钥签名的功能受eID签名密码保护，在开通eID时需要用户本人设置eID签名密码，连续输错多次eID签名密码eID功能将被锁定，确保了使用eID完成的电子签名不可抵赖。\n用户使用eID通过网络向应用方自证身份时，应用方会向连接“公民网络身份识别系统”的服务机构发出请求，以核实用户网络身份的真实性和有效性。一旦用户网络身份通过验证，应用方得到用户在当前应用上的网络身份应用标识。由于用户在不同的线上应用上所使用的网络身份应用标识编码不同，可以避免用户在不同线上应用中的行为数据被汇聚、分析和追踪。\neID数字身份模型![eID数字身份模型](eID 数字身份体系&#x2F;image-20210622194227808.png)\n申领与开通公安部第三研究所与智能手机厂家开展合作，将eID载入手机安全芯片。目前已支持直接申领eID的智能手机品牌及型号如下：\n![image-20210622193305876](eID 数字身份体系&#x2F;image-20210622193305876.png)\neID数字身份体系特点\n● 以个人信息保护为首要原则，将公民身份信息转化成去身份化和碎片化的个人标记，防止公民个人信息泄露和大数据精准画像，保障公民的生活安宁、财产和人身安全；\n\n● 在全面研究分析我国主流身份认证技术及应用的基础上，通过引入eID数字身份构建全国统一数字身份体系，包容各种数字身份认证技术并实现认证互通；\n\n● 分别对eID数字身份颁发过程和eID数字身份认证过程的安全可靠程度分级，构建eID数字身份体系框架；\n\n● 旨在推动我国数据的开放和流通，促进我国数字政府、数字经济发展，建设网络强国。\n\n\n参考资料https://eid.cn/knoweid/whatiseid.html\nhttps://eid.cn/eid2018.pdf\n","slug":"eID 数字身份体系","date":"2022-02-26T06:11:14.000Z","categories_index":"","tags_index":"","author_index":"明说网络"},{"id":"4b2fe54e4f901417624daae5e3a327d1","title":"中国研究人员发现微软0Day漏洞","content":"中国研究人员发现微软0Day漏洞摘要中国的安全研究人员披露了一个关键的Windows零日漏洞，使得域控制器服务器尤其面临风险。专家建议尽可能严格限制对这些服务器的网络访问，或是直接关闭这些服务。\n\n正文中国的安全研究人员披露了一个关键的Windows零日漏洞，该漏洞被命名为PrintNightmare。\n总部设在深圳的桑福(Sangfor )科技公司披露技术细节和概念验证（PoC）漏洞，该漏洞目前在Windows中没有补丁，允许远程代码执行。\n此前，微软在6月修补了一个高严重度的特权提升漏洞CVE-2021-1675。但在上周一，在分析了它可以实现远程代码执行（RCE）后，它把这个漏洞重新归类为关键性的。\nPrint Spooler的零日漏洞，使得域控制器服务器尤其面临风险。威胁者可以利用这些的远程控制访问企业网络。即使强加认证，但鉴于暗网中RDP和其他系统的证书被攻破的数量，这对攻击者来说是很容易突破。\n措施Sophos首席研究科学家Paul Ducklin说，微软可能会在7月的补丁星期二之前发布一个带外更新来解决这个问题。\n那些有让Print Spooler运行的服务器用户，建议尽可能严格限制对这些服务器的网络访问。另外，如果有的服务器没有必要运行Print Spooler，即使有了补丁，也应该关闭它。\n","slug":"中国研究人员发现微软0Day漏洞","date":"2022-02-26T06:10:58.000Z","categories_index":"","tags_index":"","author_index":"明说网络"},{"id":"a20e5ca542927b4b3c8e25987b6f8977","title":"这款木马的传播者已被逮捕","content":"这款木马的传播者已被逮捕\n摘要哥伦比亚的执法部门已经逮捕了一名涉嫌传播Gozi木马的网络犯罪分子。\n正文这位罗马尼亚国民Mihai Ionut Paunescu，也被称为 “病毒”，是2007年至2012年期间，影响超过一百万台个人电脑的三名主要嫌疑人之一。\n他在波哥大埃尔多拉多国际机场被捕，并因被指控经营防弹托管服务(bulletproof hosting service)而面临被引渡到美国。Paunescu在纽约南区法院面临计算机入侵和金融欺诈的指控。此前，Paunescu于2012年在其本国被捕，但他之前能够避免引渡。\n防弹托管防弹托管(bulletproof hosting service)通常被网络犯罪分子用于后台基础设施，用于传播垃圾邮件、恶意软件、漏洞工具包，以及托管被盗数据。这些在线服务对其客户的违法活动视而不见。威胁者以每周500美元的价格出租恶意软件及其基础设施，这被认为是当今恶意软件即服务（MaaS）犯罪设置的早期形式。\nGozi木马2007年首次发现的Gozi银行木马是通过附在电子邮件中的武器化PDF文件传播的。下载后，该恶意软件会潜伏在后台，收集银行账户信息和账户细节，然后发送到木马的命令和控制（C2）服务器，供操作者用于访问账户和进行欺诈性交易。\nGozi的源代码在2010年被泄露，许多变种被创造出来，目前仍在使用中。\n2016年，Gozi的俄罗斯创造者Nikita “76” Kuzmin在承认各种计算机入侵和欺诈指控后在美国法院被判刑。\n据估计，该恶意软件给受害者造成的损失高达数千万美元。\n","slug":"这款木马的传播者已被逮捕","date":"2022-02-26T06:10:40.000Z","categories_index":"","tags_index":"","author_index":"明说网络"},{"id":"71b0522dffa47f8d26766573034d2309","title":"又一勒索软件组织回来了！逮捕只针对洗钱部分，核心成员没被逮捕","content":"又一勒索软件组织回来了！逮捕只针对洗钱部分，核心成员没被逮捕\nCl0p是最著名的勒索软件集团之一，在联邦机构最近的一次打击行动中被发现再次活跃。虽然它的行动保持了大约一周的安静，但它最近在其数据泄露网站上列出了新的受害者。\n发生了什么？Cl0p团伙回来了，因为它在其勒索软件数据泄露网站上泄露了两名新受害者的数据。运营商公布了一批新的机密数据，声称是从新的受害者那里偷来的。这些数据属于两个受害者，一个是农场设备零售商，而另一个是建筑师的办公室。\n快速回归Cl0p勒索软件组自2019年3月以来一直很活跃，当时它用CryptoMix勒索软件针对一家企业。据乌克兰警方称，Clop的总损失估计为5亿美元。上周，一次执法行动导致Cl0p勒索软件团伙成员被捕。执法部门已经关闭了恶意软件的基础设施，并阻断了对非法获得的加密货币进行洗钱的渠道。然而，最新的活动表明，联邦机构的逮捕只针对行动中的洗钱部分，核心成员没有被逮捕。预计逮捕对Cl0p行动的整体影响不大，因为在一周内，新的活动又开始萌芽。\n结论最近在乌克兰的逮捕行动对Cl0p行动的打击并不大，因为核心组成员没有受到影响。可以说，阻止勒索软件的斗争远未结束，预计将进一步继续。因此，企业应该积极主动地采取足够的安全措施，以保持保护。\n参考资料https://cyware.com/news/recent-arrests-probably-werent-able-to-stop-cl0p-ransomware-0fdec2cd\n","slug":"又一勒索软件组织回来了！逮捕只针对洗钱部分，核心成员没被逮捕","date":"2022-02-26T06:10:33.000Z","categories_index":"","tags_index":"","author_index":"明说网络"},{"id":"d6638bef18ca696173c563dbad65b818","title":"由SolarWinds提供的Serv-U管理的文件传输服务中的一个RCE漏洞被人利用","content":"由SolarWinds提供的Serv-U管理的文件传输服务中的一个RCE漏洞被人利用\n由SolarWinds提供的Serv-U管理的文件传输服务中的一个RCE漏洞被人利用。SolarWinds公司早些时候通过供应链攻击成为目标，该公司已发布补丁以修复该漏洞。\n发生了什么？微软已经提出了有限的和目标客户受到被追踪为CVE-2021-35211的零日漏洞影响的证据。然而，SolarWinds 並沒有准确估计有多少客戶可能受到该漏洞的影响。该漏洞影响到Serv-U 15.2.3 HF1及之前的版本。成功利用该漏洞后，攻击者可在受感染的系统上运行任意代码。此外，该漏洞使攻击者能够安装恶意程序并查看、更改或删除重要数据。然而，该漏洞在Serv-U 15.2.3版热修复（HF）2中得到解决。该公司要求管理员注意任何通过SSH从IP地址98[.]176[.]196[.]89和68[.]235[.]178[.]32或208[.]113[.]35[.]58通过TCP 443的潜在可疑连接。SolarWinds在其最近的公告中表示，发现的零日与SUNBURST供应链攻击没有任何关系。此外，它不影响任何其他产品，特别是Orion平台。\n最近的供应链攻击有几起事件被曝光，其中有供应链攻击。最近，卡西亚在一次供应链攻击中被REvil勒索软件盯上，目标是其虚拟系统管理员解决方案中的关键安全漏洞（CVE-2021-30116&#x2F;19&#x2F;20）。6月，对航空业的一次巨大的供应链攻击与中国国家行为者APT41有关。5月，加拿大邮政遭遇数据泄露事件，影响到其95万名客户。该安全漏洞是由于基于恶意软件的供应链攻击而发生的。\n结论最近的供应链攻击突出了现代网络和供应链的脆弱性。攻击者越来越多地发现广泛使用的软件链中的漏洞，以部署恶意软件。因此，建议企业遵循安全机构提供的建议，并定期审查其网络安全态势。\n","slug":"由SolarWinds提供的Serv-U管理的文件传输服务中的一个RCE漏洞被人利用","date":"2022-02-26T06:10:26.000Z","categories_index":"","tags_index":"","author_index":"明说网络"},{"id":"bd11a9ddfa9e55bfa813b9924f7874fa","title":"应用商店下载量达580万的应用程序竟然盗取用户的密码","content":"应用商店下载量达580万的应用程序竟然盗取用户的密码\n摘要研究人员发现了谷歌商店(Google Play)中9个盗取凭证的应用程序，这些应用能够偷取用户的Facebook登录凭证。\n\n盗取用户名密码据安全公司Dr.Web发表的一篇文章称，为了赢得用户的信任并降低他们的警惕性，这些应用程序提供了功能齐全的照片编辑和取景、运动和训练、星座和删除安卓设备上的垃圾文件等服务。所有被确认的应用程序都为用户提供了一个选项，即通过登录他们的Facebook账户来禁用应用内广告。选择该选项的用户看到一个真正的Facebook登录框，其中包含输入用户名和密码的字段。\n\n来自同一木马变体研究人员确定了藏在应用程序中的五个恶意软件变体。其中三个是原生安卓应用，其余两个使用谷歌的Flutter框架，该框架是为跨平台兼容而设计。Dr.Web说，它把所有这些都归类为同一个木马，因为它们使用相同的配置文件格式和相同的JavaScript代码来窃取用户数据。\n受影响的应用清单大部分的下载是针对一个名为PIP Photo的应用程序，其访问量超过580万次。覆盖面次之的应用程序是Processing Photo，下载量超过50万次。其余的应用是\nRubbish Cleaner，垃圾清理器：超过10万次下载Inwell Fitness，英威健身：超过10万次下载Horoscope Daily，星座日报：超过100,000次下载App Lock Keep：超过50,000次下载Lockit Master：超过5,000次下载Horoscope Pi，星座Pi：超过5,000次下载 1,000次下载App Lock Manager：10次下载\n处理在Google Play搜索显示，所有的应用程序都已从Play中删除。谷歌发言人表示，该公司还禁止所有9个应用程序的开发者进入商店，这意味着他们将不被允许提交新的应用程序。谷歌这样做是对的，但这对开发者来说无所谓，因为他们可以用不同的名字注册一个新的开发者账户，只需一次性支付25美元即可。\n任何下载了上述应用程序的人都应该彻底检查他们的设备和他们的Facebook账户，看看是否有任何被破坏的迹象。从已知的安全公司下载一个免费的安卓防病毒应用程序，并扫描其他恶意应用程序。\n","slug":"应用商店下载量达580万的应用程序竟然盗取用户的密码","date":"2022-02-26T06:10:19.000Z","categories_index":"","tags_index":"","author_index":"明说网络"},{"id":"2e3663cbc12ae7c7b7f0a29f5c884443","title":"每天感染1000台设备，这款恶意软件专为挖矿而来、超过9000个XMR币被开采出来","content":"每天感染1000台设备，这款恶意软件专为挖矿而来、超过9000个XMR币被开采出来\n摘要一款在攻击过程中利用Windows安全模式的加密货币挖矿恶意软件被发现，每天约有1,000台设备被攻击，全球已有超过22.2万台机器被感染。该恶意软件至少从2018年6月就开始蔓延，最新版本于2020年11月发布。研究人员表示，只要人们还下载破解的软件，恶意软件就会一直蔓延下去\n名为Crackonosh的恶意软件一款在攻击过程中滥用Windows安全模式的加密货币挖矿恶意软件被发现，它通过盗版和破解软件传播，并经常出现在torrents, forums, 和 “warez “网站中。\nAvast的研究人员将这种恶意软件称为Crackonosh。研究人员指出，该恶意软件至少从2018年6月就开始蔓延，第一个受害者是运行伪装成合法软件的破解版软件而被攻击。\n每天约有1,000台设备被攻击，全球已有超过22.2万台机器被感染。\n主要利用系统算力和资源来挖掘门罗币（XMR）（一种加密货币）。Crackonosh总共产生了至少200万美元的门罗币，有超过9000个XMR币被开采出来。\n\n\n到目前为止，该恶意软件的30个变种已被确认，最新版本于2020年11月发布。\n感染流程启动感染链从一个安装程序和一个修改Windows注册表的脚本开始，允许主要的恶意软件可执行文件在安全模式下运行。被感染的系统被设置为在下次启动时以安全模式启动。\n抗杀软研究人员说，当Windows系统处于安全模式时，杀毒软件就不会工作。这使得恶意的Serviceinstaller.exe能够轻易地禁用和删除Windows Defender。它还使用WQL查询所有安装的杀毒软件 SELECT * FROM AntiVirusProduct.\nCrackonosh将检查防病毒程序的存在，如Avast、Kaspersky、McAfee的扫描器、Norton和Bitdefender - 并尝试禁用或删除它们。然后擦除日志系统文件以掩盖其痕迹。\n阻止Windows更新Crackonosh还将试图停止Windows更新，并将用一个假的绿色勾选托盘图标取代Windows安全。\n挖矿最后，部署了一个XMRig，这是一个加密货币矿工，利用系统算力和资源来挖掘门罗币（XMR）（一种加密货币）。\nAvast研究人员表示，只要人们还下载破解的软件，恶意软件就会一直蔓延下去\n","slug":"一款名为Crackonosh的加密货币恶意软件被发现","date":"2022-02-26T06:10:07.000Z","categories_index":"","tags_index":"","author_index":"明说网络"},{"id":"a32c0979716a4d829588ac887f009c53","title":"一个用Go编程语言编写的新木马被用于勒索攻击","content":"一个用Go编程语言编写的新木马被用于勒索攻击\n被称为ChaChi的恶意软件，在2020年上半年被发现，远程访问木马（RAT）的原始变体已经与针对法国地方政府当局的网络攻击有关，但现在，一个更为复杂的变体已经出现。现有的最新样本已与针对美国大型学校和教育机构发起的攻击有关。\nGo语言开发的恶意软件ChaChi是用GoLang（Go）编写的，这种编程语言由于其通用性和跨平台代码编译的便利性，现在被攻击者使用。 \n\n据Intezer称，在过去几年中，基于Go的恶意软件样本大约增加了2000%。据黑莓威胁研究和情报部门的研究团队称，由于这是一个新现象，许多核心分析工具仍在开发。这可能使分析Go的恶意软件更具挑战性。\n\n命名ChaChi之所以这样命名，是因为Chashell和Chisel是恶意软件在攻击过程中使用的两个现成的工具。Chashell是一个通过DNS提供的反向外壳，而Chisel是一个端口转发系统。\n能力与ChaChi的第一个变种相比，该恶意软件具有较差的混淆和低级别的攻击能力，现在能够执行典型的RAT活动，包括创建后门和数据渗透，以及通过Windows本地安全授权子系统服务（LSASS）进行证书转储、网络枚举、DNS隧道、SOCKS代理功能、服务创建和跨网络横向移动。该恶意软件使用一个可开源的GoLang工具gobfuscate进行混淆。\n黑客组织PYSA黑莓研究人员认为，该木马是PYSA&#x2F;Mespinoza的作品，该威胁组织以发起勒索软件活动和使用扩展名而闻名。当受害者的文件被加密时，PYSA代表 “保护你的系统Amigo”。\n通常PYSA专注于 “猎杀大型游戏”( “big game hunting” )，并挑选那些能够支付大笔赎金的目标。这些攻击是有针对性的，由人类操作员控制，而不是自动化执行。\n","slug":"新的GoLang木马","date":"2022-02-26T06:09:59.000Z","categories_index":"","tags_index":"","author_index":"明说网络"},{"id":"5ab502d7701b74130eab80a57797f73b","title":"小心! 网络犯罪分子正在对加密货币用户进行攻击","content":"小心! 网络犯罪分子正在对加密货币用户进行攻击\n随着网络犯罪分子不断发展他们的攻击技术和恶意软件，非法的加密挖矿活动正在飞速增长。上升的主要原因之一是快速增长的加密货币汇率。\n此外，新数字货币的引入和加密货币的正式交易，使人们对加密货币滥用和加密货币诈骗带来的新威胁产生了怀疑。根据Akamai最近的报告，在2020年3月至2021年5月期间，虚假的加密货币交易所钓鱼网址激增超过500%。这些钓鱼网址最终使攻击者能够秘密地盗取钱财。然而，攻击者正在将重点从URL转移到恶意应用程序，以欺骗用户并赚取更多利润。\nBitScam和CloudScam最近，Lookout威胁实验室的安全研究人员发现了170多个安卓应用，这些应用欺骗对加密货币感兴趣的人。根据研究人员的发现，这些应用程序被归类为BitScam和CloudScam。这些应用程序承诺帮助受害者进行云采矿，而不需要额外的商品或服务。这两个版本都提供了加密采矿的订阅和服务，用户可以通过Google Play的应用内付费系统来启用。BitScam与CloudScam的唯一区别是在支付选项中增加了比特币和以太坊。然而，受害者并不知道，攻击者正在眼皮下利用他们。据悉，攻击者至少骗取了35万美元的加密货币资金。\n更深层次 的攻击联邦调查局发布了一份关于正在进行的针对加密货币所有者和第三方平台的攻击的警告。该警告显示，攻击者正在使用几种战术来控制目标的加密货币交易所账户并窃取数字货币。冒充支付平台和利用SIM卡交换攻击是攻击者用来发动攻击的一些战术。\n结论随着加密货币变得更加重要，看到它在越来越多的受到攻击将不足为奇，例如DDoS勒索和勒索软件攻击。鉴于与加密货币相关的攻击对消费者和企业的潜在影响，强烈建议建立主动的安全监测和控制。\n","slug":"小心! 网络犯罪分子正在对加密货币用户进行攻击","date":"2022-02-26T06:09:50.000Z","categories_index":"","tags_index":"","author_index":"明说网络"},{"id":"a76717815deaa16da77e88cac6185cdf","title":"“太空网络”支持宇航员在太空视频聊天","content":"“太空网络”支持宇航员在太空视频聊天\n2021 年 6 月 23 日上午，在距离地球约 400 公里的中国天河空间站核心舱上，三名宇航员在北京控制中心接到了地面的第一个视频通话，高分辨率图像给许多人留下了深刻的印象。语音，以及几乎零延迟的地面空间连接。是什么让连接如此顺畅？答案是卫星互联网。\n由中国航天科技集团公司和中国航天科技集团公司共同主办的《中国航天报》称，由三颗国产天链卫星组成的“太空网络”保证了地面和太空之间的畅通无阻。\n什么是卫星互联网？\n卫星互联网是从绕地球运行的卫星传输的无线互联网。它与有线或 DSL 等陆基互联网服务有很大不同，后者通过电线传输数据。卫星互联网允许您通过从固定在您财产上的碟形天线(俗称卫星锅)向太空中的地球同步卫星发送无线信号来访问万维网。信号会回传到您的互联网提供商的网络接入点，并传输回您的天线、调制解调器，最后是您的计算机，从而完全无线地将您连接到互联网。就像使用任何其他类型的互联网连接一样，您可以使用卫星互联网进行从下载和流媒体到上传和游戏的所有常规在线活动。\n卫星互联网是如何工作的？卫星互联网通过三个独立的卫星天线将用户连接到网络；一个悬浮在太空中，一个驻留在互联网服务提供商的中心，一个连接到你的设备。\n卫星互联网的工作原理是使用无线电波与绕地球运行的卫星进行通信。数据通过通信网络发送和检索，该网络从您的设备开始，通过您的调制解调器和卫星天线，到达太空中的卫星，然后返回地球，到达称为网络运营中心 (NOC) 的地面站。然后，数据通过此网络传回太空，然后返回地球上的卫星天线，以在您的设备上传输数据。\n\n\n如上所述，卫星互联网信号传输到固定在赤道上方的卫星，然后传输到您的家庭天线，并根据需要来回传输。\n卫星互联网组成\n卫星互联网使用五部分中继系统：\n\n联网设备\n调制解调器&#x2F;路由器\n卫星天线\n太空中的卫星\n网络运营中心 (NOC)\n\n联网设备互联网就绪设备是可以通过适当的服务访问互联网的任何设备。这包括您的计算机、平板电脑、智能手机、智能电视、游戏机和任何其他支持互联网的设备。\n当您在其中一台设备上使用互联网时，它会通过您的调制解调器&#x2F;路由器发送和接收数据。\n调制解调器&#x2F;路由器转换数据： 调制解调器转换数据，使得数据可以在您的互联网就绪设备和卫星天线之间移动。您可以使用线缆将某些设备（如计算机、智能电视或游戏机）直接连接到调制解调器。\n卫星天线中继的下一步是您的家庭卫星天线。这个碟形天线必须精确定位(由微波的波长决定)，以便向在轨供应商的卫星发射信号并接收回信息。\n\n太空中的卫星在距离地球表面大约22,000 英里的地方，传统卫星互联网服务中使用的卫星悬停在赤道上空。它们随行星旋转，因此信号中继保持一致。这称为地球静止轨道。这允许在您的碟形天线和提供商集线器或 NOC 之间进行双向数据通信。\n卫星网关和网络运营中心 (NOC)每当您从 Internet 请求信息时，无论您是单击链接、流式传输节目还是打开 Facebook，来自该请求的数据都会通过上述中继上传。然后卫星将请求发送给 NOC。\nNOC 使用比您家里的卫星天线大得多的卫星天线接收您的请求。然后 NOC接入互联网骨干网，收集您请求的信息，并通过中继将其发送回给您。\n所有这些过程，包括将信息发送到太空 22,000 英里并返回两次，都在几分之一秒内发生。\n由于信息必须传播到很远的地方，您可能会注意到比 DSL 或有线互联网更多的延迟（也称为延迟）\n卫星互联网的优缺点是什么？\n虽然卫星互联网在某些地方通常是最好的（有时是唯一的）选择，但它也带来了一些独特的挑战，如果您选择 DSL 或有线互联网连接，您可能不会面临这些挑战。虽然卫星互联网仍在不断发展和改进，但该技术仍然缺乏有线和光纤互联网的速度和带宽能力。但是，使用卫星连接来装饰您的家有许多宝贵的好处。让我们仔细看看卫星互联网的优缺点。\n卫星互联网的优势\n速度：您可以期待比标准拨号连接更快的速度，并且可以与卫星互联网服务提供商的 DSL 互联网相媲美。\n覆盖范围：因为卫星是完全无线的，这种互联网类型几乎在全国任何地方都可用，甚至在船上和房车上。无论您的住所多么偏远，您都可以依靠卫星连接访问网络。\n可靠性：与有线或 DSL 等流行的地面互联网类型相比，使用卫星连接遇到网络中断的可能性要小得多。\n\n卫星互联网的缺点\n天气：您所在位置的天气会影响卫星互联网设置的信号路径。无论是大雨、大雪还是强风，信号都可能因您无法控制的气候因素而中断。\nVPN 不兼容：不幸的是，虚拟专用网络 (VPN) 与卫星互联网不兼容。VPN 需要高带宽容量才能进行功能上传和下载，并且需要低延迟——这是卫星连接无法保留的两个基本要素。\n高延迟：延迟问题（互联网连接中的延迟）通常是由于信号必须传播以促进网络连接的距离而导致的，这导致宽带应用程序（即视频游戏、视频聊天、4K 流媒体等）变慢和滞后。\n\n卫星互联网有多快？卫星互联网速度范围为 12 到 100 Mbps，这对于发送电子邮件、浏览和在线学习等常见在线活动来说已经足够了。\n卫星互联网与卫星电视有何不同\n卫星电视只向一个方向播放，从卫星向家庭播放视频信号，没有“返航”。互联网信号必须双向传输，而且由于进出的信号不像视频那样广播，因此移动所有数据需要更多的带宽。\n美国星链计划（商业化）星链，是美国太空探索技术公司的一个项目，太空探索技术公司计划在2019年至2024年间在太空搭建由约1.2万颗卫星组成的“星链”网络提供互联网服务，其中1584颗将部署在地球上空550千米处的近地轨道，并从2020年开始工作。\n但据有关文件显示，该公司还准备再增加3万颗，使卫星总量达到约4.2万颗。 \n2021年3月11日，美国太空探索技术公司(SpaceX)的“猎鹰9”号运载火箭，携带一组60颗“星链”互联网卫星在美佛罗里达州发射升空  。5月5日，SpaceX发射了60颗Starlink卫星  。5月15日，SpaceX使用八手火箭发射52颗星链卫星\n中国天链卫星“天链”顾名思义是“天上的信息链”，主要为飞船、空间实验室、空间站等载人航天器提供数据中继和测控服务，为中低轨道遥感、测绘、气象等卫星提供数据中继和测控服务，为航天器发射提供测控支持。****天链卫星将能够有效支撑我国空间站通讯任务，我们将能够随时跟天上航天员进行视频通话。\n天链卫星是中国在地球静止轨道上飞行的数据跟踪和中继通信卫星。它们的主要任务是在全球范围内为在轨航天器提供数据中继、测控和传输服务。\n\n该站网络下行速率为1.2G，相当于地面5G通信速度，时间延迟仅在一秒内。\n2008年至2012年，中国先后发射了天链一号01号、天链一号02号和天链一号03号三颗数据跟踪中继卫星。卫星产业链使中国成为世界上第二个拥有覆盖中低轨卫星和载人航天器的中继卫星系统的国家。\n随后几年，天链一号04于2016年进入轨道，天链二号01号于2019年作为国家第二代卫星中的第一颗发射升空。\n所有卫星将合作改进数据跟踪和传输。天链II-01首次用于载人任务，可以监控多个目标，并提供更好的性能和更高的效率。\n天链I-05、天链II-02和天链II-03正在研制中。 \n参考文献https://ishare.ifeng.com/c/s/7lZgd4iQHrF\n3名航天员实现天地通话，在空间站还能刷视频？这事没那么简单！,https://www.163.com/dy/article/GD6DRFQE05328YVR.html\nHow does China’s satellite chain help taikonauts make home calls?，https://news.cgtn.com/news/2021-06-23/How-does-China-s-satellite-chain-help-taikonauts-make-home-calls--11k73Oj6YKI/index.html\nhttps://www.bandwidthplace.com/satellite-internet/\n5G-equivalanet network speeds in space empower taikonaut’s unimpeded video call with ground，https://www.globaltimes.cn/page/202106/1226871.shtml\n","slug":"卫星互联网","date":"2022-02-26T06:09:41.000Z","categories_index":"","tags_index":"","author_index":"明说网络"},{"id":"6717a3b69a576994d81d5d69e98f7e0e","title":"微软披露路由器NETGEAR固件漏洞","content":"微软披露路由器NETGEAR固件漏洞\n摘要网络安全研究人员披露了影响NETGEAR DGN2200v1系列路由器的关键安全漏洞，这些漏洞可以使认证绕过设备并访问存储的凭证。\n正文这三个HTTPd认证安全漏洞的CVSS评分为7.1-9.4，影响运行v1.0.0.60之前的固件版本的路由器，作为协调漏洞披露过程的一部分，该公司在2020年12月打了补丁。\n微软365防御者研究团队的Jonathan Bar Or说，越来越多的固件攻击和通过VPN设备和其他面向互联网的系统进行的勒索软件攻击，这是在操作系统层之外和之下发起攻击的例子。由于这些类型的攻击已经变得很普遍，用户甚至必须确保运行其硬件的单一用途软件（如路由器）的安全。\n这些漏洞允许使用认证旁路访问路由器管理页面，使攻击者能够达到对路由器的完全控制，还可以通过加密的侧信道攻击获得保存的路由器凭证，甚至通过利用配置备份&#x2F;恢复功能恢复存储在路由器内存中的用户名和密码。\n研究人员还发现，凭证是用一个恒定的密钥进行加密的，随后可以用它来检索明文密码和用户名。\n建议建议所有NETGEAR DGN2200v1用户下载并更新到最新固件，以避免任何潜在的攻击。\n","slug":"微软披露NETGEAR固件漏洞","date":"2022-02-26T06:09:33.000Z","categories_index":"","tags_index":"","author_index":"明说网络"},{"id":"b29948e82d06501e27c7b4895c4d927b","title":"威胁情报","content":"威胁情报网络威胁情报（CTI）仍然可以说是一个新生的、快速发展的领域。但是，情报工作本身在历史上和商业上是一门非常成熟的学科。\n情报情报的定义有很多，下面列举其中的两个以资说明。\n“情报是为回答关于是谁、是什么、在哪里、什么时候、如何和为什么等具体问题而接收或收集的信息…… “英国国家犯罪署（NCA）。“情报是对我们周围世界的了解和预知，是决策和行动的前奏…… “美国中央情报局（CIA）。\n然而，无论组织的确切作用和意见的多样性如何，很明显，好的定义一致认为情报的产品是可以帮助决策过程的理解。\n数据、信息、情报的区别数据、信息和情报这些术语经常被错误地互换使用。\n\n数据指的是简单的事实，这些事实往往是大量存在的。在网络安全的背景下，IP地址或日志是典型的数据例子。就其本身而言，原始数据的效用有限。当这些数据被整理以提供有用的输出时，信息就产生了–例如，一系列整理的日志显示了可疑活动的高峰。情报来自于对这些信息的处理和分析，可以用来为决策提供信息。例如，整理后的日志数据与之前关于类似活动的事件报告相联系，这也允许制定一个策略来减轻事件的影响。\n以情报为主导的安全网络安全越来越被认为是一种优先的商业风险；产品的种类和成熟度越来越高；以及其他因素，如监管要求，都在推动对网络威胁情报服务的需求。\n网络威胁情报（Cyber Threat Intelligence, CTI）用于更好地理解、预测和适应恶意行为者的行为，无论他们是犯罪集团、活动甚至是国家。网络威胁情报可以有几种形式，包括关于恶意软件的详细信息、妥协指标（IoC）或恶意行为者用来窃取信息的具体技术。通过掌握这些知识，我们可以更新我们对威胁的防御措施。有许多可能的网络威胁情报来源，如历史事件、开放源码情报（OSINT）、任何威胁反馈、ISACs（信息共享和分析中心）甚至政府威胁的共享计划[^ 5] 。\n什么是威胁情报 \n图片来源：https://m.k.sohu.com/d/528075690\n定义^1行业内关于“威胁情报”的讨论很多，但是这个词的定义却各有各的说法，但大多数文献中援引的是Gartner在2014年发表的《安全威胁情报服务市场指南》（Market Guide for Security Threat Intelligence Service）中提出的定义，所以我们也来看看Gartner的威胁情报定义，即：\n\n\n\n\n\n\n\n\n\n“威胁情报是关于IT或信息资产所面临的现有或潜在威胁的循证知识，包括情境、机制、指标、推论与可行建议，这些知识可为威胁响应提供决策依据。”\n如果认为Gartner为威胁情报所下的定义比较让人费解，我们可以参考Jon Friedman和Mark Bouchard在2015年发表的《网络威胁情报权威指南》（Definitive Guide to Cyber Threat Intelligence）中对威胁情报所下的定义：\n\n\n\n\n\n\n\n\n\n“对敌方的情报，及其动机、企图和方法进行收集、分析和传播，帮助各个层面的安全和业务成员保护企业关键资产。”\n网络威胁分析是识别和评估潜在恶意威胁和文件特性的过程。适当的网络威胁分析是优秀的、可行的网络威胁情报的基础优先级。\n传统上，安全防御严格关注于在周边授予或拒绝访问。然而，不断演变的威胁使用一系列的隐身能力来避免被发现。网络威胁分析提供了对文件整个生命周期的持续评估。如果对文件的分析确定它在任何时候都是一个威胁，那么这个威胁将被记录下来并被全面封锁。\n内容^1针对攻击方的威胁情报应该包含的要点包括了：\n\n\n\n\n\n\n\n\n\n- 攻击者身份：威胁情报需要能够帮助企业将攻击&#x2F;恶意活动最终溯源至相应组织（网络犯罪团体、黑客、政府&#x2F;国家机构等）\n- 攻击的原因：了解地方动机，以及他们会在攻击中投入多少精力（APT或仅是投机型攻击），及其针对性有多强等\n- 攻击目的：了解攻击者的目的，对于企业和组织基于资产重要性调整响应优先级也是有意义的\n- 具体是怎么做的：也就是所谓的TTP（Tatics策略、Technique技术和Procedure程序），这其中也包含了攻击者所用的工具、基础设施等\n- 攻击者的位置：结合地方所在国家，以及其地缘政治状况，自然能够帮助企业和组织更好地理解地方情况\n- 如何组织情报：包括IOC一类的技术指标（比如IP地址、哈希值等）提供的信息可用来更准确地检测和标记恶意行为\n- 如何缓解攻击：企业可用以保护自身的信息\n来源\nDifferent sources of intelligence Cyber threat intelligence suppliers should draw from a wide range of different sources to enable them to provide a rounded and holistic understanding of the threats that organisations face. This is particularly true because the range of cyber adversaries most organisations face are disparate, and relevant information sources about those threat actors need to match that challenge. Commonly used sources by cyber threat intelligence providers include:Indicators of compromise (IoCs) associated with malicious activity. Hashes of malware samples, IP addresses and domain names can all be used to update firewalls and detection systems, as well as contribute to an understanding of threat actors’ TTPs. IOCs are their own are more akin to data than processed intelligence, though are still included within the spectrum of cyber threat intelligence.Client-derived data, such as that regarding its infrastructure or extracted from a security information and event management (SIEM) tool or other logs can be correlated with other sources, or for pro-active measures such as threat hunting.Deep web, such as information from member-only hacking forums frequented by cybercriminals. These sources can provide valuable insight into the tools and services advertised and requested by cybercriminals, as well as identifying which exploits are being discussed to enable patch prioritisation.Dark web will include marketplaces and shops that are hosted on anonymity-focused networks such as Tor or I2P which criminals use to purchase goods and services. This will enable consumers to identify if their data – ranging from login credentials to valuable intellectual property – is available or being advertised for sale, or if infrastructure they use may be targeted.\nMessaging platforms are also used by threat actors to communicate, and can provide intelligence. Rather than relying on semi-public forums, some cybercriminals prefer more direct means of engaging each other to sell their goods and services.Similarly, cyber activists will often use a combination of outmoded Internet Relay Chat (IRC) channels and other messaging platforms to discuss impending operations, which can provide useful insight into potential tactics and targets.Social media can be used by a variety of actors, typically those with low capabilities. Activists may signal their intent to pursue specific targets in advance via social media pages.Criminals may use popular networks as an alternative means of attracting potential customers, particularly in jurisdictions where law enforcement capability is limited and they do not run the risk of arrest. Social media collection may also include coverage of inadvertent data leaks by employees or potential threats from malicious insiders.Human intelligence can be derived from engagement with individuals via several the above sources. However,threat intelligence providers should only engage in such activity under a strict and defined framework and in pursuit of specific intelligence requirements and in a legal and ethical way. Providers also need to ensure that collection efforts from social media and human sources are compliant with legislation such as the General Data Protection Regulation (GDPR).Malware analysis, which allows analysts to extract information such as indicators of compromise from a sample,which can in turn be used to search the client estate. Analysis also allows providers to better understand the latest tactics, techniques and procedures that are being used by threat actors, with a view to informing network defenders how to better respond.Geopolitical developments can be used to derive an understanding of the intent of nation-state actors. For example, understanding how a state’s strategic development objectives coincide with those of the client organisation, or how potential nation-state rivalries will affect the prospect of disruptive attacks in a region in which it operates, will help it understand the threats it faces.Code repositories, such as exploit databases, can provide insight into which exploits are available for adoption by threat actors, and which vulnerabilities should be prioritised for patching as a result.\nPaste sites can reveal a wide array of information, including leaked credentials, indications of impending activist operations, code snippets, and evidence of breaches. The example in the image to the right shows a message from a campaign by the Anonymous collective, which goes on to list a series of targets for DDoS attacks.Information sharing platforms can also provide additional context and insight to threat actors’ current activity. These are typically divided along national or sectoral boundaries, and include:• The UK National Cyber Security Centre’s (NCSC) Cyber Security Information Sharing Partnership (CiSP)• The Financial Services Information Sharing and Analysis Center (FS-ISAC)• AlienVault’s Open Threat Exchange (OTX), a crowd-sourced platform used by participants in 140 countries• US-CERT’s (United States Computer Emergency Response Team) Automated Indicator Sharing (AIS) platform• The Asia Pacific (APAC) Intelligence Centre based in Singapore Data from government partners is also available to some sectors and for specific projects. Rather than using these sources in isolation, effective cyber threat intelligence suppliers need to corroborate and fuse together material from different sources to better understand the nature of the threat that their clients face. Ideally, intelligence reports should be multi-sourced – potentially fusing information from at least two source types.\n对威胁情报的需求正在增长尽管许多安全专业人员仍然对威胁情报的准确性和质量不满意，但它作为网络防御资源的使用正在增长。根据2019年SANS网络威胁情报（CTI）调查，生产或消费CTI的组织比例从60％上升到72％^ 2。\n网络威胁情报是网络威胁分析的最终结果。这是一组可用于采取行动和防御威胁的调查结果。网络威胁情报不是手动授权或拒绝访问，追踪恶意威胁，并记录以前识别的犯罪分子，而是允许自动的通用行动。例如，如果一个文件被识别为恶意文件，它可以立即在全球所有网络中被阻止。\n通过投资网络威胁情报，企业可以访问大量的威胁数据库，这些数据库可以极大地提高他们解决方案的效率。归根结底，安全解决方案的强度取决于为其提供动力的威胁情报。\n威胁情报与其他比较曾经有一段时间威胁情报与妥协指标（IoC）同义，但现在通常被认为还包括战术，技术和程序（TTP），威胁行为，攻击面意识和战略评估。然后，此安全数据和信息用于创建组织的数字风险图并进行管理。\n妥协的指标(Indicators of Compromise)妥协指标（IOC）被定义为“法医数据，包括在系统日志条目或文件中找到的数据，用于识别系统或网络上的潜在恶意活动。”\n通过监控IOC，组织可以检测攻击并迅速采取行动，防止此类攻击发生，或通过阻止早期攻击来限制损害。\n有一些用例，允许查询法医文物，如 -\n\n通过MD5查找特定文件\n搜索实际存储在内存中的特定实体\n特定条目或条目集，存储在Windows注册表中\n\n其他比较作为最纯粹的威胁情报落地应用形态，威胁情报网关（Threat Intelligence Gateway， TIG）与我们熟知的其他安全产品形态，在使用场景上到底有什么区别？^3\n威胁情报网关与其他安全产品如何协同联动？[^6 ]\n为什么会有威胁情报传统防火墙并不能解决\n威胁情报可以干啥a rising number of organizations across the world are showing a growing willingness to leverage the open exchange of cyber threat intelligence (CTI) for obtaining a full picture of the fast-evolving cyber threat situation and protecting themselves against cyber-attacks. H\nThe exchange and collaborative generation of CTI by the means of sharing platforms has proven to be an important aspect of practical application[^4].\nThis collective information can guide decision making in cyber defense applications utilized by security operation centers (SoCs). \n\n\n\n\n现在都怎么干的威胁历史数据数据，数据和更多的数据。可行的威胁情报需要过多的威胁历史数据。网络威胁分析和机器学习能力产生了有价值的见解。随着数据集的增大，两者都得到了改善。如果网络威胁情报只有一个10的威胁数据集，它只可能主动阻止10个威胁。随着数据集的增加，威胁情报将获得关于可能威胁您的网络的恶意威胁的更多信息。此外，随着数据量的增加，基于 ml 的分析算法也在不断改进。\n自动检测&#x2F;阻塞拥有精确的网络威胁分析、机器学习能力和广泛的威胁历史数据是很棒的，但是网络威胁情报系统需要能够利用这些工具来自动化行动。它不仅需要对检测到的威胁做出反应，还需要采取积极主动的行动，永久性地阻止威胁。\n网络威胁的数量正呈指数级增长，并且在可预见的未来可能还会继续增长。手动操作根本无法跟上步伐。因此，当务之急是企业部署一个整合式威胁管理解决方案，能够识别亚洲的威胁，并立即阻止这种威胁在南美洲。\n网络威胁分析网络威胁情报必须有精心设计的网络威胁分析。企业处理的数据比以往任何时候都多，所以黑客的财务刺激比以往任何时候都大，黑客变得更加老练和协调。这带来了新的挑战，需要更多创新的网络威胁分析技术。\n机器学习能力威胁防御的两个最令人担忧的趋势是威胁数量的增加和常见威胁的快速演变。为了跟上这些趋势，网络威胁情报需要在威胁情况下利用机器学习。\n机器学习可以识别大量数据集中的模式和预测威胁，所有这些都是以机器速度进行的。安全行动小组可以利用这一点，迅速发现需要深入人员分析的高级威胁并对其进行优先排序。为了开发有效的机器学习能力，组织应该考虑以下要求^ 7:\n\n数据集的多样性和精确性。不同行业、规模和地理位置的组织所遇到的恶意软件的均衡表示，并通过不同的攻击载体传递，对于全面覆盖是必不可少的\n多层处理。机器学习管道的每个处理阶段都应该提高检测的准确性和逼真度，以确保安全小组处理优先级高、上下文丰富的检测\n端点和网络数据的相关性。通过对多层次处理结果的相关性分析，系统可以加强检测能力，提高检测精度和自学习能力，更快地检测出更多的威胁\n深入的领域专业知识和持续培训的分类器。在构建一个不容易操作的健壮的机器学习系统时，领域知识和持续学习是这个难题的关键部分\n\n威胁情报系统\\平台威胁情报平台集中收集来自大量数据源和格式的威胁数据。威胁情报数据量巨大，因此威胁情报平台的设计目的是将数据聚合到一个地方，最重要的是，以可理解和可用的格式显示数据。\n\n与其他IT系统发展相比，网络威胁情报系统发展还处于初级阶段，但这个领域的主导厂商以国外的为主，包括FireEye、Cyveilance、IBM X-Force Exchange\nLogRhythm、VeriSign、AlienVault(AlienVault开放威胁交换(OTX)是全球权威的开放威胁信息共享和分析网络。OTX提供了一个由威胁研究人员和安全专业人员组成的全球社区，有来自140个国家的5万多名参与者，每天贡献400多万个威胁指标。)；国内的360威胁情报中心和微步在线Threatbook从2015年起步，离一个完整、成熟的威胁情报平台还有一段路要走。\nThreatMiner，https://www.threatminer.org/\nHarpoon：OSINT威胁情报工具\n开源软件来实现情报威胁系统开源工具非OSSIM莫属，该系统中OTX所提供的功能可满足威胁情报系统的要求。。OSSIM具体部署与使用大家可参考《开源安全运维平台-OSSIM最佳实践》一书。\n\n威胁情报网关Threat Intelligence Gateway落地产品\n\n威胁情报的挑战网络威胁情报交换（cyber threat intelligence (CTI) exchange）, modeling CTI is challenging due to the explicit and implicit relationships among CTI and the heterogeneity of cyber-threat infrastructure nodes involved in CTI. Owing to the limited labels of cyber threat infrastructure nodes involved in CTI, automatically identifying the threat type of infrastructure nodes for early warning is also challenging.\n参考资料https://zhuanlan.zhihu.com/p/69594768\nFootNotes[^4]: Measuring and visualizing cyber threat intelligence quality\n[^ 5]: Cybersecurity threat intelligence knowledge exchange based on blockchain\n\n\n\n\n\n\n\n\n\n(i)基于 Ethereum 区块链的网络威胁情报(CTI)共享激励模型。新的进化经济激励措施是通过 Ether 和一种新的威胁情报数字资产 CTI 令牌(ERC20兼容)的组合提供的。(ii)新增强版的同侪。动态风险管理(DRM)过程中网络威胁情报共享系统的语义方法。为此，我们支持在所有级别(操作、战术和战略级别)以 SWRL 和 STIXTMv2的 OWL 增强版的形式交换 CTI 语义 web 算法(不包括交换 IoC 数据)。(三)模拟模型优化和实验，以证明其好处和限制，特别是在成本方面。\n","slug":"威胁情报","date":"2022-02-26T06:09:26.000Z","categories_index":"","tags_index":"","author_index":"明说网络"},{"id":"86e3d52489f4a02b9f508fb0aa61d56f","title":"网络武器的兴起及其对网络空间的相对影响(译)","content":"网络武器的兴起及其对网络空间的相对影响(译)曾几何时，我们生活在这样一个世界，在这个世界中，战争由勇敢的士兵面对面的进行交锋，而今天战争的形态发生了深刻的变化。网络空间的发展，使得战争的形态发生了巨大的变化，处于各种目的的网络攻击行为在网络空间中此起彼伏。网络武器，作为一种新的武器形态，在网络空间作战中展现了惊人的力量，flame、Stuxnet、Duqu等网络武器更是将网络作战带到了一个更高的高度。随着网络空间的快速发展，网络武器还将会对网络空间带来什么样的变化呢？\n网络战争美国政府安全专家理查德·A·克拉克在其著作《网络战争》（2010 年 5 月）中将“网络战争”定义为“一个民族国家为了造成损害或中断而侵入另一个国家的计算机或网络的行为”。\n专家提供的定义强调了将网络战争行为与其他网络行动区分开来的两个基本因素：民族国家的承诺和可能以造成破坏或监视敌人网络为目的的进攻意图。\n网络空间被主要政府认为是空间、陆地、海洋和空中等第五个战争领域，因此，主要国家正在大规模投资开发新的网络能力来保护它。\n这是美国政府在网络空间的立场。美国国防部副部长威廉·J·林恩 (William J. Lynn) 表示“作为一个理论问题，五角大楼已正式承认网络空间是战争中的一个新领域。. . [这] 已变得与陆地、海洋、空中和太空一样对军事行动至关重要。”美国政府的这一声明公开承认了与网络空间驻军相关的重要性以及用于开发新一代技术和工具以在这个充满陷阱的额外领域保护国家的努力的重要性。\n军事部门加强了对通过网络空间传播的威胁可能对公民安全和政府稳定构成严重威胁的认识。然而，这种考虑也适用于其他场景，包括将网络空间中的军事行动用于进攻目的，与常规攻击相比，这些行动具有许多优势。\n与导致常规攻击的方式不同，网络攻击可以在和平时期以无声的方式进行，这导致必须考虑需要高度警惕的极其阴险的威胁。\n世界各地的政府都关注其数字基础设施的安全级别，并正在推动建立熟练的网络单位以支持新领域的行动。奥巴马总统在 2009 年的立场宣布美国的数字基础设施是“国家战略资产”，仅仅一年后，政府创建了一个新的美国网络司令部 (USCYBERCOM)，其主要任务是保卫美国军事网络并全面实施频谱军事网络空间行动，以便在所有领域采取行动。\n美国并不是唯一一个投资网络战能力的国家。中国和俄罗斯的运作方式完全相同，朝鲜和伊朗等其他国家也在提高他们在网络空间的存在感。\n官方消息称，至少有140个国家正在开发网络武器，网络战行动的数量急剧增加。据估计，由于外国的进攻，全世界每天都会对政府系统进行数千次攻击……其中有多少会成功？\n每场战争都使用适当的武器进行，在网络战中，我们假设使用网络武器、工具和软件来冒犯网络空间中的敌人具有相关重要性。但是，尽管“网络武器”一词的使用率很高，但今天还没有正式的法律定义。例如，让我们考虑国防部的军事和相关术语词典，由 550 页的国防部定义组成，不包含网络武器的具体定义，国际法也没有以详尽的方式定义什么是用于网络武器。\n缺乏全球公认的网络武器定义的影响是严重的。缺乏定义使得无法区分网络武器及其正确使用方式，无法评估攻击者的法律和政治责任以及网络战背景下造成的真实威胁水平。\n为什么使用网络武器是政府行之有效的选择？成功的主要因素是这些类型技术的效率和降低的成本。Stuxnet 病毒是网络武器的真正第一个例子，它证明了类似工具可能对关键基础设施产生的影响。\n网络武器的使用有点吵。这些代理因被利用的漏洞的性质而被压制，这为攻击者提供了真正的优势。事实上，攻击者可以及时采取行动，避免泄露攻击的真正来源。在覆盖范围内运作的可能性代表着逃避国际社会的制裁，因为该罪行的匿名性质允许规避国际社会对军事进攻的批准。\n从军事角度来看，网络武器的准备阶段很容易被窥探。让我们考虑一下，通过情报研究更容易发现常规武器（例如导弹、无人机、战斗机）的构造。网络武器的发展很难确定。\n网络武器的使用是对常规军事打击的补充。有可能：\n\n支持摧毁敌方防御基础设施的进攻行动。\n通过评估代理感染敌方系统的能力来探索敌方的技术能力。\n\n这些优势使网络战对那些尽管军事开支资金减少但能够在新领域与最重要国家竞争的“小”国非常有吸引力。\n网络武器的目标是什么？频谱非常广泛。一般来说，网络武器可以打击一个国家的每一个关键基础设施和重要系统，例如：\n\n工业控制系统尤其值得关注的是那些监督工厂运行的组件，用于能源生产和提供各种服务，例如供水设施。\n电力供应网。\n领土控制系统。\n医院和政府控制。\n通信网络。\n防御系统。\n军用空中交通和空域控制系统。\n金融和银行系统。\n\n在最近的一次采访中，卡巴斯基安全公司首席执行官尤金卡巴斯基就网络空间主题宣布：\n“网络领域就像现实世界一样，在现实世界中，我们有条约和监督机构来监督遵守情况。它适用于核武器、生物和化学武器，那么为什么不使用网络呢？”\n该声明是详尽无遗的，并强调了成立国际网络监管委员会的必要性，但首先有必要为网络武器的概念提供一个有效的定义，并且从法律的角度这样做是必要的，以确定其目的使用，使用它的上下文，冒犯的主体&#x2F;客体，当然还有攻击的目标。\n网络战专家意大利律师 Stefano Mele 在他的出版物“网络武器——法律和战略方面”中提供了一个非常有趣的网络武器定义：\n“网络武器是[一种]器具、设备或任何计算机指令集，旨在非法破坏具有关键基础设施性质的计算机或电信系统、其中包含的或与之相关的信息、数据或程序，或促进其运营的全部或部分中断或变更。”\n安全专家常用的网络武器的另一个有效定义如下：\n“旨在通过网络空间冒犯他人的设备、设备或任何计算机指令集。”\n这两个定义都是完整且具有法律效力的，并且证明网络武器是由国家资助的，并且有能力对关键基础设施造成巨大破坏并造成人员伤亡。\n一旦我们定义了一种网络武器，就可以将其专门设计用于冒犯的情况与那些最初为其他功能设计的工具的不当使用可能用于攻击目的的情况区分开来。\n也可以将其与网络战行动中使用的其他工具（例如网络间谍工具）区分开来。\n最具争议的问题之一是是否有可能将“网络武器”定义为一种网络间谍工具，它呈现出一种模块化结构，使恶意软件的使用成为可能。根据定义，由于没有对人造成伤害或没有对关键基础设施造成严重破坏的责任，因此它不被视为网络武器，但许多专家提出了合理的反对意见。这些工具包还可用于通过简单地加载为示波器开发的适当模块来对特定目标进行攻击。\n举个例子，让我们考虑一下恶意软件 Duqu：它有一个国家支持的起源，但孤立的实例主要揭示了网络间谍的目的。尽管如此，安全公司已经认识到它是使用创建 Stuxnet 的相同平台开发的，即“Tilded 平台”。该恶意软件创建了已知具有模块化结构的创新平台，可以指定其行为。这意味着配备适当组件的 Duqu 也可用于进攻目的。\n案例研究——震网为了了解网络武器的效率，可以分析与其传播相关的数字。该主题的一个有趣来源是赛门铁克档案“Symantec W32.Stuxnet Dossier Version 1.4（2011 年 2 月）”，其中提供了有关感染的有用统计数据和信息。Stuxnet 被许多专家认为是历史上第一个网络武器。事实上，国家支持的攻击第一次袭击了外国的关键基础设施，其具体意图是摧毁它们。\nStuxnet 是一种于 2009 年检测到的恶意软件，它感染了部署在伊朗关键基础设施（如天然气管道或发电厂）中的特定工业控制系统。Stuxnet 的最终目标是通过重新编程可编程逻辑控制器 (PLC) 来破坏这些设施，使其按照攻击者的意图运行，很可能超出其指定的边界。该代理已开发用于摧毁伊朗的核计划。\nStuxnet 是一个大型、复杂的恶意软件，具有许多不同的组件和功能，包括零日漏洞利用、Windows rootkit、有史以来第一个 PLC rootkit、防病毒规避技术、复杂的进程注入和挂钩代码、网络感染例程、点对点对等更新，以及命令和控制界面。与感染地理分布相关的图表为我们提供了两条重要信息：\n\n各种传播技术的使用意味着 Stuxnet 已经超出了最初的目标。正如直方图所示，伊朗并不是恶意软件唯一针对的国家。进一步的感染被认为是由于使用混杂的初始传播方法造成的无意“附带损害”。作者是否能够控制代理的传播？根据许多军方官员的声明，不可能确定恶意软件只会感染目标。\n该代理主要攻击伊朗，伊朗报告了大约 60% 的受感染主机。该国的感染集中度可能表明这是最初的目标，也是最初感染的地方。\n下图报告了受感染 PC 对不同 Stuxnet 变体的影响。事实上，各种实例因传播方法和组成它们的模块而异。代理及时变异；这是网络武器的另一个特点，可以改变其行为，改变其中一个模块的结构。只需加载新的有效负载，就可以使恶意软件更具攻击性。\n\n对网络空间的影响恶意代理在网络空间中的传播可能会导致人员伤亡和关键基础设施的破坏。这些作为网络武器设计的直接影响是相当可观的，但也存在网络武器不受控制的扩散造成的“附带损害”。\n网络攻击可能造成与常规攻击类似的损害，所显示的案例表明对公民的严重影响。网络攻击和相关损害的主要目标是：\n\n电子国防系统——通过入侵一个国家的防御系统，可以控制其常规武器，例如有可能向该国或其他国家发射导弹。\n医院——*医院和医疗中心的电子系统可能会受到网络攻击，从而影响其功能，造成严重后果。\n***关键设施的控制系统——***网络攻击可能会破坏化工厂或核电站的管理系统，改变生产流程并使大片区域面临破坏的风险。\n供水——水是人们必不可少的资源。供应中断可能会导致大片地区缺水。控制系统的更改可能使其能够正常工作，但容易受到连续攻击（例如水中毒）的影响。\n全自动交通管制系统和民用和军用空中交通管制——所有这些系统都不需要售票员或司机，也不需要对交通的指挥和控制提供合理的帮助。考虑攻击对列车控制系统或空中交通管理系统的影响。*\n***电网管理系统***——这个目标代表了一个国家的重要系统。攻击这些系统可能会中断电力供应，从而导致计算机、火车、医院和电信服务等国家的活动完全受阻。这些代表了网络攻击的特权目标，它们的防御是每个网络战略的基础。\n***银行系统和金融平台——***金融系统是一个国家的重要资产，它们的封锁可能会导致严重的问题，例如对目标经济活动的封锁。尽管无法直接造成人员伤亡，但网络攻击可能会导致一个国家的金融崩溃。情况令人担忧；如果我们认为当今的全球金融严格依赖于每个国家的经济，那么针对某个国家的网络攻击可能会对整个经济体系造成严重且不可预测的后果。\n\n但网络武器的存在是一个危险因素，可能对网络空间产生严重影响。大量使用恶意应用程序和网络战技术的后果通常对公民的安全和隐私产生重大影响。\n最近几个月，世界各地都检测到不同的无声恶意软件窃取敏感数据并破坏目标系统。Stuxnet、Flame 和 Gauss 等代理肯定是国家资助项目的结果，这些项目不仅感染了真正的最终目标，而且威胁着地球特定地区许多国家的基础设施。\n使用网络武器最危险的影响之一是难以预测其扩散。网络空间没有界限，美国政府前空军情报、监视和侦察主管约翰·P·卡夏诺将军证实了这一概念，并宣称：\n*“我们永远无法 100% 保证网络攻击会按计划进行。”*\n这意味着网络武器也可能以不可预测的方式打击不被视为目标的其他系统或网络。在极端情况下，它也可能以某种“回旋镖效应”攻击作者所在的国家。\n网络空间中网络武器的存在可能会开启恶意个人对其源代码进行逆向工程的可能性。外国政府、网络恐怖分子、黑客行动主义者和网络犯罪分子可以检测、隔离和分析代理，设计和传播难以缓解的新网络威胁。\n这些代理很难被发现，并且可以静默运行多年，例如 Gauss 恶意软件对受害者和网络空间中的其他实体造成严重损害。\n在网络攻击的情况下，使国土安全面临严重风险的另一个因素是公民缺乏对网络战和攻击时正确响应程序的认识。大多数人完全忽略了“网络战”这个词以及网络作战对现实世界的影响。当然，在正在进行的《网络战争》中，知识的泄露是一个相当大的因素，可以让对手晋级。\n该司令部战略倡议小组负责人托马斯·戈斯上校宣布：\n*“虽然技术在网络空间领域发挥着重要作用，但在 21 世纪的网络战场上获胜的并不是技术 [……] 一次又一次，在行动和演习中，人们会有所作为。”*\n该声明是对该主题适当教育水平的战略重要性的完美综合。《2012 年陆军战略规划指南》呼吁该军种继续招募、教育、培训和留住网络专业人员，为下一代网络专业人员建立管道。\n黑客的新角色和新0day市场的诞生“网络武器”的一个基本要素是利用未知漏洞。它被称为零日漏洞，是影响其效率并使目标成为特定应用程序或基础设施成为可能的一个因素。政府和私营企业突然发现在最常见的应用程序中发现错误的重要性，为新的贵重商品创造了新的市场。\n美国国家安全局局长亚历山大在 Defcon 2012\n新漏洞的利用是黑客工作的特权，这引起了极大的兴趣。在被攻陷主应用的产品制造商和政府眼中，黑客的形象完全改变了。过去，黑客主要是为了自己的乐趣和衡量他们的技能的需要，远离政府事务。今天，他们是市场中的关键人物，其特点是任何涉及漏洞信息的交易都是“即时”的。\n一旦发现漏洞，就必须高度重视，避免泄露，并且必须提交给在新市场中作为经纪人运营并能够对发现保密的适当组织，“短路”一个需求和报价。\n市场及其参与者笼罩在神秘之中。许多专家认为，它需要监管，但问题远非简单。引入对此类漏洞利用谈判的控制可能会劫持销售到难以监控的领域，从而产生危险的后果。\n政府对这些黑客攻击非常感兴趣，因为他们可以将它们用于网络行动，例如网络间谍活动或利用目标基础设施。中国、俄罗斯和美国，以及朝鲜和伊朗，都公开表现出对黑客世界的浓厚兴趣。在许多情况下，政府已经宣布招募最优秀的黑客来创建新的网络单位，例如，在上一届 Defcon 黑客大会期间，美国国家安全局局长基思·B·亚历山大将军曾要求黑客帮助保护网络空间。\n网络战争时代——没有规则的冲突全球安全社区都意识到我们正处于网络时代，如今网络冲突是在没有规则和法规的情况下进行的。每个国家都能够投资于网络能力的发展，并且由于技术的性质，每个国家都可以在不被发现的情况下使用它，并及时造成严重破坏。\n像往常一样，普通民众受无声网络攻击的影响最大。使人们面临网络攻击风险的主要因素是：\n\n计算机和通信网络的大规模扩散。\n关键系统之间的非托管和易受攻击的互连。\n技术格局的快速演变。\n网络空间缺乏边界。\n\n从监管的角度来看，必须提供以下回应：\n\n在网络空间使用武力是什么意思？\n\n什么时候应该将网络攻击视为武装攻击？\n\n对网络攻击的相应响应的方法和级别是什么？\n\n哪种规则应该适用于这种响应？\n\n我们如何确定参与网络运营的行为者的法律责任？\n\n我们如何平衡国家安全需要和保护公民个人自由的迫切需要？\n\n\n网络空间是一个相当重要的新领域，必须以与常规战争中的核或化学武器库完全相同的方式来管理网络武器的使用。尤金·卡巴斯基 (Eugene Kaspersky) 在论点上表示：\n“*网络领域就像现实世界一样，在现实世界中，我们有条约和监督机构来监督遵守情况。它适用于核武器、生物和化学武器，那么为什么不使用网络呢？”*\n网络武器的开发相对简单，近年来观察到的网络武器竞赛需要全球公认的监管。一个代表世界所有国家的单一机构将定义一套网络规则，并设法规范网络空间中网络武器和其他网络工具的使用，这是可取的。\n目标非常具有挑战性。政府有明显的优势，在这个关键时刻不想限制他们在网络战争中的能力。他们意识到，许多对手正在秘密地继续在如此关键的领域进行投资，并且害怕可能让他们措手不及的网络攻势。在此前提下，很难预测这场争论将如何演变，与此同时，一些安全专家正试图将监管机构正式化以适用于网络战。\n关于该主题的最有趣的作品之一是“****适用于网络战的国际法塔林手册”，这是一份由独立的“国际专家组”撰写的文件，旨在研究现有的国际法规范如何适用于这种“新”形式的战争。\n该研究试图阐明国家在网络空间界定管辖权、控制和法律责任的立场。\n*«一国对其造成的网络操作承担国际法律责任，并构成违反国际义务。»*\n专家们根据第一版草案的摘要为网络攻击和网络武器等概念提供了法律定义：\n*«网络攻击是网络操作，无论是进攻性还是防御性，合理预期会造成人员伤亡或物体损坏或破坏»*\n该手册提供了有关目标的详细说明，强调了在攻击大坝、堤坝和核电站时的注意义务，以及保护儿童、记者、医疗和宗教人员的需要。在网络战中，背景是引入网络武器概念的基础，专家们已经接近它，定义网络战的**“手段”是网络武器及其相关的网络系统。**\n网络武器是网络战争手段，其设计、使用或预期用途能够造成人员伤亡。网络战的**“方法”是进行敌对行动的网络战术、技术和程序。**\n可以提供一个手段和方法示例，参考使用僵尸网络进行的 DDoS 攻击。在这种情况下，僵尸网络是网络战的“手段”，而 DDoS 攻击是“方法”。\n该手册还阐述了两个基本概念：\n\n禁止使用本质上会造成多余（在没有军事优势的情况下加剧痛苦）或不必要的痛苦的网络战手段或方法。\n每次使用网络战争的手段或方法时，都需要进行法律审查，以确定其技术描述、目标性质、对目标的影响、精确度和预期影响范围。\n\n您是否相信在当前场景中这些概念可以控制应用程序？\n很明显，在我们面临严重且无法弥补的后果之前，引入监管平台是可取的。\n关于网络能力发展的经济数据在文章的第一部分，已经介绍了当前的网络战场景。大多数国家都在投资以提高其网络能力以用于防御目的，但不仅如此。不仅仅是收集有关正在进行的项目的信息，而且在许多情况下，政府会提供有关这些项目的详细信息，以公开展示他们对网络战的承诺。\nX计划无疑是最著名的项目之一，由美国政府推动并由 DARPA 部门开发，用于开发新的网络战技术。该项目并不是美国唯一正在进行的项目。空军研究实验室 (AFRL) 根据一项名为敏捷网络技术 (ACT) 的计划向六家公司提供了价值高达 3 亿美元的合同，以一种形式按需提供网络武器。合同称为不确定交货-不确定数量 (IDIQ)。由于此事缺乏透明度，没有关于俄罗斯和中国等其他活跃国家进行的类似项目的具体信息，但可以肯定的是，这些政府正在大量投资于网络战技术。俄罗斯武装部队在“信息环境：原则、规则、和建立信任措施”宣布了国家对网络武器发展和监管的需求。还要考虑英国和伊朗所付出的努力。\n最近，其他国家已确认参与新领域。这个斯堪的纳维亚国家的国防部旨在创建恶意软件和漏洞利用来发起针对威胁的在线反击。北约（北大西洋公约组织）也将在 2012 年投资约 5800 万美元以提升其防御能力。\n\n**图 – 各国的网络战费用**\n上表提出了一些与网络战最活跃国家的总费用相关的数字。注意中国和美国已经为开发新的网络技术分配了大量投资。\n分析网络战的全球费用，可以了解每个国家展示战略重要性以采用适当的网络战略，当然还有开发网络武器库的经济影响。\n网络武器的成本是多少？很难确定开发网络武器的确切成本，这取决于许多变量，但著名黑客查理米勒提供了有效且现实的估计，他在演示文稿中提出了一些有趣的数字«如何建立一个攻击美国的网络军队»\n黑客假设了一个总持续时间为几年的项目，涉及大约 592 名专业人员，涵盖从漏洞分析师到经理的各种工作角色。该研究表明，网络武器的开发需要高技能的专业人员，这些专业人员的结构具有严格的等级制度，并且在设备方面具有无限的可用性。模拟显示年薪为 4,590 万美元（平均年薪为 77,534 美元）和设备费用为 300 万美元。\n\n**图 – 网络武器开发团队的组成**\n尽管数量看起来很昂贵，但如果与常规武器的成本相比，它确实便宜。出于这个原因，许多政府正在建立致力于开发新的进攻性技术的网络单位。\n结论文章提出了与网络武器概念相关的几个方面，提供了不同视角下的实际网络战场景图，强调了定义全球公认的监管平台的重要性。尽管许多政府普遍关注，但一些专家认为网络武器的概念过于“抽象”，因此低估了其危害性。这些怀疑论者提出的主要论点是：\n\n迄今为止，政府网络武器影响了数千人。\n所有众所周知的网络武器的“火力”都远低于人们通常认为的。\n网络武器的主要好处可能是与常规军事进攻结合使用；这意味着网络冲突的“武器化”工具的收益回报可能比通常假设的要可疑得多。\n\n综合他们对网络武器论点的观点，“网络战争实际上不是战争，因为没有人命损失，网络武器也是如此”，但分析最近发生的事件和不断发现的恶意状态——赞助恶意软件，可以了解网络空间中的重大活动以及对民用和军用基础设施的相关不可预测的影响。\n各国政府对网络战具有高度敏感性，并意识到通过网络空间进行的网络威胁可能以与常规攻击完全相同的方式影响国土安全。\n未来的特点是加强国家支持的网络行动。网络空间将发生深刻变化，网络安全的概念也将随之发生变化。政府、企业和私营企业必须为迎接挑战做好准备，而不是低估风险。\n让我们以一段从黑客世界电影《重启》预告片中提取的声明结束，该声明综合了保护一个国家数字资产的重要性：\n“我们都连接在一个庞大的全球网络上，谁控制了网络，谁就控制了世界。”\n原文The Rise of Cyber Weapons and Relative Impact on Cyberspace，https://resources.infosecinstitute.com/topic/the-rise-of-cyber-weapons-and-relative-impact-on-cyberspace/\n","slug":"网络武器的兴起及其对网络空间的相对影响","date":"2022-02-26T06:09:15.000Z","categories_index":"","tags_index":"","author_index":"明说网络"},{"id":"dc0051b501afb2dd8fd8557ef31cf4dc","title":"世界第一位被美国无人机袭击故意杀害的黑客--Junaid Hussain","content":"世界第一位被美国无人机袭击故意杀害的黑客–Junaid Hussain\n在 2015 年 8 月，一名21 岁的男子，成为第一位被美国无人机杀害的黑客。他就是世界头号通缉恐怖分子Junaid Hussain，他的名字排在伊斯兰国(ISIS)头目阿布·贝克尔·巴格达迪之后的第三位。为什么一名黑客可以成为头号恐怖分子？\n成长Junaid Hussain(朱奈德侯赛因)约 1994 年出生，第二代英国国民。他的家人来自克什米尔的巴基斯坦一侧。小时候，他的家人住在伯明翰的Small Heath区，该地区南亚人人口稠密，犯罪率在伯明翰排名第二。后来，侯赛因的家人搬到了Kings Heath，这个地区经常被吹捧为英国非常理想的居住地。Hussain 的世界观就是在这个绿树成荫的街区形成的。\n侯赛因的父亲是英国巴基斯坦社区中一位受人尊敬的成员，他在伯明翰地区经营私人出租车。他的父亲被认为是“可敬的”、“勤奋的”和“健谈的”。但相比之下，朱奈德侯赛因却似乎是一个沉默寡言的人。 \n被称为 TriCk 的黑客Hussain 涉足黑客世界源于对报复的需要。在 11 岁时，有人入侵他在线玩的游戏的帐户。“我想报复，所以我开始在谷歌上搜索如何破解。” 侯赛因无法报仇雪恨，但这让他走上了一条培养黑客技能的道路。“我加入了一些在线黑客论坛，阅读教程，从基本的社会工程开始，然后逐步提升……我潜伏在论坛中，结识人，提出问题，从那时起我转向了黑客网站、服务器等。”\n随着他的黑客技能的发展，他对政治激进主义的品味也越来越高。侯赛因对政治的热情使他走出家门，走上街头。早在2009年，他就在街头抗议穆斯林人民的困境。“我上网、看书、看纪录片等。我对政治越来越感兴趣，我开始深入研究共济会、光明会、300 人委员会等。它使我很生气，它改变了我的生活方式和我看待世界的方式。然后我开始使用黑客作为我的媒介，通过破坏网站来提高对世界各地问题的认识，并‘欺负’腐败组织并通过泄密等方式使他们难堪，这就是我进入黑客行动主义的方式。\n在他的“黑客行动主义”中，侯赛因创建了自己的网站 p0ison.org（当时 15 岁）和TeMp0isoN组织 。\nTeaMp0isoN 是一个由八名黑客行动主义者组成的组织，由主要来自英国的青少年和年轻人组成。Hussain 的黑客行动主义笔名是 TriCk。\n他宣称的一些黑客行为包括：\n\n1 . 成功入侵了托尼·布莱尔 (Tony Blair) 的一位助手、当时的英国首相的 Gmail 帐户。他开始在网上泄露通讯录，暴露了总理许多朋友的联系方式\n2 . 他还声称入侵了马克扎克伯格本人的 Facebook 帐户\n3 . 2012 年，他参与了名为“自由巴勒斯坦行动”的在线黑客活动。数以百计的以色列信用卡被黑客入侵，以向巴勒斯坦事业输送资金。\n4 . 他和他在 Poison 的朋友们曾经对英国反恐司令部的热线发起了基于电话的拒绝服务 (DOS) 攻击。他们甚至公开了与 M16 官员的谈话，威胁要向 FBI 报告他们。\n**5.**他们还声称入侵了北约和英国国防部的网站，发布了一些员工的地址信息。\n\n从网络黑客到恐怖主义之路朱奈德侯赛因在入侵托尼布莱尔私人助理的电子邮件后被捕。他被审判并被判处六个月监禁。据接近他的人说，他的被捕让他非常痛苦。他开始喃喃自语，黑客如何不足以改变世界。\n到他被释放时，朱奈德侯赛因已经与他的大多数朋友断绝了联系，包括Poison黑客组织中的朋友。他停止在他的推特账户上发帖。 2014 年侯赛因出现了，通过同一个 Twitter 帐户，但该帐户改头换面：他的名字从 Trick 改为 Abu-Hussain al-Britani，头像换为了一名手持AK47的蒙面男子，并且2014 年 8 月，他的新伊斯兰妻子在 Twitter 上发布了一条消息，称他们现在在 ISIS 控制的领土上。他现在是一个已知恐怖组织的圣战者。\n\n伊斯兰国网络教练化名为 Abu-Hussain al-Britani，Junaid Hussain 利用他的技能为恐怖分子谋取利益。他成为了被称为CyberCaliphate的恐怖分子黑客团队中最重要的成员之一。\n他开始训练其他人破解银行账户和信用卡。当以色列信用卡成为目标时，他在“自由巴勒斯坦”活动中使用的方法相同；他利用自己作为说唱歌手的经验为 ISIS 制作了高质量的音频宣传剪辑。凭借他在 Anonymous 的经验，他能够组织和领导 ISIS 行动的数字部门，并产生毁灭性的影响；\n在 Junaid Hussain 加入 ISIS 之前，没有人听说过 CyberCaliphate。然而，他在入侵美国中央司令部的推特账户后，让该组织臭名昭著。\n\n\n\n\n\n\n\n\n\n2015年1月，ISIS的支持者入侵了美国中央司令部的YouTube和Twitter账户，并从其移动设备上窃取了大量内部文件并泄露到了网上。\n他们控制了美国中央司令部Twitter账户长达1个小时，并把美国中央司令部的logo换成了“I love you isis”。\n美国中央司令部是美国军队的强有力部门，其职责范围主要在伊拉克和叙利亚地区。\n在他的领导下，CyberCaliphate 入侵了多个在线社交帐户、网站，并在多个网站上组织了 DDoS 攻击。\n在 2015 年 4 月，他在几个小时内控制了一家法国电视网络，利用控制的时间向法国人民广播 ISIS 宣传。\n正是侯赛因的招募工作、宣传传播、袭击策划和煽动以及敏感信息泄露，使他成为联军的高价值目标。据媒体报道，他的名字在五角大楼的目标名单上排名第三。\n朱奈德侯赛因被杀当局知道他在叙利亚，但如何获取他的确切位置呢？当局对他使用了一个他过去对他的许多受害者使用过的把戏。\n他点击了卧底安全人员发给他的链接。\n首先，英国的证券工作人员能够在他喜欢使用的安全消息应用程序 Surespot 上获取他的用户名。卧底特工给他发了一个好友请求，他接受了。\n后来，卧底特工借口他想给朱奈德看一些重要的东西，给他发了一个“带毒”链接。“带毒”链接指向一个未知网站，这种攻击方式就是我们所知的水坑攻击。\n对于朱奈德侯赛因来说，他当时选择的设备是他的手机。他在点击链接时无意中下载了病毒。当他稍后用电话拨打电话时，工作人员能够轻松地确定他的位置。\n最终，当局将坐标输入无人机并击毙朱奈德侯赛因。\n总结作为第一个被无人机击杀的黑客，Junaid Hussain的黑客恐怖主义行为可见一斑。网络空间拉近了人和人之间的距离，同时也拉近和网络恐怖主义的距离。当黑客遇见恐怖主义，具有更强的威力和蛊惑效果。\n值得注意的是，黑客组织CyberCaliphate 同时也隶属于恐怖组织，带有极强的政治色彩，该种黑客行为不单单是黑客行为，是网络空间中不可忽视的一股恐怖势力。\n因此，在享受网络空间带来便利的同时，也要时刻警惕网络恐怖主义蔓延。\n参考资料[1]The British Hacker Who Became the Islamic State’s Chief Terror Cybercoach: A Profile of Junaid Hussain，https://ctc.usma.edu/british-hacker-became-islamic-states-chief-terror-cybercoach-profile-junaid-hussain/\n[2]Junaid Hussain: Hacker Killed By A U.S Drone，https://awajis.com/junaid-hussain-hacker/\n","slug":"世界第一位被美国无人机袭击故意杀害的黑客--Junaid Hussain","date":"2022-02-26T06:09:07.000Z","categories_index":"","tags_index":"","author_index":"明说网络"},{"id":"d8143ff4b66aff71820f1e996fdac034","title":"时尚零售商Guess披露数据泄露","content":"时尚零售商Guess披露数据泄露\n摘要美国时尚品牌和零售商Guess在2月份的勒索软件攻击导致数据被盗后，又遭遇了数据泄露。\n正文该公司已经开始通知受影响的客户有关数据泄露的情况，其中指出，经调查发现，在2021年2月2日至2021年2月23日期间，Guess的系统遭到未经授权的访问。\n经过调查，在2021年5月26日，确定与某些人有关的个人信息可能已经被未经授权的行为者使用。在这次攻击中暴露的信息包括社会安全号码、驾驶执照号码、护照号码和&#x2F;或金融账户号码等细节。尽管受影响的个人数量没有透露，但提交给缅因州总检察长办公室的信息显示，在2月份的攻击中，有超过1300人的数据被暴露或被访问。\nGuess没有提供任何关于勒索软件攻击背后的威胁者的细节，但DarkSide勒索软件团伙已将Guess列入其数据泄露网站。\n该团伙声称，在试图加密他们的系统之前，已经从这家时尚零售商的网络中窃取了价值超过200GB的文件。\n措施和进展这家时尚零售商在2021年6月3日完成了对存储在被入侵系统中的文件的全面审查后，确定了所有受影响个人的地址。\nGuess已经通过Experian向所有受影响的个人提供免费的身份盗窃保护服务和一年的免费信用监测。\nGuess公司已经实施了额外的措施来提高其安全协议，并正在与执法部门合作，作为正在进行的事件调查的一部分。\n截至2021年5月，Guess在美洲、欧洲和亚洲直接经营1041家零售店，其分销商和合作伙伴在全球另有539家店。属于Guess零售网络的商店目前在大约100个国家经营。\n","slug":"时尚零售商Guess披露数据泄露","date":"2022-02-26T06:08:55.000Z","categories_index":"","tags_index":"","author_index":"明说网络"},{"id":"1d9c47053e5f4a8b3248ca28297f8b06","title":"欧盟将成立联合网络部门","content":"欧盟将成立联合网络部门2021年6月23日，欧盟委员会已宣布计划建立一个联合网络部门(Joint Cyber Unit)，以应对大规模的网络攻击。\n\n前因这不是欧盟委员会第一次提出在整个欧洲建立一个协调的网络部门的想法。此前欧盟也试图建立这样一个组织，但收效甚微。欧盟成员国认为他们自己可以完全掌控自己的安全问题，导致很难说服他们与其他国家合作。\n然而，随着电子设备互联数量的增加、5G 网络的广泛安装以及利用 COVID-19 大流行造成的混乱而实施的网络攻击，给欧盟带来了新的挑战。尤其是过去几年席卷该地区的网络攻击，特别是在医疗保健领域，促使欧盟国家寻求其他方式来打击网络犯罪。\n欧盟面临的压力越来越大，需要采取措施应对这些网络攻击。\n导火索网络攻击是一种国家安全威胁，欧洲的网络安全事件从 2019 年的 432 起增加到 2020 年的 756 起。\n4 月，包括欧盟委员会在内的一系列欧盟机构遭到重大网络攻击。尤其是最近针对爱尔兰和美国关键服务的勒索软件事件“引起了人们的关注”。\n今年五月爱尔兰的 Health Service Executive (HSE) 遭到名为 Conti 的勒索软件组织的攻击，该组织扰乱了 IT 系统，对许多医院造成了重大破坏。\n同样是五月，美国燃料供应遭到黑客攻击。一个名为 Darkside 的网络犯罪团伙迫使美国燃料供应商Colonial Pipeline 离线近一周，导致恐慌性购买和燃料短缺。\n\n勒索软件黑客使用恶意软件来扰乱和窃取组织的计算机数据 - 向受害者收取费用以将服务恢复正常。勒索软件攻击已造成超过 3.5 亿美元的损失。\n\n美国政府最近还成立了勒索软件工作组，而英国国家网络安全中心警告说，勒索软件是英国最大的网络威胁。\n再此背景下，提出了建立联合网络部门，来应对这些网络事件。\n部门简介欧盟委员会已宣布计划建立一个联合网络部门。委员会声明称，联合网络部门“旨在汇集欧盟（EU）及其成员国可用的资源和专业知识，以有效预防、阻止和应对大规模网络事件和危机”。\n目标该部门计划为“网络犯罪警察、网络机构、外交官、军事服务和网络安全公司协调响应和共享资源“提供一个对抗网络攻击的虚拟和物理平台，以便与成员国合作并通过安全渠道共享资源。最终，联合网络部门将实现成员国和欧盟机构之间的互助协议以及国家和跨境监测和检测。\n职能该部门职能包括：协调成员国和欧盟机构之间对严重网络事件的响应；提供一个协作平台，让受网络攻击困扰的欧盟成员国能够获得其他成员国的帮助，抵御网络攻击；在发生严重攻击时，一个由多国网络专家组成的专门团队将迅速部署到欧洲国家；\n地点欧盟计划中的联合网络单位，位于欧盟网络安全局 (ENISA) 和欧盟机构、机构和机构的计算机应急响应小组 (CERT-EU) 布鲁塞尔新办事处旁边。\n时间明年 6 月投入使用，并在一年后，即 2023 年 6 月 30 日之前完全建立。\n资金来源根据该机构的声明，设立该部门的投资将来自欧盟委员会数字欧洲计划(European Commission Digital Europe Programme)。 投资将包括“构建物理和虚拟平台，建立和维护安全的通信渠道，以及提高检测能力。”\n用于发展成员国网络防御能力等更长期任务的资源将来自欧洲国防基金(European Defence Fund)。\n总结\n勒索软件和基础设施安全\n\n​        近年来，大规模网络事件被报道的越来越多，其中针对关键基础设施的攻击尤为引人注意，如输油管道、卫生服务、供水系统等。尤其是勒索软件低成本、高收益、难解决的特点，使得勒索软件横行。勒索软件盯上基础设施的原因是：与物理世界息息相关，一旦中招，就不得不支付赎金。\n\n协作防御\n\n​        欧盟在网络攻击的响应中采取的是协作平台的方式，这也许是未来网络安全防御的趋势。在当今网络空间中，面对大规模网络攻击，合作共赢是一个趋势。随着技术的进步，在网络攻击中谁也不能全身而退，唯有合作，才能将损失减到最小。\n参考资料https://abcnews.go.com/International/irelands-health-service-hit-significant-ransomware-attack/story?id=77685241\nhttps://balkaninsight.com/2021/06/23/eu-sets-up-joint-cyber-unit-to-tackle-steep-rise-in-cyber-attacks/\nhttps://igca.org/2021/06/23/eu-to-launch-cybersecurity-joint-task-force/\nhttps://www.siliconrepublic.com/enterprise/joint-cyber-unit-eu-cyberattacks\nhttps://www.thedefensepost.com/2021/06/23/eu-joint-cyber-unit/\nhttps://news.yahoo.com/eu-wants-emergency-team-nightmare-123014135.html?guccounter=1&amp;guce_referrer=aHR0cHM6Ly9jbi5iaW5nLmNvbS8&amp;guce_referrer_sig=AQAAAG2x8KqN3MAlhHZKrQqweB3N_umneTJv2XRD9ToL2zQWF4Nx7CDTTXjNXZHD2PDsdYEdplyyY3cg5P00EInHKrEjTulc1Y3OIkS2J1qp1WbWATAli91CdA4WR-SLe7u9n8F9UJdE8DRlOwdp1tEBmSk15xfgPCqSXIpttYN6Tn3q\n","slug":"欧盟将成立联合网络安全工作组","date":"2022-02-26T06:08:41.000Z","categories_index":"","tags_index":"","author_index":"明说网络"},{"id":"f7dac1c4f8be79a67ad6ef3ccb07d851","title":"你的智能家居设备每周可能遭受10,000次黑客攻击","content":"你的智能家居设备每周可能遭受10,000次黑客攻击\n虽然使用智能家居设备可以提升你的生活环境，但它也可能使你的家庭成为充满窥视和犯罪活动的生活地狱。英国消费者团体Which? 的一项新调查发现，配备了智能家居设备的房子每周可能遭受超过一万次的黑客攻击。\n在与NCC集团和全球网络联盟（GCA）的合作下，Which? 为一栋房子配备了一系列智能家居设备，包括电视、恒温器，甚至水壶。接下来的情况相当令人震惊：新的智能家居遭受了许多网络攻击，最终在一小时内攀升到14次。结论是，大多数设备可以成功避免攻击，但亚马逊的一个摄像头被黑，并允许威胁者试图监视家里的人。\n调查的结果总的来说，在5月的第一周测试中，Which? 记录了来自全球不同地点的1017次黑客攻击企图，随后在最严格的一周测试中发生了12807次事件。\n受攻击最多的设备是一台爱普生打印机，但它被证明是安全的。一台从亚马逊购买并被宣传为公司选择的ieGeek相机的情况并不理想，在此份报告发布后不久就被从商店中删除。\n有趣的是，这并不是第一起与亚马逊有关的相机容易被黑客攻击的事件。2019年，在一连串成功的黑客尝试使用DDoS该公司的摄像头和麦克风之后，许多消费者团体站出来敦促用户不要购买亚马逊的Ring设备。\n为什么有人会黑进你的家？如果你家里的大部分东西都是以数字方式治理的，黑客就会有更大的攻击面。试图访问你的智能家居设备可以有各种目的，从接管你的网络到窃取你的数据，甚至要求赎金以获得敏感信息。\n一些相对无辜但令人讨厌的黑客将只是试图通过按照威胁者的意愿控制你的设备来刺激你。一些更严重的黑客攻击将包括监听你的谈话，绘制你的日常生活，并检查你何时离开和回家。\n你能做些什么来保护你的智能家居？幸运的是，你有很多方法来保护你的智能家居设备。始终使用一个强大的wifi密码和VPN，以确保你的连接是加密的。此外，在所有个人账户上启用多因子验证(口令、短信验证码等)，保持最新的软件版本，并为客人使用一个单独的Wi-Fi网络(访客Wifi)。当涉及到保护你的智能家居设备时，这些相对简单的网络安全建议可以产生极大的效果。\n","slug":"你的智能家居设备每周可能遭受10,000次黑客攻击","date":"2022-02-26T06:08:31.000Z","categories_index":"","tags_index":"","author_index":"明说网络"},{"id":"48e39417e91350100bfea1d9bf3ca8be","title":"《供应链安全培训法》:美将立法建立标准化网络安全培训，防范网络安全威胁","content":"《供应链安全培训法》:美将立法建立标准化网络安全培训，防范网络安全威胁\n美参议院提出的一项两党法案，将为采购技术服务(注：购买信息设备及服务)的联邦雇员创建一个标准化的网络安全培训计划。\n支持该立法提案的立法者说，这将有助于美国政府防范安全威胁和其他供应链的脆弱性。\n该法案名为《供应链安全培训法》( Supply Chain Security Training Act)，由担任参议院国土安全和政府事务委员会主席的密歇根州参议员加里-彼得斯和担任该委员会成员的威斯康星州议员罗恩-约翰逊提出。该法案将指示美国总务管理局与国土安全部、国防部和管理与预算办公室协调，为负有采购的联邦官员创建一个供应链安全培训。该法案还将要求管理和预算局为联邦机构采用和使用该计划制定指南。\n进入美政府系统的 “后门彼得斯强调了这项措施的国家安全重要性，告诫威胁者不要进入美国系统。\n“彼得斯说：”最近针对美国网络的攻击表明，我们的外国对手和犯罪组织将不惜一切代价入侵网络，窃取信息并破坏我们的国家安全。”联邦雇员在购买软件和设备时，需要知道如何识别可能的威胁，因为这些软件和设备可能会让坏人有后门进入政府信息系统。”\n彼得斯说，该法案将有助于加强政府的安全态势。\n最近的攻击拟议的立法是在最近一连串的攻击之后提出的，包括2020年12月检测到的SolarWinds供应链攻击。据报道，该活动导致9个美国机构（包括财政部和商务部）以及100家公司（包括微软、SolarWinds和VMWare）遭到后续攻击。\n5月，Colonial Pipeline Co.的管道横跨东海岸，成为勒索软件攻击的受害者，导致该公司暂时停止运营。Colonial Pipeline随后向据说在东欧运作的犯罪集团DarkSide支付了440万美元的赎金，以获得一个解密器。联邦调查局后来追回了230万美元的赎金。\n同样在5月，肉类加工巨头JBS遭受了勒索软件攻击，中断了在美国、加拿大和澳大利亚的业务。联邦调查局将这次攻击归咎于REvil，又称Sodinokibi，这是一个勒索软件即服务（ransomware-as-a-service）的操作。JBS后来表示，它向犯罪团伙支付了价值1100万美元的加密货币。\n而在最近几天，出现了关于REvil供应链勒索软件攻击软件供应商Kaseya的细节，该攻击可能已经影响到全球多达1500个组织。\n约翰逊在评论拟议的法案时说：”在我们的对手正在探测网络漏洞以破坏我们的系统和窃取信息的时候，对为政府购买和销售商品和服务的联邦工作人员进行反情报培训至关重要。这种类型的培训将有助于弥补我们在网络和物理安全防御方面的差距。”\n彼得斯和约翰逊在2019年提出了类似的立法。那项法案得到了参议院的批准，但没有得到众议院的投票，其目的是让联邦人员做好准备，以识别和减轻在软件采购过程中出现的反情报威胁。\n建立在行政命令基础之上新的提案希望建立在乔-拜登总统于5月12日发布的网络安全行政命令的基础上，该命令要求政府部门为软件建立基线安全标准–包括应用程序的可见性和对安全数据的访问。该指令还要求供应商在开发过程中纳入安全性。此外，将创建一个新的标签，类似于能源之星的标签，供政府和私营企业确定软件是否是安全开发的）。\n在关于该行政命令的补充文件中，白宫指出：”我们有太多的软件，包括关键软件，存在严重的漏洞，被我们的对手所利用。” 利用联邦政府的购买力，政府希望 “从头开始在所有软件中建立安全”。\n","slug":"美将立法建立标准化网络安全培训，防范网络安全威胁","date":"2022-02-26T06:08:22.000Z","categories_index":"","tags_index":"","author_index":"明说网络"},{"id":"b9751c01f44761e7eecc1870fe40423d","title":"救援机器人队伍将驰援佛罗里达州救援现场，是搜救行动的有力工具","content":"救援机器人队伍将驰援佛罗里达州救援现场，是搜救行动的有力工具\n截至7月3日，已有37人从6月24日清晨倒塌的佛罗里达州公寓楼中获救。然而，还有140多人仍然下落不明–现在已经派出救援机器人来寻找他们。\n挑战搜救工作往往是与时间赛跑–在大楼倒塌这样的情况下，每过一个小时，找到幸存者的可能性就会减少。\n然而，对于急救人员来说，倒塌的建筑物也是一个非常危险的地方，所以他们必须非常慎重地在其中穿行–一个错误的动作，就可能导致难以想象的后果。\n7月1日上午，佛罗里达州的另一部分建筑开始出现可能倒塌的迹象，因此急救人员在当天的大部分时间里被从现场撤出。当搜索重新开始时，他们的进入受到限制。\n救援机器人机器人可以成为搜救行动的有力工具，它使用摄像机和其他传感器来寻找幸存者的迹象，而不会将人类救援人员置于危险之中。\n较小的救援机器人还可以进入人类无法–或不应该–驾驭的狭小空间。\n\n“机器人公司Teledyne Flir的无人地面系统副总裁汤姆-弗罗斯特告诉《华盛顿邮报》：”在这样的坍塌情况下，桩的结构不健全，经常容易发生移动。”让机器人爬到空隙深处比让人爬到空隙中要安全得多。”\n提供帮助据《邮报》报道，Teledyne Flir公司已经向迈阿密-戴德消防局（MDFR）派出了至少两个救援机器人，以帮助处理佛罗里达州的灾难。\n其中一个是重达7磅、类似坦克的机器人，名为FirstLook。它配备了摄像头和麦克风，可以在跌落到混凝土上的16英尺处生存。\n\n“弗罗斯特说：”你可以把这个机器人扔进窗户或扔到屋顶上，然后到达真正难以到达的地方。\n另一个是名为PackBot的手提箱大小的机器人。它在9&#x2F;11恐怖袭击世界贸易中心后协助了救援工作，被设计用来移动物体和携带多达40磅的货物。\n\n接下来目前还不清楚MDFR是否已经部署了这两个救援机器人，或计划在未来部署。\n然而，第一波救援已经使用了无人机、声纳和其他技术–由于安全问题限制了人类救援人员目前能做的事情，地面机器人可能是救援工作的一个有价值的补充。\n","slug":"救援机器人将驰援佛罗里达州救援现场","date":"2022-02-26T06:08:07.000Z","categories_index":"","tags_index":"","author_index":"明说网络"},{"id":"77209a391e51d9d761bc9875b20fa8ab","title":"警报! 物联网恶意软件Mirai和其他十几个变种依然活跃","content":"警报! 物联网恶意软件Mirai和其他十几个变种依然活跃摘要Mirai僵尸网络自2016年首次出现以来，已经有近五年的时间。自Mirai出现以来，一直是一个持续的物联网安全威胁。该恶意软件及其几个变种被认为是2021年第一季度引发对物联网（55%）和Linux（38%）系统攻击激增的原因。物联网设备制造商需要及时修补漏洞，并遵循适当的物联网安全标准。\n\nMirai僵尸网络自2016年首次出现以来，已经有近五年的时间。自Mirai出现以来，一直是一个持续的物联网安全威胁。在McAfee最近的一份报告中，该恶意软件及其几个变种被认为是2021年第一季度引发对物联网（55%）和Linux（38%）系统攻击激增的原因。 安全研究人员警告说，恶意软件一直在控制世界各地的路由器、网络摄像机和DVR，以创建一个能够扰乱互联网的巨大僵尸网络。\n\n物联网恶意软件在互联网上扫描使用默认或薄弱用户名和密码的物联网设备。他们还寻求利用已知的，有时甚至是零日(0Day)漏洞来增加他们获得设备访问权限的机会。一旦触发漏洞，就会自动下载并执行恶意二进制文件，使物联网设备成为僵尸网络的一部分，然后可能被攻击者控制参与分布式拒绝服务（DDOS）攻击，导致被攻击目标服务中断。一些威胁者甚至将这些控制的僵尸网络作为一项服务（DDoS-for-Hire&#x2F; DDoS as a Service)出售。\n变种继续增长自从Mirai的作者发布源代码以来，威胁者一直在通过创建他们自己的物联网僵尸网络军队的来发动大量的攻击。虽然各种Mirai变体不断增加新的功能和漏洞，但其结构和目标仍然是相同的。\n\n评估Mirai的突出地位Fortinet的研究人员在跟踪物联网僵尸网络活动的过程中遇到了许多有趣的方面。一个用于此目的的新蜜罐(Honeypot)系统被发现每天收到约200次攻击，在短短三周内总和接近4700次攻击。这些攻击中约有4000次与Mirai变体有关。根据这些攻击，使用最多的变种是Hajime, SYLVEON, Kyton, PEDO, DNXFCOW, SORA, Cult, BOTNET, OWARI, 和Ecchi。除了蜜罐，研究人员还发现Mirai的一个变种MANGA正在积极更新其列表中的漏洞载体。其中一些漏洞是针对OptiLink ONT1GEW GPON、Cisco HyperFlex和Tenda路由器中发现的漏洞。\n另一个Mirai变体Moobot的活动出现了高峰根据AT&amp;T外星人实验室(AT&amp;T Alien Labs)的说法，另一个Mirai变体Moobot的活动出现了高峰。事实证明，它是从一个新的网络地下恶意软件域推送出来的，该域被称为Cyberium，一直在锚定大量的Mirai变体活动。研究人员观察到，Moobot正在积极扫描Tenda路由器中的一个远程代码执行漏洞。Moobot的主要特征之一是在代码中多次使用硬编码字符串，如生成执行时使用的进程名称。\n结论随着智能设备的数量不断爆炸，物联网在未来仍将是恶意软件运作的温床。显然，Mirai变种在攻击和发展方面的活跃状态使其更加令人担忧。它也再次强调物联网设备制造商需要及时修补漏洞，并遵循适当的物联网安全标准。\n","slug":"警报! Mirai僵尸网络活跃，其他十几个变种也是如此","date":"2022-02-26T06:07:58.000Z","categories_index":"","tags_index":"","author_index":"明说网络"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"\ntitle: 针对人工智能驱动的人脸识别系统的新攻击方法date: 2022-02-26 14:10:48\n\n针对人工智能驱动的人脸识别系统的新攻击方法\n来自Adversa的研究人员开发了一种名为Adversarial Octopus的攻击技术，可以对面部识别系统进行定向攻击。它影响了当前几个人工智能驱动的面部识别工具，使它们暴露在严重的攻击之下。\n关于新的攻击研究人员开发了这种针对人工智能驱动的面部识别系统的新攻击，可以改变照片的方式，使人工智能系统识别出不同的人或任选的人。这种攻击的主要特点是，它可以针对各种人工智能的实现，如物理设备和在线API。它可以适应目标环境。这种类型的攻击既可用于规避场景，如制作隐蔽的深度欺骗，也可用于通过欺骗计算机视觉算法，对场景进行“投毒”，并可能导致严重后果。该攻击能够绕过面部识别服务、应用程序和API。此外，它影响了最先进的在线面部识别搜索引擎，即PimEyes。\n对PimEyes搜索引擎的攻击这个针对PimEyes的对抗性Octopus 攻击是用攻击框架中的以下技术开发的。为了提供更好的可转移性，它在各种面部识别模型上与随机模糊和噪音一起训练。为了提供更好的准确性，该系统被创建为在神经网络的每一层计算对抗性变化，并使用随机人脸检测框架。为了获得更好的可感知性，它对每个像素的微小变化进行了优化，并使用特殊函数来平滑对抗性噪声。\n结论这种攻击表明，人工智能系统在安全方面需要更多的关注，而这种新的攻击方法将有助于提高人们的认识。它将帮助企业处理目前对抗性机器学习系统中存在的问题。此外，研究人员正在与企业协调，以保护他们的人工智能应用免受这种攻击。\n参考资料https://cyware.com/news/a-new-attack-on-ai-driven-facial-recognition-systems-4ece656a\n","slug":"针对人工智能驱动的人脸识别系统的新攻击方法","date":"2022-02-26T04:40:08.987Z","categories_index":"","tags_index":"","author_index":"明说网络"},{"id":"195a1e45ce14c8e11c0aa1ca446ac13d","title":"犯罪分子进入一个网络需要多少钱？可能是7200美元","content":"犯罪分子进入一个网络需要多少钱？可能是7200美元\n摘要Verizon数据泄露调查报告（DBIR）显示，勒索软件是泄露事件当中的第三大热门行动。”报告的作者Phil Langlois在一次网络研讨会上说：”这很令人吃惊。平均而言，网络犯罪分子进入一个网络要花费7200美元。\n正文Verizon分析了来自全球88个国家的样本，近8万起事件，其中5,300起是确认的泄露事件。研究强调，事件和漏洞之间是有区别的。事件是指损害信息资产的完整性、保密性或可用性的安全事件，而漏洞是一个导致数据被确认披露给未授权方的事件。\n三种最常见的入侵类型研究人员将他们观察到的事件和漏洞归纳为八个核心模式，代表了绝大多数的事件。当我们谈论漏洞时，社会工程、基本网络应用程序攻击和系统入侵是最流行的模式。Phil Langlois简要地介绍了这三种模式。\n社会工程。研究人员发现，他们分析的大约85%的漏洞涉及人为因素。”有人点击了一个链接，错误地配置了一个防火墙，或类似的东西，”Langlois说明道。研究人员还看到网络钓鱼有了相对显著的增长。以前，它占数据泄露的1&#x2F;4，而现在它徘徊在36%左右。\n基本的网络应用程序攻击是那些在最初的网络应用程序被破坏后有少量的步骤或额外的行动。它们非常专注于直接攻击目标，从获取电子邮件和网络应用程序数据，到重新利用网络应用程序进行恶意软件分发、污损或未来的DDoS攻击。Langlois说：”我们谈论的是单步攻击，在这种攻击中，对手利用的往往是受损的凭证、弱口令，有时还有漏洞，”。他称其为互联网噪音（internet noise）：不断看到凭证被使用和暴力攻击的尝试。\n系统入侵涉及一个高级攻击者。这种模式代表了一个专门的攻击者使用黑客和恶意软件技术的组合来实现其目标。系统入侵的三个主要组成部分是勒索软件、一般的高级威胁，以及magecart攻击，即攻击者在应用程序中注入恶意的javascript以窃取信用卡信息。例如，电子商务安全供应商Sansec报告说，Lazarus集团一直在使用Magecart支付卡盗刷来攻击美国和欧盟的电子零售商。\nLanglois强调说，赎金软件在增长，现在占他们分析的泄露事件的10%。他说：”这是一个相当戏剧性的上升”。\n犯罪分子接入一个网络需要多少钱？初始访问代理（Initial access brokers ）催生了勒索软件。犯罪分子在暗网购买数据或出售数据和访问权限。最主要的目标行业是零售、金融服务、工业品、医疗保健和技术部门。\n研究人员正在研究各种非法市场。自2020年以来，他们已经看到了500个不同的网络访问权限的销售清单。这意味着，如果你有一个不安全的网络，可能会被出售。\n根据数字风险保护公司Digital Shadows的数据，平均而言，网络犯罪分子进入一个网络要花费7200美元。\n远程桌面协议（RDP）访问是列出的最常见的访问类型，平均价格为9,874美元。\n","slug":"犯罪分子进入一个网络需要多少钱？可能是7200美元","date":"2022-02-26T04:40:08.852Z","categories_index":"","tags_index":"","author_index":"明说网络"},{"id":"907fda85396eb3c2a9f20d248e6804fd","title":"打着安全的幌子公然给客户安装恶意软件","content":"打着安全的幌子公然给客户安装恶意软件\n最近，来自Proofpoint的研究人员发现了一种新的网络安全威胁，它试图用一个看起来很专业的网站的虚假幌子来欺骗人们，声称可以提供更强的安全性。这种伪装可以说是一种讽刺，因为它实际上最终在受害者的机器上部署了信息窃取的恶意软件。\n发现了什么？一些威胁者开发了一个看起来合法的网站，伪装成隐私工具服务，声称提供实用工具来保护个人和商业数据。\n\n这个所谓的隐私工具服务被宣传为一个类似zip的实用工具，可以加密用户数据确保安全。\n该网站提供了有关所谓服务的详细信息，包括指导用户下载和使用隐私工具的分步说明。\n按照指示，受害者最终会安装Smoke Loader恶意软件，它是一个具有多种功能的模块化下载器。Smoke Loader工具进一步下载了两个数据窃取的恶意软件：Redline和Raccoon Stealer。\n\n最近的信息窃取者攻击在过去的一段时间里，有几个攻击者被观察到通过使用虚假的假装或其他方法来引诱他们的受害者来传播信息窃取恶意软件。\n\n在上个月，一些攻击者被发现滥用谷歌搜索结果中的一些点击付费（PPC）广告，会下载恶意的AnyDesk、Dropbox和Telegram软件包。这些假的应用程序最终会使受害者感染Redline、Taurus、Tesla和Amadey信息窃取者恶意软件。\n早些时候，一些威胁者被发现滥用微软Build（MSBuild）引擎，用Remcos RAT和Quasar RAT以及RedLine Stealer感染受害者。\n\n总结最新的活动揭示了攻击者在使这种以隐私为主题的诱饵变得现实和有效方面所付出的越来越多的努力。此外，信息窃取越来越多，引起了人们对地下黑市中私人信息不断增长的需求的担忧。因此，建议用户通过使用可靠的反恶意软件解决方案提供保护。\n","slug":"打着安全的幌子公然给客户安装恶意软件","date":"2022-02-26T04:40:08.637Z","categories_index":"","tags_index":"","author_index":"明说网络"},{"id":"8c41f30400ba00b9f35b78840a7e59fe","title":"打印机软件中存在16年的漏洞可让黑客获取管理权限","content":"打印机软件中存在16年的漏洞可让黑客获取管理权限\n速揽在惠普、施乐和三星打印机驱动程序中发现的一个存在16年的安全漏洞，允许攻击者在使用有漏洞的驱动程序软件的系统上获得管理权限。这个被称为CVE-2021-3438的安全漏洞是特定型号打印机的SSPORT.SYS驱动程序中的缓冲区溢出，可能导致用户权限的本地升级。\n正文在惠普、施乐和三星打印机驱动程序中发现的一个存在16年的安全漏洞，允许攻击者在使用有漏洞的驱动程序软件的系统上获得管理权限。这个被称为CVE-2021-3438的安全漏洞是特定型号打印机的SSPORT.SYS驱动程序中的缓冲区溢出，可能导致用户权限的本地升级。\n这个高危漏洞自2005年起就存在于打印机软件中，影响到全球数以亿计的设备和数百万的用户。\nSentinelOne的研究人员发现，这个有问题的驱动程序会自动与打印机软件一起安装，并在每次系统重启后被Windows加载。这使得它成为提升权限的完美目标，因为即使在打印机没有连接到目标设备时，也很容易滥用这个漏洞。要成功利用这个漏洞，需要本地用户访问，这意味着威胁者将需要首先在目标设备上获得一个立足点。一旦他们得到这一点，他们就可以滥用这个安全漏洞，在不需要用户交互的情况下，在低复杂度的攻击中提升权限。\n研究人员表示，在成功利用驱动漏洞后，可能会让攻击者有可能安装程序，查看、改变、加密或删除数据，或创建具有完全用户权限的新账户。\n由于没有证据表明这一漏洞在现实中被利用但单目前有数以亿计的企业和用户存在漏洞，攻击者会寻找那些采取适当防护措施的人。惠普、施乐和三星的企业和家庭用户尽快应用这两家供应商提供的补丁。\n","slug":"打印机软件中存在16年的漏洞可让黑客获取管理权限","date":"2022-02-26T04:40:08.630Z","categories_index":"","tags_index":"","author_index":"明说网络"},{"id":"11fe66844838ca259f473a1a6f2d718c","title":"恶意软件投放：不容忽视的伪装威胁","content":"恶意软件投放：不容忽视的伪装威胁\n企业正受到恶意软件投放器(dropper)的打击，这种投放器使得攻击者能够进行多阶段的攻击。这使得企业面临更高的恶意软件威胁、数据被盗和系统被破坏等风险。\n什么是恶意软件投放器Droppers是特洛伊木马的一种类型。它们的标志性目的是，一旦它们出现在一个系统中，就安装其他恶意软件。事实上，它们被命名为投放器(droppers )，因为它们将恶意软件和恶意软件组件投放到一个被破坏的系统中。这种活动为投放者赢得了 “催生恶意软件的恶意软件 “的绰号。\n为了更好地避免被发现，投放者通常不会保存到被攻击系统的磁盘上。相反，投放者通常在其目的达到后自行删除。它们在推进攻击目标的过程中经常执行不同的行动。\n传播方式droppers 程序可以通过多种方式传播。最常见的外挂程序传播方式包括。\n\n访问恶意网站\n点击恶意链接\n垃圾邮件的附件\n插入受感染的可移动媒体\n使用受感染的互联网代理\n下载受感染的免费软件\n\ndroppers 也可能通过受感染的应用程序传播–甚至是那个广泛使用的、看似合法的应用程序。研究人员最近发现，CamScanner，一个下载量超过1亿的流行的安卓应用，已经有一段时间在其中隐藏了一个droppers 程序。\n最新的恶意软件投放器活动Proofpoint研究人员剖析了JSSLoader恶意软件的一个新变种，它为威胁者提供了躲避检测和加载额外有效载荷(payload)的机会。\n\n在另一项研究中，Proofpoint发现了一个新的Smoke Loader活动，该活动将Raccoon Stealer和RedLine等窃取数据的恶意软件作为最终的有效载荷。该活动的初始感染过程涉及将受害者引诱到一个提供商业和个人使用的隐私工具的虚假网站。\nSload，也被称为Starslord loader，在针对欧洲、英国和意大利的多个供应商的恶意活动中被发现。恶意软件创建者使用VBS和PowerShell等脚本作为其最初立足点(initial foothold)的一部分，诱使用户执行加载器。\n一种名为Matanbuchus Loader的新恶意软件即服务，能够从C2基础设施中投放第二阶段的恶意软件，也被各种攻击者使用。\n\n下载器的发展造成了更大的破坏\n不仅JSSLoader已经进化到为其操作者提供多阶段攻击的多种选择，而且另一个名为Buer Loader的恶意软件下载器也已被改造，以帮助在不被发现的情况下在被攻击的系统中获得立足点。\nProofpoint发现，名为RustyBuer的新变种已经影响到全球50多个垂直行业的200多个组织。\n\n基于TLS的恶意流量\n在Sophos进行的一项研究中，研究人员发现，初始阶段的恶意软件，如加载器（loaders）、投放器（droppers）和基于文件的安装器（installers ），在很大程度上依赖于恶意的TLS流量，以确保他们对受害者机器的访问。\nSophos解释说，使用TLS是一种逃避基本有效载荷检查的方式。此外，在恶意软件投放器中利用该协议并不需要太复杂，因为支持TLS的基础设施可以有效提供恶意软件或恶意代码片段。\n\n总结Droppers 是一种著名的恶意软件类型，从特洛伊木马的早期就已经存在了。除了下载和安装恶意软件外，人们还观察到攻击者表现出不同的行为，使其与其他恶意软件不同。这些行为包括搜索可用的安全控件，连接到可疑的网站，并试图隐藏与网站的连接。此外，随着勒索软件和持续的恶意电子邮件威胁的增加，预计加载器的存在越来越多，可能会见证一个上升。\n参考资料https://resources.infosecinstitute.com/topic/malware-spotlight-droppers/\n","slug":"恶意软件投放：不容忽视的伪装威胁","date":"2022-02-26T04:40:08.627Z","categories_index":"","tags_index":"","author_index":"明说网络"},{"id":"eb5d876b4883fd257ce36854111e3d6f","title":"不要让你对家人的爱，变成泄露数据隐私的“帮凶”","content":"不要让你对家人的爱，变成泄露数据隐私的“帮凶”研究人员发现，常见的安卓追踪软件应用受到漏洞的影响，可能暴露受害者的隐私和安全。\n\n手机追踪软件，也被称为spouseware，被追踪者用来监视受害者。该应用程序可以收集GPS位置，监视对话，访问浏览器历史记录、图像和存储在设备上的其他敏感数据，一般用来作为保护儿童的解决方案。例如现在很多这种的手表(图文无关)\n\n但它们提供的间谍软件功能也可能被第三方滥用。\n众多安卓追踪软件应用存在安全风险据ESET研究人员称，在对86个安卓追踪软件应用的分析中，在58个安卓追踪软件应用中发现了超过150个安全漏洞，这些漏洞使受害者暴露在其他隐私和安全风险中。\n研究人员手动分析了86个不同供应商提供的安卓平台的追踪软件应用。安装和远程监视或控制追踪软件的人被定义为追踪者，而受害者是追踪者使用追踪软件监视的目标人物。攻击者是追踪者和受害者通常不知道的第三方。攻击者可以利用如追踪软件或其相关监控服务中的安全问题或隐私缺陷等，发动攻击。最常见的问题包括不安全地传输受害者的PII和将敏感数据储存在外部媒介上。\n\n攻击者可以利用该缺陷获得对受害者设备的控制，它还可以通过上传捏造的证据来威胁受害者。\n\n目前修复动态研究人员在开发团队的90天协调信息披露政策(coordinated disclosure policy)后向其披露了该漏洞。截至目前，只有六家厂商解决了研究人员发现的漏洞，只有七家厂商计划修复这些漏洞，有一家厂商决定不修复报告的问题。\n研究人员对使用此类软件的人员发出警告研究人员总结说，这项研究应该作为对未来追踪软件客户的警告，让他们重新考虑使用软件来对付他们的配偶和亲人，因为这不仅是不道德的，而且可能导致泄露他们配偶的私人和私密信息，使他们面临网络攻击和欺诈的风险。\n同时，这对追踪者来说也是有风险的，因为追踪者和受害者之间可能存在密切的关系，因此他们的私人信息也可能被暴露。\n","slug":"常见的安卓追踪软件应用受到漏洞的影响，可能暴露受害者的隐私和安全","date":"2022-02-26T04:40:08.595Z","categories_index":"","tags_index":"","author_index":"明说网络"},{"id":"8ba16520bf2f9f2afc20dc140f78edc0","title":"基于netfilter的IP数据统计设计","content":"Table of Contents\n背景\nIP信息统计\n统计信息设计\n存储数据结构\n\n\nLinux驱动\n网络型驱动设备\n字符型设备\n用户代码\n\n\n总结\nLinux 驱动\nLinux内核\n其他\n\n\n参考资料\n\n\n背景当今社会，没有都有自己的信息处理设备，如手机、计算机甚至可能是路由器。在使用这些设备的时候，我们想知道的一件事就是，我的电脑和那些设备有过通信，通信情况怎么样，以便在网络出现问题，如拥塞，或是自己主机被黑客控制出现异常数据的时候，能够通过上述统计信息快速定位问题所在。因此本文通过Linux驱动中的netfilter对IP数据报中的IP信息进行统计，通过字符型驱动实现用户态查看统计信息，达到了统计主机通信的目的，为进一步做好异常处理打下了基础。\n\nIP信息统计\n统计信息设计统计对象为源IP地址，信息内容目前设计为：IP出现频次，最后一个IP数据包出现时的时间戳。\ntypedef struct IPData&#123;\n  int timestamp;\n  int count\n&#125;ipdata;\n\n\n存储数据结构由于在Linux Kernel中没有C++的set，map等数据结构，因此使用其提供的红黑树实现IP信息的快速存储和读取。其中红黑树节点的信息如下所示：\n   typedef struct roc_node_s\n&#123;\n    struct rb_node node;\n    void *ctx;\n    int key;\n    ipdata ipcount;\n&#125;roc_node_t;\n\n红黑树的实现使用Linux Kernel自带的rbtree数据结构，头文件为：\n#include &lt;linux/rbtree.h&gt;\n\n红黑树插入，删除等代码参考链接为：https://blog.csdn.net/chn475111/article/details/52594457.\n/**\n * filename: my_rbtree.h\n * @author lijk@.infosec.com.cn\n * @version 0.0.1\n * @date 2016-9-20 11:52:06\n */\n#include &lt;linux/string.h>\n#include &lt;linux/rbtree.h>\ntypedef struct IPData&#123;\n  int timestamp;\n  int count\n&#125;ipdata;\ntypedef struct roc_node_s\n&#123;\n    struct rb_node node;\n    void *ctx;\n    int key;\n    ipdata ipcount;\n&#125;roc_node_t;\n\ntypedef void (*roc_cb)(void*);\n\nroc_node_t* roc_search(struct rb_root *root, int key)\n&#123;\n    struct rb_node *node = root->rb_node;\n    while(node)\n    &#123;\n        roc_node_t *data = rb_entry(node, roc_node_t, node);\n        int result = key - data->key;\n\n        if (result &lt; 0)\n            node = node->rb_left;\n        else if (result > 0)\n            node = node->rb_right;\n        else\n            return data;\n    &#125;\n    return NULL;\n&#125;\n\nint roc_insert(struct rb_root *root, roc_node_t *data)\n&#123;\n    struct rb_node **new = &amp;(root->rb_node), *parent = NULL;\n    while(*new)\n    &#123;\n        roc_node_t *this = rb_entry(*new, roc_node_t, node);\n        int result = data->key - this->key;\n\n        parent = *new;\n        if (result &lt; 0)\n            new = &amp;((*new)->rb_left);\n        else if (result > 0)\n            new = &amp;((*new)->rb_right);\n        else\n            return 0;\n    &#125;\n\n    rb_link_node(&amp;data->node, parent, new);\n    rb_insert_color(&amp;data->node, root);\n\n    return 1;\n&#125;\n\nvoid roc_erase(struct rb_root *root, int key, roc_cb cb)\n&#123;\n    roc_node_t *data = roc_search(root, key);\n    if(data)\n    &#123;\n        rb_erase(&amp;data->node, root);\n        RB_CLEAR_NODE(&amp;data->node);\n        if(cb) cb(data);\n    &#125;\n&#125;\n\nvoid roc_destroy(struct rb_root *root, roc_cb cb)\n&#123;\n    roc_node_t *pos = NULL;\n    struct rb_node *node = NULL;\n    while((node = rb_first(root)))\n    &#123;\n        pos = rb_entry(node, roc_node_t, node);\n    #ifdef _DEBUG\n        sprintf(message, \"key = %d\\n\", pos->key);\n    #endif\n        rb_erase(&amp;pos->node, root);\n        RB_CLEAR_NODE(&amp;pos->node);\n        if(cb) cb(pos);\n    &#125;\n&#125;\n\nvoid roc_dump(struct rb_root *root)\n&#123;\n    struct rb_node *node = NULL;\n  int sip, count, timestamp;\n  //printk(\"roc_dump\");\n    memset(message, 0, MAX_SIZE);\n    for(node = rb_first(root); strlen(message) &lt; MAX_SIZE &amp;&amp; node != NULL; node = rb_next(node))&#123;\n\n  sip = (unsigned int)rb_entry(node, roc_node_t, node)->key ;   \n  count = (unsigned int)rb_entry(node, roc_node_t, node)->ipcount.count ;   \n  timestamp = (unsigned int)rb_entry(node, roc_node_t, node)->ipcount.timestamp ;  \n  sprintf(message, \"%s%d.%d.%d.%d|%d|%d,\",message, NIPQUAD( sip), count, timestamp);\n      //printk(message);\n    &#125;\n&#125;\n\nvoid roc_free(void *ptr)\n&#123;\n    roc_node_t *node = (roc_node_t*)ptr;\n    if(node)\n    &#123;\n        if(node->ctx) kfree(node->ctx);\n        kfree(node);\n    &#125;\n&#125;\n\nint test(int argc, char const *argv[])\n&#123;\n    struct rb_root root = RB_ROOT;\n\n    int loop = 0;\n    roc_node_t *node = NULL;\n    for(loop = 0; loop &lt; 100; loop ++)\n    &#123;\n        node = (roc_node_t*)kmalloc(sizeof(roc_node_t), GFP_KERNEL );\n        if(node == NULL)\n            break;\n        node->ctx = NULL;\n        node->key = loop;\n        roc_insert(&amp;root, node);\n    &#125;\n\n#if 0\n    for(loop = 0; loop &lt; 100; loop ++)\n        roc_erase(&amp;root, loop, roc_free);\n#endif\n\n    roc_dump(&amp;root);\n    roc_destroy(&amp;root, roc_free);\n    return 0;\n&#125;\n\n\nLinux驱动考虑在内核实现的原因是目前Linux相关设备非常多，可能具有一定的参考价值和移植性。笔者的内核环境为：\n  uname -r\n4.15.0-142-generic\n\n\n网络型驱动设备netfilter的相关参考资料为：Linnux5.0.0下，基于Netlink与NetFilter对本机数据包进行筛选监控,https://blog.csdn.net/qq_40758751/article/details/105117750 , netfilter数据包过滤, https://blog.csdn.net/specialsun/article/details/84695519因为本文为源Ip数据包信息统计，所以netfilter hook的层级在NFINETLOCALIN.Hook 函数为filterhttp(忽略函数名，粘贴过来，不想改了).\n\n字符型设备内核态数据在用户态访问需要通过字符型设备驱动进行。因此建立一个字符型设备&#x2F;dev&#x2F;IPDataSet 使得用户态能够访问内核 态的数据信息。参考资料：ubuntu 添加字符设备驱动程序, https://blog.csdn.net/ARAFATms/article/details/79397800因为上述驱动需要自己手动添加字符设备，所以通过以下方法自动添加设备节点。参考资料：linux驱动：自动创建设备节点, https://blog.csdn.net/u012247418/article/details/83684029\n// filename: filter_ip.c\n#ifndef __KERNEL__\n#define __KERNEL__\n#endif  /* __KERNEL__ */\n\n#include &lt;linux/module.h&gt;\n#include &lt;linux/init.h&gt;\n#include &lt;linux/types.h&gt;\n#include &lt;linux/string.h&gt;\n//#include &lt;asm/uaccess.h&gt;\n#include &lt;linux/netdevice.h&gt;\n#include &lt;linux/netfilter_ipv4.h&gt;  // ip4 netfilter,ipv6则需引入相应 linux/netfilter_ipv6.h\n#include &lt;linux/ip.h&gt;\n#include &lt;linux/tcp.h&gt;\n#include &lt;linux/sched.h&gt;\n#include &quot;linux/kernel.h&quot;\n#include &quot;linux/fs.h&quot;\n#include &quot;linux/errno.h&quot;\n#include &quot;linux/uaccess.h&quot;\n#include &quot;linux/kdev_t.h&quot;\n#include &lt;linux/device.h&gt;\n#include &lt;linux/time.h&gt;\n\n#define NIPQUAD(addr) \\  \n((unsigned char *)&amp;addr)[0], \\  \n((unsigned char *)&amp;addr)[1], \\  \n((unsigned char *)&amp;addr)[2], \\  \n((unsigned char *)&amp;addr)[3]  \n\n#define MAX_SIZE 1024 * 1024 * 8\nchar message[MAX_SIZE] = &quot;&quot;;  //打开设备时会显示的消息\n#include &quot;my_rbtree.h&quot;\n\nstruct rb_root root = RB_ROOT;\nint insert(int key, int timestamp)\n&#123;\n\n  roc_node_t *node = NULL;\n  node = roc_search(&amp;root, key);\n  if(node != NULL) &#123;\n    node-&gt;ipcount.count++;\n    node-&gt;ipcount.timestamp = timestamp;\n    return 1;\n  &#125;\n  node = (roc_node_t*)kmalloc(sizeof(roc_node_t), GFP_KERNEL );\n  node-&gt;ctx = NULL;\n  node-&gt;key = key;\n  node-&gt;ipcount.count = 1;\n  node-&gt;ipcount.timestamp = timestamp;\n  return roc_insert(&amp;root, node);\n\n&#125;\n\nstruct timeval time;\n// 过滤http数据包\nunsigned int filter_http(char *type,struct sk_buff *pskb)\n&#123;\n  __be32 sip,dip;\n  int retval = NF_ACCEPT;\n  int ret, ms;\n  struct sk_buff *skb = pskb;\n\n  struct iphdr *iph = ip_hdr(skb);  // 获取ip头\n\n  sip = iph-&gt;saddr;  \n  dip = iph-&gt;daddr;  \n  //printk(&quot;Packet for source address: %d.%d.%d.%d destination address: %d.%d.%d.%d\\n&quot;, NIPQUAD(sip), NIPQUAD(dip));  \n\n  //sprintf(message, &quot;Packet for source address: %d.%d.%d.%d destination address: %d.%d.%d.%d\\n&quot;, NIPQUAD(sip), NIPQUAD(dip));\n\n\n  do_gettimeofday(&amp;time);  /*第一次去获取时间*/  ms = time.tv_sec * 1000 + time.tv_usec / 1000;  ret = insert(sip, ms);  //if(ret == 1)&#123;      roc_dump(&amp;root);  printk(message);  //&#125;  return retval;&#125;\n\n\nunsigned int NET_HookLocalIn(void *priv,     struct sk_buff *pskb,     const struct nf_hook_state *state)&#123;  return filter_http(&quot;in&quot;,pskb);&#125;\n\n\nunsigned int NET_HookLocalOut(void *priv,     struct sk_buff *pskb,     const struct nf_hook_state *state)&#123;  //return filter_http(&quot;out&quot;,pskb);  return NF_ACCEPT;&#125;\n\n\n\nunsigned int NET_HookPreRouting(void *priv,     struct sk_buff *pskb,     const struct nf_hook_state *state)&#123;  return NF_ACCEPT;&#125;\n\n\n\n\n\nunsigned int NET_HookPostRouting(void *priv,     struct sk_buff *pskb,     const struct nf_hook_state *state)&#123;  return NF_ACCEPT;&#125;\n\n\nunsigned int NET_HookForward(void *priv,     struct sk_buff *pskb,     const struct nf_hook_state *state)&#123;  return NF_ACCEPT;&#125;\n\n\n// 钩子数组static struct nf_hook_ops net_hooks[] = &#123;  &#123;    .hook         = NET_HookLocalIn,        // 发往本地数据包    .pf            = PF_INET,    .hooknum    =    NF_INET_LOCAL_IN,    .priority    = NF_IP_PRI_FILTER-1,  &#125;,  &#123;    .hook         = NET_HookLocalOut,        // 本地发出数据包    .pf            = PF_INET,    .hooknum    =    NF_INET_LOCAL_OUT,    .priority    = NF_IP_PRI_FILTER-1,  &#125;,  &#123;    .hook         = NET_HookForward,        // 转发的数据包    .pf            = PF_INET,    .hooknum    =    NF_INET_FORWARD,    .priority    = NF_IP_PRI_FILTER-1,  &#125;,  &#123;    .hook        = NET_HookPreRouting,    // 进入本机路由前        .pf            = PF_INET,                    .hooknum    = NF_INET_PRE_ROUTING,            .priority    = NF_IP_PRI_FILTER-1,          &#125;,  &#123;    .hook        = NET_HookPostRouting,    // 本机发出包经路由后        .pf            = PF_INET,                    .hooknum    = NF_INET_POST_ROUTING,            .priority    = NF_IP_PRI_FILTER-1,          &#125;,&#125;;\n\n\nint my_open(struct inode *inode, struct file *file);int my_release(struct inode *inode, struct file *file);ssize_t my_read(struct file *file, char __user *user, size_t t, loff_t *f);ssize_t my_write(struct file *file, const char __user *user, size_t t, loff_t *f);char* devName = &quot;IPDataSet&quot;;//设备名struct file_operations pStruct =&#123; open:my_open,      release:my_release,      read:my_read,      write:my_write, &#125;;//打开int my_open(struct inode *inode, struct file *file)&#123;  printk(&quot;open lgsDrive OK!\\n&quot;);  try_module_get(THIS_MODULE);  return 0;&#125;//关闭int my_release(struct inode *inode, struct file *file)&#123;  printk(&quot;Device released!\\n&quot;);  module_put(THIS_MODULE);  return 0;&#125;\n\n\n//读设备里的信息ssize_t my_read(struct file *file, char __user *user, size_t t, loff_t *f)&#123;  roc_dump(&amp;root);  if(copy_to_user(user,message,t))  &#123;    return -2;  &#125;  return sizeof(message);&#125;//向设备里写信息ssize_t my_write(struct file *file, const char __user *user, size_t t, loff_t *f)&#123;  if(copy_from_user(message,user,t))  &#123;    return -3;  &#125;  return sizeof(message);&#125;\n\n\nstatic struct class *drv_class = NULL;int major = 0;//设备号static int __init nf_init(void) &#123;  int ret = 0;  //char device  major = register_chrdev(0, &quot;ipdataset_drv&quot;, &amp;pStruct);  drv_class = class_create(THIS_MODULE, &quot;ipdataset_drv&quot;);  device_create(drv_class, NULL, MKDEV(major, 0), NULL, devName);  //    ret = register_chrdev(0, devName, &amp;pStruct);  //    if (ret &lt; 0)  //    &#123;  //        printk(&quot;failed to register_chrdev.\\n&quot;);  //        return -1;  //    &#125;  //    else  //    &#123;  //        printk(&quot;the lgsDrive has been registered!\\n&quot;);  //        printk(&quot;id: %d\\n&quot;, ret);  //        device_num = ret;  //   //        return 0;  //    &#125;  //net device  ret = nf_register_net_hook(&amp;init_net, net_hooks);  //ret = nf_register_hooks(net_hooks,ARRAY_SIZE(net_hooks));    // 安装钩子  if(ret)  &#123;    printk(KERN_ERR &quot;register hook failed\\n&quot;);    return -1;  &#125;  printk(&quot;Start...\\n&quot;);  return 0;&#125;void close(void)&#123;  roc_destroy(&amp;root, roc_free);&#125;static void __exit nf_exit(void)&#123;  close();  unregister_chrdev(major, &quot;ipdataset_drv&quot;);  device_destroy(drv_class, MKDEV(major, 0));  class_destroy(drv_class);  //unregister_chrdev(device_num, devName);\n\n\n  nf_unregister_net_hook(&amp;init_net, net_hooks);  //nf_unregister_hooks(net_hooks,ARRAY_SIZE(net_hooks));    // 卸载钩子  printk(&quot;Exit...\\n&quot;);&#125;\n\n\n\nmodule_init(nf_init);module_exit(nf_exit);\n\n\n\n\n\nMODULE_LICENSE(&quot;Dual BSD/GPL&quot;);MODULE_AUTHOR(&quot;dianwoshishi&quot;);MODULE_DESCRIPTION(&quot;Netfilter IP Statistic&quot;);MODULE_VERSION(&quot;1.0.1&quot;);MODULE_ALIAS(&quot;Netfilter 01&quot;);\n\n\n用户代码上述字符型设备创建了一个字符节点为：&#x2F;dev&#x2F;IPDataSet， 在用户态程序中，我们通过Linux编程中提供的read函数对驱动中的数据message进行读取。代码如下：\n   #include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#define MAX_SIZE 1024 char message[MAX_SIZE] ;  //打开设备时会显示的消息int main(int num, char *arg[])&#123;    if(2 != num)&#123;        printf(&quot;Usage: %s /dev/IPDataSet\\n&quot;, arg[0]);        return -1;    &#125;    int fd = open(arg[1], O_RDWR);    if(0 &gt; fd)&#123;        perror(&quot;open&quot;);        return -1;    &#125;    int ret = read(fd, message, MAX_SIZE);    printf(&quot;read: ret = %d. %s\\n&quot;, ret, message);    memset(message, 0, MAX_SIZE);    ret = write(fd, message, MAX_SIZE);    printf(&quot;write: ret = %d.\\n&quot;, ret);    close(fd);    return 0;&#125;\n\n\n总结\nLinux 驱动熟悉Linux驱动的编写流程。 了解了Linux内核代码与用户代码的不同，比较明显的就是缺少了类似C++ STL类似的好用的库，只能使用类似红黑树（rbtree)这样的数据结构来做一些set的操作，需要对红黑树有一定的了解。网络设备驱动和字符型设备驱动的编写结构都差不多，但是目前也是一知半解，尤其是一些简单操作之外的特性还不了解，例如加锁？多线程？不知道\n\nLinux内核Linux内核的设计模式还是比较令人佩服的，虽然不懂全貌，但是也能从局部出发，贡献一些力量。再一次感受到了设计的魅力。\n\n其他一定要在虚拟机中编写、测试驱动，不知道有什么错出现，你就要重启你的电脑，boring！\n\n参考资料linux驱动编写（总结篇）,https://blog.csdn.net/feixiaoxing/article/details/79913476?spm=1001.2014.3001.5506智能路由器设备流量、网速统计及上下线提醒（基于netfilter编程）,https://blog.csdn.net/u012819339/article/details/50513387?spm=1001.2014.3001.5506利用Linux内核模块Netfilter hook UDP报文, https://blog.csdn.net/qq_41791640/article/details/104933006?spm=1001.2014.3001.5506Netfilter的使用和实现, https://blog.csdn.net/zhangskd/article/details/22678659?spm=1001.2014.3001.5506\n","slug":"基于netfilter的IP数据统计设计与Linux驱动实现","date":"2022-02-26T04:40:08.436Z","categories_index":"编程开发","tags_index":"Linux,netfilter,内核","author_index":"明说网络"},{"id":"dfc0a69891447bc4e3dfea1542d0fbf1","title":"传输层安全协议真（TLS）的安全吗？","content":"传输层安全协议真（TLS）的安全吗？随着数字通信，计算机网络，公钥密码体制等技术的迅速发展，安全网络通信已经成为了人们的日常需求。TLS 作为目前被广泛应用的安全通信协议之一，被广泛使用于日常生活中，如HTTPS，DNS over TLS等等。但是TLS真的安全吗？他能有效的保护我们的隐私吗？\nTLS基础TLS是什么？传输层安全协议（Transport Layer Security，TLS）：TLS标准由互联网工程任务组（IETF）TLS工作组制定和维护。TLS在TCP&#x2F;IP协议栈上运行，用于保护web流量（使用HTTPS）、文件传输、电子邮件传输和许多其他应用程序。迄今为止，已有两个版本的SSL（SSL v2和SSL v3）和三个版本的TLS（TLS 1.0、TLS 1.1和TLS 1.2）；下一个版本TLS 1.3已于2018年8月发布。\nTLS用于保护许多应用程序。很多人最为熟悉的TLS使用场景是用于保护通过超文本传输协议（HTTP）传输的web流量。在HTTPS中，建立SSL&#x2F;TLS连接（通常在TCP端口443上，与不安全网站的端口80不同），然后HTTP数据通过安全连接传输。TLS还可用于保护电子邮件传输协议（IMAP和POP，用于客户端从邮件服务器下载邮件，SMTP用于发送邮件），以及文件传输（FTP）。在这些场景中，不安全连接被“升级”为安全连接，用于保护人们的隐私和通信数据安全。\nTLS历史SSL协议由Netscape公司开发，历史可以追溯到Netscape Navigator浏览器统治互联网的时代。协议的第一个版本从未发布过，\n第二版则于1994年11月发布。第一次部署是在Netscape Navigator 1.1浏览器上，发行于1995年3月。SSL 2的开发基本上没有与Netscape以外的安全专家进行过商讨，所以有严重的弱点，被认为是失败的协议，最终退出了历史的舞台。\n这次失败使Netscape专注于SSL 3，并于1995年年底发布。虽然名称与早先的协议版本相同，但SSL 3是完全重新设计的协议。该设计一直沿用到今天。\n1996年5月，TLS工作组成立，开始将SSL从Netscape迁移至IETF。由于Microsoft和Netscape当时正在为Web的统治权争得不可开交，整个迁移过程进行得非常缓慢、艰难。最终，TLS 1.0于1999年1月问世，见RFC 2246。尽管与SSL 3相比，版本修改并不大，但是为了取悦Microsoft，协议还是进行了更名[插图]。\n直到2006年4月，下一个版本TLS 1.1才问世，仅仅修复了一些关键的安全问题。然而，协议的重要更改是作为TLS扩展于2003年6月发布的，并被集成到了协议中，这比大家的预期早了好几年。\n2008年8月，TLS 1.2发布。该版本添加了对已验证加密的支持，并且基本上删除了协议说明中所有硬编码的安全基元，使协议完全弹性化。\n当前最新版本的TLS协议为TLSv1.3，已于2018年有IETF正式发布。\n\n\n\nProtocol\nPublished\nStatus\n\n\n\n——–\n———–\n————————————————————\n\n\nSSL 1.0\nUnpublished\nUnpublished\n\n\nSSL 2.0\n1995\nDeprecated in 2011\n\n\nSSL 3.0\n1996\nDeprecated in 2015\n\n\nTLS 1.0\n1999\nDeprecated in 2020\n\n\nTLS 1.1\n2006\nDeprecated in 2020, in 2021 Chrome will not load websites with TLS 1.0 or 1.1.\n\n\nTLS 1.2\n2008\n\n\n\nTLS 1.3\n2018\n\n\n\nTLS组成协议TLS的主规格说明书定义了四个核心子协议：握手协议（handshake protocol）、密钥规格变更协议（change cipher spec protocol）、应用数据协议（application data protocol）和警报协议（alert protocol）。\n出于加密目的，两个最重要的子协议是握手协议和记录层协议。\nSSL握手协议握手是TLS协议中最精密复杂的部分。在握手协议中，客户机和服务器商定一组称为密码套件的加密参数，交换身份验证凭据，建立共享机密，执行显式身份验证，并派生用于批量加密和消息验证的密钥。\n\nFigure 1.3.1: 握手协议\n握手过程分为4个阶段：\n\n初始化逻辑连接，客户方先发出ClientHello消息，服务器方也应返回一个ServerHello消息，这两个消息用来协商双方的安全能力，包括协议版本、随机参数、会话ID、交换密钥算法、对称加密算法、压缩算法等。\n\n\n\n\n\n\n\n\n\n\n\n\nclienthello消息示例\n\n服务器方应发送服务器证书Certificate（包含了服务器的公钥等）和服务端会话密钥(Serverkeyexchange)，如果服务器要求验证客户方，则要发送CertificateRequest消息。最后服务器方发送ServerHelloDone消息，表示hello阶段结束，服务器等待客户方的响应。\n如果服务器要求验证客户方，则客户方先发送客户端证书Certificate消息，然后产生客户端会话密钥，并用服务器的公钥加密，封装在ClientKeyExchange消息中，如果客户方发送了自己的证书，则再发送一个数字签名CertificateVerify来对证书进行校验。\n客户方发送一个ChangeCipherSpec消息，通知服务器以后发送的消息将采用先前协商好的安全参数加密，最后再发送一个加密后的Finished消息。服务器在收到上述两个消息后，也发送自己的ChangeCipherSpec消息和Finished消息。至此，握手全部完成，双方可以开始传输应用数据。\n\n会话恢复\n完整的握手协议非常复杂，需要很多握手消息和两次网络往返才能开始发送客户端应用数据。此外，握手执行的密钥学操作通常需要密集的CPU处理。因此建立一次握手的代价很昂贵，于是短时间中断的连接可以使用会话恢复快速恢复。\n最初的会话恢复机制是，在一次完整协商的连接断开时，客户端和服务器都会将会话的安全参数保存一段时间。希望使用会话恢复的服务器为会话指定唯一的标识，称为会话ID。服务器在ServerHello消息中将会话ID发回客户端。希望恢复早先会话的客户端将适当的会话ID放入ClientHello消息，然后提交。服务器如果愿意恢复会话，就将相同的会话ID放入ServerHello消息返回，接着使用之前协商的主密钥生成一套新的密钥，再切换到加密模式，发送Finished消息。客户端收到会话已恢复的消息以后，也进行相同的操作。这样的结果是握手只需要一次网络往返。\n\n简短握手，用于恢复已经建立的会话\nTLS中的密码交换算法\n最常用的密钥交换算法概览\n使用哪一种密钥交换由协商的套件所决定。\n记录层协议记录层协议提供TLS中所有消息的传递，包括握手协议消息和应用程序数据，但特别是记录层协议可以选择使用身份验证和加密来保护消息。还有一个附加的警报协议，用于通知对等方错误或关闭连接。 SSL记录协议从高层接收到数据后要经过分段、压缩和加密处理，最后由传输层发送出去。在SSL协议中，所有的传输数据都被封装在记录中，SSL记录协议规定了记录头和记录数据的格式。\n总之，经过上述两个协议，客户端和服务器通过公钥密码体制协商通信时使用的对称加密体制秘钥，然后使用对称加密体制对通信数据进行加密处理。这样，通信数据就可以“安全”的在网络中进行传输。\n其他协议当然了，除了上述最重要的两个协议之外，还有一些其他的协议，例如警告协议，心跳协议等等。\n警报的目的是以简单的通知机制告知对端通信出现异常状况。发送警告通知的一端不会主动终止连接，而是交由接收端通过发送它自己的严重警报对该警告自行作出反应。\n心跳（Heartbeat）是一个协议扩展，添加了支持连接保活的功能（检查对端是否仍然可用），以及为TLS和DTLS发现路径最大传输单元（path maximumtransmission unit, PMTU）\nSSL&#x2F;TLS安全吗？TLS 的发展有 20 多年的历史，在之前的版本中，TLS 1.2 是高度可配置的，为了更好的兼容旧版本的浏览器，这意味着那些易受攻击的站点始终在运行着不安全的加密算法，这让互联网黑客有可乘之机。\n协议漏洞经典攻击以下是TLS&#x2F;SSL协议中的主要漏洞。它们都会影响协议的旧版本（TLSv1.2及更早版本）。\n\nPOODLE（Padding Oracle On Downgraded Legacy Encryption）,(CVE-2014-3566)\nBEAST（Browser Exploit Against SSL&#x2F;TLS ）(CVE-2011-3389)\nCRIME (Compression Ratio Info-leak Made Easy) (CVE-2012-4929)\nBREACH（Browser Reconnaissance and Exfiltration via Adaptive Compression of Hypertext） (CVE-2013-3587.)\nHeartbleed (CVE-2014-0160.)\n\n详细的一些介绍看这里[这里[1]]:https://www.acunetix.com/blog/articles/tls-vulnerabilities-attacks-final-part/\n不安全因素这些主要漏洞中，的一些不安全的因素：\n\nRSA 密钥传输 —— 不支持前向安全性\nCBC 模式密码 —— 易受 BEAST 和 Lucky 13 攻击\nRC4 流密码 —— 在 HTTPS 中使用并不安全\nSHA-1 哈希函数 —— 建议以 SHA-2 取而代之\n任意 Diffie-Hellman 组—— CVE-2016-0701 漏洞\n输出密码 —— 易受 FREAK 和 LogJam 攻击\n\n部署安全虽然SSL&#x2F;TLS协议用于保护数据传输，但配置不当的服务器可能会暴露数据而不是保护数据。\n\n中间人攻击：如middlebox（如部分杀毒软件会作为中间人，解密用户数据，进行恶意审查；不安全的CA及不可验证的数字证书链等）的广泛部署\n误配置：如使用已经被证明不安全的协议（TLSv1.1之前的版本），支持不安全的密码套件（RC4，MD5等）等。\n\n根据SSL Labs的统计信息，如下图所示，即使许多的SSL&#x2F;TLS已经被证明不安全，但是由于各种原因，例如管理员疏忽、配置错误、机器升级障碍等问题，目前仍然存在大量不安全的SSL&#x2F;TLS协议在使用当中。\n\nFigure 2.2.1: SSL Labs统计信息\n防御方法在大多数情况下，保护自己免受SSL&#x2F;TLS相关攻击的最佳方法是禁用旧的协议版本。这甚至是一些行业的标准要求。例如看看下面几个业界的动态就知道低版本 TLS 的现状了。\n\nGitHub 于 2018 年 2 月 1 日起，禁用 TLSv1 和 TLSv1.1。\nSalesforce 于 2018 年 3 月 逐步禁用 TLSv1。\n微信小程序要求的 TLS 版本必须大于等于 1.2。\n为了符合支付卡行业数据安全标准（PCI DSS）并符合行业最佳实践，GlobalSign 将在 2018 年 6 月 21 日禁用 TLS 1 和 TLS 1.1 。\n\n选择的协议级别越高，相应的也就更安全。\n同时，将目前计算机上部署的TLS版本更新到最新，可有效防止此类问题，目前安全的版本为TLSv1.3。\nTLSv1.3下图是TLS完整的握手过程\n\nFigure 3.1: SSL Labs统计信息\n与TLSv1.2主要的不同，TLSv1.3进行了很多改进，改进力度还是比较大。如上图所示，握手过程明显比TLS之前版本更少的握手次数，，甚至是0次（zero round trip time (0-RTT)）可以更快的建联，简化了握手机制。\n同时，不再兼容一些不安全的密码算法，甚至是不安全的前向兼容.\n总结总的来说，当前TLS是广泛使用的安全通信协议，安全性在整个互联网界的共同努力下，逐步提升，可以保证用户数据和隐私的安全。但是由于其历史、兼容性、实现以及部署等原因，在实际使用过程中产生了一些安全的问题，但是很快就会被打上补丁。因此，只要能够及时打上TLS的补丁，升级支持最新版的协议，禁用旧的版本，就能够有效地保护数据隐私和通信安全。\n参考资料《HTTPS权威指南：在服务器和Web应用上部署SSL&#x2F;TLS和PKI》\n","slug":"传输层安全协议真（TLS）的安全吗？","date":"2022-02-26T04:40:06.963Z","categories_index":"","tags_index":"","author_index":"明说网络"},{"id":"422918ab17fac2b9611905dfbc28c6cc","title":"从hello world开始，拆解函数栈结构","content":"从hello world开始，拆解字符串常量的存储位置第一个程序helloworld编写程序首先我们有如下程序：main.c\n//main.c\n#include &lt;stdio.h>\nint display(char *name)&#123;\n\n    printf(\"hello world! %s\\n\", name);\n&#125;\nchar *g_pstr = \"global_I'm a string\\n\";\nint \nmain()&#123;\n    char *pname = \"III'm a stringI'm a stringII'm a stringI'm a stringII'm a stringI'm a stringII'm a stringI'm a stringII'm a stringI'm a stringII'm a stringI'm a stringII'm a stringI'm a stringII'm a stringI'm a stringII'm a stringI'm a stringII'm a stringI'm a stringI'm a stringI'm a string\";\n    puts(pname);\n    puts(g_pstr);\n    char name[256] = \"local_string_I'm a string\"; \n    display(name);\n    return 0;\n&#125;\n\n上述程序实现的功能很简单，就是输出三个字符串pname，g_pstr和name，为了便于说明，其中故意使用了一个函数调用int display(char *)。\n函数的逻辑为，main函数–&gt; display()函数(一个参数)–&gt;printf函数(两个参数)。\n是不是很简单！\n程序编译makefile为了便于说明，我们使用makefile文件进行编译。创建文件名为makefile的文件，内容如下：\n# makefile\nOBJ=printf.main\n\n$(OBJ):\n    gcc main.c -o $@\n\nclean:\n    -rm $(OBJ)\n\n我们生成的文件名为printf.main，这里你可以改为你喜欢的任意名称。\n使用make命令进行编译，会生成最终文件。运行后就可以看见输出。\n提出问题我们想要知道字符串常量在程序运行中存储的位置\n分析问题我们通过命令objdump -d ./printf.main, 查看相应的汇编代码。如下所示，定位到关键步骤，关键步骤已经使用‘#’注释\n.&#x2F;printf.main:     file format elf64-x86-64\n\n00000000004005d6 &lt;display&gt;:\n  4005d6:    55                       push   %rbp\n  4005d7:    48 89 e5                 mov    %rsp,%rbp\n  4005da:    48 83 ec 10              sub    $0x10,%rsp\n  4005de:    48 89 7d f8              mov    %rdi,-0x8(%rbp)\n  4005e2:    48 8b 45 f8              mov    -0x8(%rbp),%rax\n  4005e6:    48 89 c6                 mov    %rax,%rsi\n  4005e9:    bf 48 07 40 00           mov    $0x400748,%edi\n  4005ee:    b8 00 00 00 00           mov    $0x0,%eax\n  4005f3:    e8 b8 fe ff ff           callq  4004b0 &lt;printf@plt&gt;\n  4005f8:    90                       nop\n  4005f9:    c9                       leaveq \n  4005fa:    c3                       retq   \n\n00000000004005fb &lt;main&gt;:\n  4005fb:    55                       push   %rbp\n  4005fc:    48 89 e5                 mov    %rsp,%rbp\n  4005ff:    48 81 ec 20 01 00 00     sub    $0x120,%rsp\n  400606:    64 48 8b 04 25 28 00     mov    %fs:0x28,%rax\n  40060d:    00 00 \n  40060f:    48 89 45 f8              mov    %rax,-0x8(%rbp)\n  400613:    31 c0                    xor    %eax,%eax\n  400615:    48 c7 85 e8 fe ff ff     movq   $0x400770,-0x118(%rbp)            # 0x400770作为pname的地址\n  40061c:    70 07 40 00 \n  400620:    48 8b 85 e8 fe ff ff     mov    -0x118(%rbp),%rax\n  400627:    48 89 c7                 mov    %rax,%rdi\n  40062a:    e8 61 fe ff ff           callq  400490 &lt;puts@plt&gt;\n  40062f:    48 8b 05 12 0a 20 00     mov    0x200a12(%rip),%rax        # 601048 &lt;g_pstr&gt;\n  400636:    48 89 c7                 mov    %rax,%rdi\n  400639:    e8 52 fe ff ff           callq  400490 &lt;puts@plt&gt;\n  40063e:    48 b8 6c 6f 63 61 6c     movabs $0x74735f6c61636f6c,%rax        #‘local_st’ &quot;local_string_I&#39;m a string&quot;变量以常量整型的方式进行复制。\n  400645:    5f 73 74 \n  400648:    48 89 85 f0 fe ff ff     mov    %rax,-0x110(%rbp)\n  40064f:    48 b8 72 69 6e 67 5f     movabs $0x6d27495f676e6972,%rax  # ‘ring_I&#39;m’\n  400656:    49 27 6d \n  400659:    48 89 85 f8 fe ff ff     mov    %rax,-0x108(%rbp)\n  400660:    48 b8 20 61 20 73 74     movabs $0x6e69727473206120,%rax\n  400667:    72 69 6e \n  40066a:    48 89 85 00 ff ff ff     mov    %rax,-0x100(%rbp)\n  400671:    48 c7 85 08 ff ff ff     movq   $0x67,-0xf8(%rbp)\n  400678:    67 00 00 00 \n  40067c:    48 8d 95 10 ff ff ff     lea    -0xf0(%rbp),%rdx\n  400683:    b8 00 00 00 00           mov    $0x0,%eax\n  400688:    b9 1c 00 00 00           mov    $0x1c,%ecx\n  40068d:    48 89 d7                 mov    %rdx,%rdi\n  400690:    f3 48 ab                 rep stos %rax,%es:(%rdi)\n  400693:    48 8d 85 f0 fe ff ff     lea    -0x110(%rbp),%rax\n  40069a:    48 89 c7                 mov    %rax,%rdi\n  40069d:    e8 34 ff ff ff           callq  4005d6 &lt;display&gt;\n  4006a2:    b8 00 00 00 00           mov    $0x0,%eax\n  4006a7:    48 8b 75 f8              mov    -0x8(%rbp),%rsi\n  4006ab:    64 48 33 34 25 28 00     xor    %fs:0x28,%rsi\n  4006b2:    00 00 \n  4006b4:    74 05                    je     4006bb &lt;main+0xc0&gt;\n  4006b6:    e8 e5 fd ff ff           callq  4004a0 &lt;__stack_chk_fail@plt&gt;\n  4006bb:    c9                       leaveq \n  4006bc:    c3                       retq   \n  4006bd:    0f 1f 00                 nopl   (%rax)\n\n第一个pname参数400615:    48 c7 85 e8 fe ff ff     movq   $0x400770,-0x118(%rbp)            # 0x400770作为pname的地址\n40061c:    70 07 40 00 \n400620:    48 8b 85 e8 fe ff ff     mov    -0x118(%rbp),%rax\n400627:    48 89 c7                 mov    %rax,%rdi\n40062a:    e8 61 fe ff ff           callq  400490 &lt;puts@plt&gt;\n\n![image-20210720102416074](从hello world开始，复习C语言知识——字符串常亮&#x2F;image-20210720102416074.png)\n查看地址0x400770，得到字符串。\n第二个参数g_pstr40062f:    48 8b 05 12 0a 20 00     mov    0x200a12(%rip),%rax        # 601048 &lt;g_pstr&gt;\n400636:    48 89 c7                 mov    %rax,%rdi\n400639:    e8 52 fe ff ff           callq  400490 &lt;puts@plt&gt;\n\n![image-20210720102733348](从hello world开始，复习C语言知识——字符串常亮&#x2F;image-20210720102733348.png)\n查看地址0x400759，得到地址\n第三个参数字符串常量40063e:    48 b8 6c 6f 63 61 6c     movabs $0x74735f6c61636f6c,%rax        #‘local_st’ &quot;local_string_I&#39;m a string&quot;变量以常量整型的方式进行复制。\n400645:    5f 73 74 \n400648:    48 89 85 f0 fe ff ff     mov    %rax,-0x110(%rbp)\n40064f:    48 b8 72 69 6e 67 5f     movabs $0x6d27495f676e6972,%rax  # ‘ring_I&#39;m’\n400656:    49 27 6d \n400659:    48 89 85 f8 fe ff ff     mov    %rax,-0x108(%rbp)\n400660:    48 b8 20 61 20 73 74     movabs $0x6e69727473206120,%rax\n400667:    72 69 6e \n40066a:    48 89 85 00 ff ff ff     mov    %rax,-0x100(%rbp)\n400671:    48 c7 85 08 ff ff ff     movq   $0x67,-0xf8(%rbp)\n400678:    67 00 00 00 \n40067c:    48 8d 95 10 ff ff ff     lea    -0xf0(%rbp),%rdx\n400683:    b8 00 00 00 00           mov    $0x0,%eax\n\n0x74735f6c61636f6c -&gt; 为字符串”local_st“\n0x6d27495f676e6972-&gt;为字符串”ring_I’m“\n其他等等\n得到字符串。\n思考全局变量和只有引用的字符串常量，使用rodata数据区存储其值全局变量g_pstr和pname所指向的地址，均为.rodata，意思是read only。从以下IDA pro的结果中我们也能看出来。\n![image-20210720143206385](从hello world开始，复习C语言知识——字符串常亮&#x2F;image-20210720143206385.png)\n能够实现赋值初始化的字符串常量，由编译器优化，使用整型常量的方式复制到栈上，不占用rodata空间对于char name[256] = &quot;local_string_I&#39;m a string&quot;; 实现的赋值语句，其常量是以整型的方式存储，然后赋值到栈上的name变量中。实际上，这是编译器帮助我们实现了这个步骤。\n为了确认这一事实，我们做如下实验：\n使用char name[256] = &quot;llocal_string_I&#39;m a stringlocal_string_I&#39;m a stringlocal_string_I&#39;m a stringlocal_string_I&#39;m a stringocal_string_I&#39;m a string&quot;;进行试验，得到如下结果。\n![image-20210720143749564](从hello world开始，复习C语言知识——字符串常亮&#x2F;image-20210720143749564.png)\n可以看出，确实是将字符串拆解为整型常量，然后赋值到栈空间上。\n总结其他的常量也可以依次类推。\n一般我们的理解都是字符串常量都是放在rodata中，但是通过汇编代码，我们可以清晰的看出，当字符串常量初始化给一个数组时，字符串常量并不会放在rodata中，二是将字符串常量转化为多个整型常量，然后在运行时直接复制到栈上。\n","slug":"从hello world开始，拆解字符串常量的存储位置","date":"2022-02-26T04:40:06.930Z","categories_index":"编程开发","tags_index":"C语言 - 汇编 - 逆向 - CTF","author_index":"明说网络"},{"id":"cca119383a62ab6c2d67564c0f149f86","title":"“黑客”组织仍在积极重新调整其恶意软件库","content":"“黑客”组织仍在积极重新调整其恶意软件库\n摘要臭名昭著的TrickBot恶意软件与一种名为Diavol的新勒索软件有关联。\n正文根据Fortinet的FortiGuard实验室的研究人员，本月初针对其一个客户的攻击中，Diavol和Conti勒索软件的有效载荷(payloads)被部署在不同的系统上。\nTrickBot银行木马是一种基于Windows的犯罪软件，在目标网络上采用不同的模块达到恶意行为，包括盗取凭证和进行勒索软件攻击。\n据信，迄今为止，Diavol已经在被部署在实际环境中。即使不知道入侵来源，但该有效载荷的源代码与Conti的代码有相似之处，甚至其赎金说明文字与Egregor勒索软件的一些语言重复。\n技术研究人员表示，Diavol使用用户模式的无对称加密算法、异步程序调用（APC）运行。通常情况下，勒索软件开发者的目标是在最短的时间内完成加密操作。非对称加密算法要比对称算法慢得多。\n该勒索软件的另一个方面是它依靠一种反分析技术，以位图图像的形式混淆其代码，从那里将例程加载到具有执行权限的缓冲区。\n在锁定文件和用赎金信息改变桌面壁纸之前，Diavol还执行其他功能，如在远程服务器上注册受害者设备，终止运行中的进程，在系统中寻找本地驱动器和文件进行加密，并通过删除shadow副本防止恢复。\n结论正如Kryptos Logic威胁情报团队所详述的那样，Wizard Spider勒索软件发展也与 “TrickBot webinject 模块的新发展 “相吻合，表明该组织仍在积极重新调整其恶意软件库。\n","slug":"“黑客”组织仍在积极重新调整其恶意软件库","date":"2022-02-26T04:40:06.568Z","categories_index":"","tags_index":"","author_index":"明说网络"},{"id":"cca00432e478abca505909e6f879fd41","title":"C语言回头看--诡异的i++和++i","content":"C语言回头看–诡异的i++和++iC语言中的i++和++i使用非常的方便，简单明了。但是很多人在学习C语言的过程中，对这两个语句还是存在恐惧，因为这两条语句会引起不必要的麻烦。例如：到底是先用再加，还是先加再用？ 同时在一些程序语句中也会出现一些令人意想不到的结果，例如i=1,((++i)+(++i))=6的情况，非常的诡异。\n因此本文针对这个问题，深入到汇编层面，理解双胞胎i++和++i的故事。相信通过本文，你能够更加深刻的理解C语言中的自加自减等操作。\n例子介绍本文所用程序C语言文件如下所示，逻辑为：分别输出i++和++i的结果。\n#include &lt;stdio.h&gt;\n\nint main()&#123;\n    int i &#x3D; 0;\n    printf(&quot;i &#x3D; 0,++i &#x3D; %d\\n&quot;, ++i);\n    i &#x3D; 0;\n\n    printf(&quot;i &#x3D; 0,i++ &#x3D; %d\\n&quot;, i++);\n\n\n\n    i &#x3D; 1;\n    printf(&quot;i &#x3D; 1,(i++)+(++i) &#x3D; %d\\n&quot;, (i++)+(++i));\n\n\n    i &#x3D; 1;\n    printf(&quot;i &#x3D; 1,(++i)+(i++) &#x3D; %d\\n&quot;, (++i)+(i++));\n\n    i &#x3D; 1;\n    printf(&quot;i &#x3D; 1,(++i)+(++i) &#x3D; %d\\n&quot;, (++i)+(++i));\n\n    return 0;\n&#125;\n\n使用make进行构建，makefile如下所示\nOBJ=selfincre\n\n$(OBJ):\n    g++ -Wall main.c -o $@\n\nclean:\n    -rm -rf $(OBJ)\n\n本机所用的环境如下所示：\nUbuntu 16.04 (64位，内核版本4.15.0-142-generic）\ngcc version 5.4.0 20160609 (Ubuntu 5.4.0-6ubuntu1~16.04.12)\nmake：GNU Make 4.1，Built for x86_64-pc-linux-gnu\n\n结果如下：\n\n汇编分析在ubuntu中我们使用objdump ~d ./selfincre &gt; objdump.txt，将程序进行反汇编，我们将不重要的信息剔除，只保留main函数，如下所示，在部分汇编语句中进行了注释，可以结合‘餐食’。\n.&#x2F;selfincre:     file format elf64-x86-64\n\n0000000000400526 &lt;main&gt;:\n  400526:    55                       push   %rbp\n  400527:    48 89 e5                 mov    %rsp,%rbp\n  40052a:    48 83 ec 10              sub    $0x10,%rsp\n  40052e:    c7 45 fc 00 00 00 00     movl   $0x0,-0x4(%rbp) # -0x4(%rbp) 是局部变量i，本操作为赋值为0\n  400535:    83 45 fc 01              addl   $0x1,-0x4(%rbp) # i + 1\n  400539:    8b 45 fc                 mov    -0x4(%rbp),%eax # 将i放入eax\n  40053c:    89 c6                    mov    %eax,%esi                # 将eax复制给esi，作为printf的第一个参数\n  40053e:    bf 04 06 40 00           mov    $0x400604,%edi\n  400543:    b8 00 00 00 00           mov    $0x0,%eax\n  400548:    e8 b3 fe ff ff           callq  400400 &lt;printf@plt&gt;\n  40054d:    c7 45 fc 00 00 00 00     movl   $0x0,-0x4(%rbp)    ## -0x4(%rbp) 是局部变量i，本操作为赋值为0\n  400554:    8b 45 fc                 mov    -0x4(%rbp),%eax    ## i赋值给eax\n  400557:    8d 50 01                 lea    0x1(%rax),%edx                    ## 取rax的值加一（注意：rax本身并没有+1)，并赋值给edx\n  40055a:    89 55 fc                 mov    %edx,-0x4(%rbp)                ## 将edx赋值给局部变量i\n  40055d:    89 c6                    mov    %eax,%esi                ## 注意这里的eax并没有进行+1操作，所以值自赋值为0后并未改变，作为printf的第一个参数\n  40055f:    bf 0e 06 40 00           mov    $0x40060e,%edi\n  400564:    b8 00 00 00 00           mov    $0x0,%eax\n  400569:    e8 92 fe ff ff           callq  400400 &lt;printf@plt&gt;\n  40056e:    b8 00 00 00 00           mov    $0x0,%eax\n  400573:    c9                       leaveq \n  400574:    c3                       retq   \n  400575:    66 2e 0f 1f 84 00 00     nopw   %cs:0x0(%rax,%rax,1)\n  40057c:    00 00 00 \n  40057f:    90                       nop\n\n分析++i主要分析一下C代码\n++i;\n\n汇编如下所示：\n  40052e:    c7 45 fc 00 00 00 00     movl   $0x0,-0x4(%rbp) # -0x4(%rbp) 是局部变量i，本操作为赋值为0\n400535:    83 45 fc 01              addl   $0x1,-0x4(%rbp) # i + 1\n400539:    8b 45 fc                 mov    -0x4(%rbp),%eax # 将i放入eax\n40053c:    89 c6                    mov    %eax,%esi                # 将eax复制给esi，作为printf的第一个参数\n40053e:    bf 04 06 40 00           mov    $0x400604,%edi\n400543:    b8 00 00 00 00           mov    $0x0,%eax\n400548:    e8 b3 fe ff ff           callq  400400 &lt;printf@plt&gt;\n\n++i正如字面的意思一样，先加后用！\n其加一汇编操作，均在-0x4(%rbp)进行，加一操作为addl   $0x1,-0x4(%rbp)，因此++i直接造成的结果就是i的改变。\n分析i++C代码如下\ni++;\n\n汇编如下所示：\n40054d:    c7 45 fc 00 00 00 00     movl   $0x0,-0x4(%rbp)    ## -0x4(%rbp) 是局部变量i，本操作为赋值为0\n400554:    8b 45 fc                 mov    -0x4(%rbp),%eax    ## i赋值给eax\n400557:    8d 50 01                 lea    0x1(%rax),%edx                    ## 取rax的值加一（注意：rax本身并没有+1)，并赋值给edx\n40055a:    89 55 fc                 mov    %edx,-0x4(%rbp)                ## 将edx赋值给局部变量i\n40055d:    89 c6                    mov    %eax,%esi                ## 注意这里的eax并没有进行+1操作，所以值自赋值为0后并未改变，作为printf的第一个参数\n40055f:    bf 0e 06 40 00           mov    $0x40060e,%edi\n400564:    b8 00 00 00 00           mov    $0x0,%eax\n400569:    e8 92 fe ff ff           callq  400400 &lt;printf@plt&gt;\n\ni++正如字面的意思一样，先用后加！\n其加一汇编操作，在寄存器eax的值的基础上进行，加一操作为lea    0x1(%rax),%edx；mov    %edx,-0x4(%rbp)。\n我们可以如下理解i++， 拆分为两句：\ni++     -->     i;i = i + 1\n\ni++相当于：先使用i，在对i进行加一操作。\n\n先使用i：操作为将i的值存储在eax以便在后面使用，eax代表了i++这条语句的结果\n\n对i进行加一操作：lea    0x1(%rax),%edx；mov    %edx,-0x4(%rbp)，加一操作并不影响eax寄存器。\n\n\n因此i++的结果是i，使用的方法是eax寄存器。只不过在使用完i，会有一个加一的操作而已。\n小结++i，先加后用！\ni++，先用后加！\n出现i++，++i这样语句的目的可能在于减少语句操作吧。通过上述字面理解，其实是最快的。\n(i++)+(++i)&#x3D;6？？？示例代码使用如下代码进行分析\ni &#x3D; 1;\nprintf(&quot;i &#x3D; 1,(i++)+(++i) &#x3D; %d\\n&quot;, (i++)+(++i));\n\n\ni &#x3D; 1;\nprintf(&quot;i &#x3D; 1,(++i)+(++i) &#x3D; %d\\n&quot;, (++i)+(++i));\n\n分析(i++)+(++i)首先我们先进行一个简单一些的分析，i = 1;(i++)+(++i) 的结果是多少呢？\n# (i++)+(++i)\n# i &#x3D; 1\n40056e:    c7 45 fc 01 00 00 00     movl   $0x1,-0x4(%rbp)        ## -0x4(%rbp) 就是局部变量i，本操作为赋值为1,i &#x3D; 1\n# i++\n400575:    8b 45 fc                 mov    -0x4(%rbp),%eax        ## eax &#x3D; i &#x3D; 1\n400578:    8d 50 01                 lea    0x1(%rax),%edx            ## 取rax的值加一，赋值给edx\n40057b:    89 55 fc                 mov    %edx,-0x4(%rbp)        ## i &#x3D; edx, 此时i &#x3D; 2\n# ++i\n40057e:    83 45 fc 01              addl   $0x1,-0x4(%rbp)        ## i+ 1 &#x3D; i,此时i &#x3D; 3\n# $1 + $2\n400582:    8b 55 fc                 mov    -0x4(%rbp),%edx        ## i的值赋给edx，也就是3\n400585:    01 d0                    add    %edx,%eax                    ## 执行eax + edx &#x3D; eax 也就是1 + 3 &#x3D; 4\n400587:    89 c6                    mov    %eax,%esi                    ## eax赋给esi，作为printf的第一个参数，也就是4\n400589:    bf 74 06 40 00           mov    $0x400674,%edi\n40058e:    b8 00 00 00 00           mov    $0x0,%eax\n400593:    e8 68 fe ff ff           callq  400400 &lt;printf@plt&gt;\n\n通过第二节的分析，我们知道，其实(i++)+(++i) 的可以看做(i_1 + (++i_2))（i_1是因为此时i_1的值是eax的值，i_1 不等同于i_2，并不随i的值变化）， 再由C语言中表达式的计算是由右到左，所以会先计算++i，然后是再相加。那么结果应该是1 + 2 &#x3D; 3。\n但是，实际结果却是4.为什么呢？\n原因就是在进行++i的时候，虽然后续用的是eax的值，但是这句话（第5行）随后进行的操作改变了-0x4(%rbp)的值（第6、7行）。其本意是-0x4(%rbp)+1，但是此时-0x4(%rbp)的值已经被i++修改过了，为2，所以++i的结果就成为了3。最终两式一加，结果为4.\n分析(++i)+(++i)下面我们分析(++i)+(++i) = 6？\n汇编代码如下所示：\n# (++i)+(++i)\n# i &#x3D; 1\n400598:    c7 45 fc 01 00 00 00     movl   $0x1,-0x4(%rbp)        # -0x4(%rbp) &#x3D; i &#x3D; 1\n#(++i)\n40059f:    83 45 fc 01              addl   $0x1,-0x4(%rbp)        # -0x4(%rbp) &#x3D; i &#x3D; 2\n#(++i)\n4005a3:    83 45 fc 01              addl   $0x1,-0x4(%rbp)        # -0x4(%rbp) &#x3D; i &#x3D; 3\n# $1 + $2\n4005a7:    8b 45 fc                 mov    -0x4(%rbp),%eax        # -0x4(%rbp)赋值给eax， eax &#x3D; 3\n4005aa:    01 c0                    add    %eax,%eax                    # eax + eax &#x3D; 6\n4005ac:    89 c6                    mov    %eax,%esi\n4005ae:    bf 8c 06 40 00           mov    $0x40068c,%edi\n4005b3:    b8 00 00 00 00           mov    $0x0,%eax\n4005b8:    e8 43 fe ff ff           callq  400400 &lt;printf@plt&gt;\n\n经过上一小节的分析，其实这里已经非常简单了，因为两次++i不断的改变-0x4(%rbp)的值，使得-0x4(%rbp)在使用时变成了3，最终两式相加为6.\n练手题目i &#x3D; 1;\nprintf(&quot;i &#x3D; 1,(++i)+(i++) &#x3D; %d\\n&quot;, (++i)+(i++));\n\n400598:    c7 45 fc 01 00 00 00     movl   $0x1,-0x4(%rbp)\n40059f:    83 45 fc 01              addl   $0x1,-0x4(%rbp)\n4005a3:    8b 45 fc                 mov    -0x4(%rbp),%eax\n4005a6:    8d 50 01                 lea    0x1(%rax),%edx\n4005a9:    89 55 fc                 mov    %edx,-0x4(%rbp)\n4005ac:    8b 55 fc                 mov    -0x4(%rbp),%edx\n4005af:    01 d0                    add    %edx,%eax\n4005b1:    89 c6                    mov    %eax,%esi\n4005b3:    bf ac 06 40 00           mov    $0x4006ac,%edi\n4005b8:    b8 00 00 00 00           mov    $0x0,%eax\n4005bd:    e8 3e fe ff ff           callq  400400 &lt;printf@plt&gt;\n\n他的结果是5，通过上述分析，你算对了吗？\n关键提示：\n\nC语言中运行由右至左，所以先算i++，再算++i\ni++和++i的运算过程改变了-0x4(%rbp)的值，所以出现了非预期的结果。\n\n未定义行为虽然这有点复杂，感觉确定性非常的不高。但是不用担心，在C语言的编译过程中，会警告我们，这样的语句中i没有定义。如果你发现这样的问题后，就需要注意了。\n\n下面文章中对这个问题进行了解释，不再赘述。\n\n\n\n\n\n\n\n\n\ni＝1，为什么 (++i)+(++i)＝6？ - CWKSC的回答 - 知乎 https://www.zhihu.com/question/347864795/answer/836263029\n总结\n从汇编角度理解++i和i++，可以更好的得出一些奇奇怪怪的语句的结果，让我们更好的理解C语言，理解编译器。\n一定不建议写这样的语句！一定不建议写这样的语句！一定不建议写这样的语句！请用i += 1这样代替。多写一个字符而已。如果一定要写i++或++i，请将其单独为一个语句，不要进行组合！不要进行组合！不要进行组合！这样，你好我好大家好，不然当某一天你维护的代码出现灵异事件时，就只有祷告了。\n\n&#x3D;&#x3D;&#x3D;&#x3D;\n#include &lt;stdio.h>\nint f()&#123;\n    int i = 1;\n    return i++;\n&#125;\n\nint g()&#123;\n    int i = 1;\n    return i++;\n&#125;\n\nint main()&#123;\n\n    int ret = f() + g();\n\n\n    printf(\"%d\\n\", ret);\n\n    printf(\"%d\\n\", f() + g());\n\n    int a = 1, b = 2, c = 3, d = 4;\n    d = a * b + c * 2;\n    printf(\"%d\\n\", d);\n\n    return 0;\n&#125;\n\n0000000000400526 &lt;_Z1fv&gt;:\n  400526:    55                       push   %rbp\n  400527:    48 89 e5                 mov    %rsp,%rbp\n  40052a:    c7 45 fc 01 00 00 00     movl   $0x1,-0x4(%rbp)\n  400531:    8b 45 fc                 mov    -0x4(%rbp),%eax\n  400534:    8d 50 01                 lea    0x1(%rax),%edx\n  400537:    89 55 fc                 mov    %edx,-0x4(%rbp)\n  40053a:    5d                       pop    %rbp\n  40053b:    c3                       retq   \n\n000000000040053c &lt;_Z1gv&gt;:\n  40053c:    55                       push   %rbp\n  40053d:    48 89 e5                 mov    %rsp,%rbp\n  400540:    c7 45 fc 01 00 00 00     movl   $0x1,-0x4(%rbp)\n  400547:    8b 45 fc                 mov    -0x4(%rbp),%eax\n  40054a:    8d 50 01                 lea    0x1(%rax),%edx\n  40054d:    89 55 fc                 mov    %edx,-0x4(%rbp)\n  400550:    5d                       pop    %rbp\n  400551:    c3                       retq   \n\n0000000000400552 &lt;main&gt;:\n  400552:    55                       push   %rbp\n  400553:    48 89 e5                 mov    %rsp,%rbp\n  400556:    53                       push   %rbx\n  400557:    48 83 ec 28              sub    $0x28,%rsp\n  40055b:    e8 c6 ff ff ff           callq  400526 &lt;_Z1fv&gt;        #f()\n  400560:    89 c3                    mov    %eax,%ebx\n  400562:    e8 d5 ff ff ff           callq  40053c &lt;_Z1gv&gt;        #g()\n  400567:    01 d8                    add    %ebx,%eax\n  400569:    89 45 dc                 mov    %eax,-0x24(%rbp)\n  40056c:    8b 45 dc                 mov    -0x24(%rbp),%eax\n  40056f:    89 c6                    mov    %eax,%esi\n  400571:    bf 74 06 40 00           mov    $0x400674,%edi\n  400576:    b8 00 00 00 00           mov    $0x0,%eax\n  40057b:    e8 80 fe ff ff           callq  400400 &lt;printf@plt&gt;\n  400580:    e8 a1 ff ff ff           callq  400526 &lt;_Z1fv&gt;        #f()\n  400585:    89 c3                    mov    %eax,%ebx\n  400587:    e8 b0 ff ff ff           callq  40053c &lt;_Z1gv&gt;        #g()\n  40058c:    01 d8                    add    %ebx,%eax\n  40058e:    89 c6                    mov    %eax,%esi\n  400590:    bf 74 06 40 00           mov    $0x400674,%edi\n  400595:    b8 00 00 00 00           mov    $0x0,%eax\n  40059a:    e8 61 fe ff ff           callq  400400 &lt;printf@plt&gt;\n  40059f:    c7 45 e0 01 00 00 00     movl   $0x1,-0x20(%rbp) #a\n  4005a6:    c7 45 e4 02 00 00 00     movl   $0x2,-0x1c(%rbp)    #b\n  4005ad:    c7 45 e8 03 00 00 00     movl   $0x3,-0x18(%rbp)    #c\n  4005b4:    c7 45 ec 04 00 00 00     movl   $0x4,-0x14(%rbp) #d\n  4005bb:    8b 45 e0                 mov    -0x20(%rbp),%eax\n  4005be:    0f af 45 e4              imul   -0x1c(%rbp),%eax # a * b\n  4005c2:    8b 55 e8                 mov    -0x18(%rbp),%edx \n  4005c5:    01 d2                    add    %edx,%edx                # c + c &#x3D; c*2\n  4005c7:    01 d0                    add    %edx,%eax                # 相加\n  4005c9:    89 45 ec                 mov    %eax,-0x14(%rbp)\n  4005cc:    8b 45 ec                 mov    -0x14(%rbp),%eax\n  4005cf:    89 c6                    mov    %eax,%esi\n  4005d1:    bf 74 06 40 00           mov    $0x400674,%edi\n  4005d6:    b8 00 00 00 00           mov    $0x0,%eax\n  4005db:    e8 20 fe ff ff           callq  400400 &lt;printf@plt&gt;\n  4005e0:    b8 00 00 00 00           mov    $0x0,%eax\n  4005e5:    48 83 c4 28              add    $0x28,%rsp\n  4005e9:    5b                       pop    %rbx\n  4005ea:    5d                       pop    %rbp\n  4005eb:    c3                       retq   \n  4005ec:    0f 1f 40 00              nopl   0x0(%rax)\n\n从汇编代码可以看出，实际上f()+g() 和a * b + c *2的顺序均为从左向右。\n实际上，之前自己记忆中一直是以下这句：\n\n复合赋值运算的优先级符合C语言运算符的优先级表，结合方向为从右到左。 C语言中可以进行连续赋值,如a&#x3D;b&#x3D;c&#x3D;1,“&#x3D;”运算符是从右至左结合\n函数参数：主要是函数参数入栈的方式造成有，入栈从右向左，运算也就从右向左。 i&#x3D;1; printf(“%d%d”,i,i++);&#x2F;&#x2F;输出2 1\n\n","slug":"C语言回头看--双胞胎i++和++i的故事","date":"2022-02-26T04:40:06.466Z","categories_index":"开发,C语言回头看","tags_index":"C语言","author_index":"明说网络"},{"id":"913fd9265e0b9bf65f9ed30ba7a8f72d","title":"Watering Hole Attack 水坑攻击","content":"Watering Hole Attack 水坑攻击\n什么是水坑攻击水坑攻击时一种看似简单但成功率较高的网络攻击方式。攻击目标多为特定的团体（组织、行业、地区等）。攻击者首先通过猜测（或观察）确定这组目标经常访问的网站，然后入侵其中一个或多个网站，植入恶意软件。在目标访问该网站时，会被重定向到恶意网址或触发恶意软件执行，导致该组目标中部分成员甚至全部成员被感染。按照这个思路，水坑攻击其实也可以算是鱼叉式钓鱼的一种延伸。\n\n\n早在 2012 年，国外就有研究人员提出了“水坑攻击”的概念。这种攻击方式的命名受狮子等猛兽的狩猎方式启发。在捕猎时，狮子并不总是会主动出击，他们有时会埋伏水坑边上，等目标路过水坑停下来喝水的时候，就抓住时机展开攻击。这样的攻击成功率就很高，因为目标总是要到水坑“喝水”的。\n\n特征水坑攻击主要呈现出两个特征：\n\n多属于 APT 攻击，目标多为是大型、重要企业的员工或网站；\n\n多利用 0-day 漏洞。\n\n\n案例水坑攻击的案例不时会有出现。2012 年底，美国外交关系委员会的网站遭遇水坑攻击；2013 年初，苹果、微软、纽约时报、Facebook、Twitter 等知名大流量网站也相继中招。国内网站也难以幸免：2013 年，西藏政府网站遭遇水坑攻击；2015 年，百度、阿里等国内知名网站也因为 JSONP 漏洞而遭受水坑攻击。\n预防针对这类攻击，重要的一点也是对用户进行教育，让他们意识到这类攻击及其危害性，遇到点击链接的要求时越谨慎越好。其次企业组织本身也要提高警惕，采取更高级的手段检测并对抗攻击。\n参考资料https://www.sohu.com/a/166589989_472906\n","slug":"Watering Hole Attack 水坑攻击","date":"2021-06-17T04:00:00.000Z","categories_index":"网络空间,科普","tags_index":"Attack","author_index":"明说网络"},{"id":"fa7351556b1cb1d20cc08a0d968e2368","title":"以色列网络作战部队之C4i","content":"以色列网络作战部队之C4i\n“We are everywhere. From the fiber optic to the satellite, from the support base to the most forward operating soldier,” said Col. R, who commands the Code, Cipher, and Security Unit of the C4i Directorate.\n“从光纤到卫星，从支援保障到最前沿的士兵，我们无处不在”——C4i 指挥部编码、密码、安全部门指挥官R上校\n\n图片来源:https://www.freebuf.com/articles/network/232118.html\n官网简介\n\n\n\n\n\n\n\n\n来源：https://www.idf.il/en/minisites/c4i-and-cyber-defense-directorate/\nC4i指挥部是IDF的精英技术单位。 C4i指挥部的主要活动是为战场指挥官提供他们需要的技术，以便以尽可能好的方式掌控战场局势。该指挥部的主要目标是发起、发展、开发和加强IDF(以色列国防军)的技术集成系统。C4i首长是少将Lior Carmeli。\n在过去的二十年里，随着技术的进步，指挥部已经成为一个领跑者。它负责以色列国防军在战场上的所有联系、计算机和通信。它还负责IDF的所有网络防御。网络防御部(Cyber Defense Unit)定期举办黑客马拉松（hackathons ），以挑战自我、提高技能。\n该处隶属于参谋长，并与业务处合作工作。\n培训\n\n\n\n\n\n\n\n\n来源：https://www.idf.il/en/minisites/training-and-preparation/the-24-hour-hackathon-exercise-of-the-c4i-and-cyber-defense-directorate/\nC4I和网络防御局在军官培训学校完成军官课程后，为即将上任的军官设置了一门特殊课程。本课程是专为刚从军官训练学校毕业的首军官而设，内容包括多项训练，以协助他们胜任其岗位\n课程新军官在网络防御局的完成来自计算机软件，电气工程和网络防御背景的课程。在课程中，他们将学习未来工作的专业知识，并了解技术部门的不同单位。他们也熟悉了理事会的各种计划和项目。\n“结业课程非常具有挑战性和复杂性。归根到底，学员面临的挑战不是理论上的，而是通过完成分配的实际任务获得的经验。们未来所需要的经验是通过各种演习获得的，其中之一就是‘黑客马拉松’。”\n什么是“黑客马拉松”?“黑客马拉松”是课程第9周完成的练习。这种持续24小时的练习，本质上是产品开发和创新的短期“冲刺”。这是一个独特的模拟系统，以帮助培训C4I和网络防御局的新军官。\n“黑客马拉松”的主要目的是让新军官发现问题，并从那里开发新的创造性想法，利用技术提供解决方案。\n\n从学员到军官完成课程的军官最终会拥有高水平的领导能力和专业技能。课程结束后，他们在网络防御局中担任各种职务，比如项目领导，这意味着他们负责正在进行的项目和编程，这包括编程和开发应用程序、分析等。\nCyberdome演习\n\n\n\n\n\n\n\n\n来源：https://www.israelnationalnews.com/News/News.aspx/271365\nC4i &amp; 网络防御局会定期与外国网络防御实体进行演练，以提高部队的能力和战备状态，并加强部队之间的联系，鼓励各机构之间的相互学习。例如2019年11月，其与美国进行名为“Cyberdome”的演习，该演习是C4i和网络防御局与美国司令部正在进行的训练的一部分，有助于两组织之间现有的网络防御战略伙伴关系。\n\n参考资料：解构全球网军之以色列网络作战部队，https://www.freebuf.com/articles/network/232118.html\nThe 24-hour “Hackathon” Exercise of the C4I and Cyber Defense Directorate，https://www.idf.il/en/minisites/training-and-preparation/the-24-hour-hackathon-exercise-of-the-c4i-and-cyber-defense-directorate/\nC4I and Cyber Defense Directorate，https://www.idf.il/en/minisites/c4i-and-cyber-defense-directorate/\nIsraeli and US armies conduct cyber battlefield exercise，https://www.israelnationalnews.com/News/News.aspx/271365\n","slug":"以色列网络作战部队C4i","date":"2021-06-17T04:00:00.000Z","categories_index":"网络空间,网络战","tags_index":"网络攻击","author_index":"明说网络"},{"id":"41ee9ceb1ae1514ff951ce8b067ef7df","title":"颠覆传统网络安全结构--Zero Trust","content":"颠覆传统网络安全结构–Zero Trust《林海雪原》中，侠客般的杨子荣靠着“黑话”&#x2F;“暗号”，赢得了土匪头子“座山雕”的信任，成功打入土匪内部，智取了威虎山。\n假如将这一场景类比于网络，它与早期的网络攻击何其相似。\n传统的网络安全中，用户与系统之间依靠防火墙隔离，用户只需完成如“盖地虎，镇河妖”的“暗号”就可访问系统内部整个网络区域，使网络存在非常大的安全隐患。随着企业业务复杂性的增加、黑客的“进化”以及网络虚拟化等技术的发展，安全防御方式也在进一步提升，“盖地虎，镇河妖”式“暗号”已不能支撑整个网络安全系统.[8]\n为了解决这个问题，零信任模型被提出，一些大的机构也提出了自己的零信任体系，如NIST[6],NSA[7],奇安信[5]等。可以看出，零信任模型作为一种颠覆性的安全结构设计，已经逐渐得到人们的认可。下面我们就简要的介绍一下零信任的相关知识。\n传统的网络安全结构据加利福尼亚州旧金山的计算机安全研究所称，60％到80％的网络滥用事件来自内部网络。因为传统的防火墙和入侵检测系统（IDS）主要是针对网络外部发起的攻击，而对来自内部的网络攻击是无效的。传统的基于边界的网络安全方法是先连接，后信任，在网络边界验证用户身份，确定用户是否值得信任。如果用户被认定为是可信任的，就能进入网络，而一旦通过边界进入到网络内部，访问基本就通行无阻了。如防火墙、入侵防御系统等，是一种城堡护城河式保护。\n传统的网络安全结构把不同的网络（或者单个网络的一部分）划分为不同的区域，不同区域之间使用防火墙进行隔离。每个区域都被授予某种程度的信任，它决定了哪些网络资源允许被访问。这种安全模型提供了非常强大的纵深防御能力。比如，互联网可访问的Web服务器等高风险的网络资源，被部署在特定的区域（一般称为“隔离区”, DMZ），该区域的网络流量被严密监控和严格控制。这是一种常见的网络安全架构。\n\n这种保护机制可以称为，城堡护城河式保护：传统的基于边界的网络安全方法是先连接，后信任，在网络边界验证用户身份，确定用户是否值得信任。如果用户被认定为是可信任的，就能进入网络，而一旦通过边界进入到网络内部，访问基本就通行无阻了。\n传统的安全模型主要有以下缺点。\n\n缺乏网络内部的流量检查。\n主机部署缺乏物理及逻辑上的灵活性。\n存在单点故障\n\n以横向移动举例说明传统的网络安全结构的问题\n① 通过钓鱼邮件锁定企业的员工。\n② 攻陷办公网的员工计算机，获得Shell。\n③ 在办公网络中横向移动。\n④ 定位拥有特权的计算机。\n⑤ 安装键盘记录器的特权计算机本地提权。\n⑥ 窃取开发人员的口令。\n⑦ 从特权计算机攻击生产应用主机。\n⑧ 利用开发人员口令在生产应用主机上提升权限。\n⑨ 从应用程序中窃取数据库口令。\n⑩ 通过失陷的应用主机外泄数据库中的数据。\n\n\n\n\n\n\n\n\n\n横向移动（Lateral Movement）就是当攻击者获得了某台内网机器的控制权限后，会以被攻陷的主机为跳板，继续访问或控制其他内网机器的过程.\n\n在上述过程中，一旦攻击者获取了内网的某台主机的访问控制权限，又由于现有防御策略对内网控制不那么强， 攻击者可以通过一些系列操作，实现内网的横向移动，最终控制整个内部网络。\n如何解决这个问题呢？首先问题的关键是信任出了问题。传统网络安全结构，对内网中的用户具有一定的默认权限，即默认信任内网用户。因此尽可能减少信任是更明智的做法。\n零信任架构一种解决上述粗粒度的访问控制的方式是进行更加细粒度的访问控制，即分段安全。分段安全用物理安全设备分割网络可以实现更强的违规控制。但此种方法成本昂贵\n分段安全的缺陷\n\n传统的周边安全缺乏必要的控制来限制攻击和恶意软件在周边的移动(上图左)。\n\n用物理安全设备分割网络可以实现更强的违规控制，但会迅速增加成本并产生变更管理挑战，特别是在工作负载变得可移动的情况下(上图右)。\n\n\n解决方案：零信任零信任网络模型在2010年由John Kindervag提出，后来Gartner和Forrester由对零信任概念、应用场景、迁移方式进行了完善和补充。\n零信任架构的做法是先信任，后连接，意味着每个用户、设备、服务或应用程序都是不可信任的，必须经历身份和访问管理过程才能获得最低级别的信任和关联访问特权。零信任模型不信任任何人，所有对数据和服务(统称为资源)的访问都需要授权,这是和传统网络安全方法的主要区别。\n《零信任网络：在不可信网络中构建安全系统》[3]对零信任安全进行了抽象：\n\n网络无时无刻不处于危险的环境中\n\n网络中自始至终存在外部或内部威胁\n\n网络位置不足以决定网络的可信程度\n\n所有的设备、用户和网络流量都应当经过认证和授权\n\n安全策略必须是动态的，并基于尽可能多的数据源计算而来。\n\n\n基于零信任的网络安全架构利用分布式策略实施和应用零信任原则，可以构建如下图所示的网络安全架构\n\n其中，零信任架构的支撑系统称为控制平面，其他部分称为数据平面，数据平面由控制平面指挥和配置。\n零信任的数据平面和控制平面\n数据平面。零信任网络中的数据平面由直接处理网络流量的应用程序、防火墙、代理服务器和路由器组成。\n\n控制平面。零信任网络中的控制平面由一系列组件构成，这些组件接收并处理来自数据平面的请求，这些请求或者是希望访问网络资源，或者是授予网络资源的访问权限。访问受保护资源的请求首先经过控制平面处理，包括设备和用户的身份认证与授权。细粒度的控制策略也在这一层进行，控制平面可以基于组织中的角色、时间或设备类型进行授权。一旦控制平面完成检查，确定该请求具备合法的授权，它就会动态配置数据平面，接收来自该客户端（且仅限该客户端）的访问流量。此外，控制平面还能够为访问请求者和被访问的资源协调配置加密隧道的具体参数，包括一次性的临时凭证、密钥和临时端口号等。\n\n\n\n奇安信零信任安全白皮书零信任架构的关键能力模型零信任架构的本质是以身份为基石的动态可信访问控制，聚焦身份、信任、业务访问和动态访问控制等维度的安全能力，基于业务场景的人、流程、环境、访问上下文等多维的因素，对信任进行持续评估，并通过信任等级对权限进行动态调整，形成具备较强风险应对能力的动态自适应的安全闭环体系。\n\n零信任架构核心逻辑架构组件\n\n可信代理\n可信代理是零信任架构的数据平面组件，是确保业务安全访问的第一道关口，是动态访问控制能力的策略执行点。\n可信代理拦截访问请求后，通过动态访问控制引擎对访问主体进行认证，对访问主体的权限进行动态判定。只有认证通过、并且具有访问权限的访问请求才予以放行。同时，可信代理需要对所有的访问流量进行加密。全流量加密对可信代理也提出了高性能和高伸缩性的需求，支持水平扩展是零信任可信代理必须具备的核心能力。\n在零信任网络模型下，授权的主体必须是网络代理。网络代理指在网络请求中用于描述请求发起者的信息集合，一般包括用户、应用程序和设备共3类实体信息。作为网络活动的首要参与者，网络代理在信任评分计算过程中，同样发挥着重要作用。评估网络代理的信任度时，信任引擎不仅仅可以使用网络代理自身包含的信息，还可以使用其历史行为记录。信任评估系统会根据访问活动日志之类的信息进行实时计算，并更新用户、应用程序和设备的信任评分。网络代理只能是一种“尽力而为”的数据集，某些字段总是会因为各种原因而缺失。网络代理属于授权范畴\n\n动态访问控制引擎\n动态访问控制引擎和可信代理联动，对所有访问请求进行认证和动态授权，是零信任架构控制平面的策略判定点。\n动态访问控制引擎对所有的访问请求进行权限判定，权限判定不再基于简单的静态规则，而是基于上下文属性、信任等级和安全策略进行动态判定。动态访问控制进行权限判定的依据是身份库、权限库和信任库。其中身份库提供访问主体的身份属性，权限库提供基础的权限基线，信任库则由身份分析引擎通过实时的风险多维关联和信任评估进行持续维护。\n\n信任评估引擎\n信任评估引擎是是零信任架构中实现持续信任评估能力的核心组件，和动态访问控制引擎联动，为其提供信任等级评估作为授权判定依据。\n信任评估引擎持续接收可信代理、动态访问控制引擎的日志信息，结合身份库、权限库数据，基于大数据和人工智能技术，对身份进行持续画像，对访问行为进行持续分析，对信任进行持续评估，最终生成和维护信任库，为动态访问控制引擎提供决策依据。另外，信任评估引擎也可以接收外部安全分析平台的分析结果，包括：终端可信环境感知、持续威胁检测、态势感知等安全分析平台，这些外部风险源可以很好的补充身份分析所需的场景数据，丰富上下文，从而进行更精准的风险识别和信任评估。\n在零信任网络里，信任引擎是对特定的网络请求或活动进行风险分析的系统组件，其职责是对网络请求及活动的风险进行数值评估，策略引擎基于这个风险评估进行进一步的授权决策，以确定是否允许此次访问请求。成熟的信任引擎除了使用静态规则，还大量采用机器学习技术来实现信任评分功能。信任引擎一般会混合使用基于规则的静态评分方法和机器学习方法。应该同时对网络代理及网络代理的构成要素（设备、用户及应用程序）进行风险评分。将这些风险评分同时传递给策略引擎，策略引擎根据具体的规则决定使用哪些评分参与授权决策。信任评分的暴露存在风险，应该不直接提供信任评分给用户，但明确标识出能提升信任评分的影响因子。信任引擎是使用历史数据的主要组件。信任评分是对系统和组件当前信任程度的量化表示，策略制定者可以基于访问资源所需的信任等级来定义策略。\n可变信任是零信任网络的一个令人兴奋的思想。传统网络策略关注的是允许哪些系统以何种方式进行访问。这种二元决策框架容易导致两类问题，一方面可能导致策略定义太严格，使用过程中需要不断进行人为调整；一方面可能导致策略定义太宽松，使安全系统事实上缺少安全断言。此外，传统的策略框架基于交互的具体细节来定义策略，这会使其不可避免地陷入类似“猫捉老鼠”的状况，总是需要根据曾经遭遇过的威胁不断调整策略。零信任模型提出了可变信任的概念，使用一个数值来代表系统组件的信任级别，然后基于这个数值编写策略，使得一条策略能够有效覆盖一定的范围，又不会因为边界条件过多而使策略复杂化。因为使用了不那么具体的细节来定义策略，并在授权判定时引入了信任评分，所以这样的授权系统能够应对新出现的威胁。零信任网络不再给网络参与者定义和分配基于二元决策的策略，而是持续监视参与者的网络活动，并据此持续更新其信任评分，然后使用这个评分作为授权策略判定的依据之一。\n\n身份安全基础设施\n身份基础设施是是实现零信任架构以身份为基石能力的关键支撑组件。\n身份基础设施至少包含身份管理和权限管理功能组件，通过身份管理实现各种实体的身份化及身份生命周期管理，通过权限管理，对授权策略进行细粒度的管理和跟踪分析。\n零信任架构的身份安全基础设施需要能满足现代IT环境下复杂、高效的管理要求，传统的静态、封闭的身份与权限管理机制已经不能满足新技术环境的要求，无法支撑企业构建零信任安全架构的战略愿景，需要足够敏捷和灵活，需要为更多新的场景和应用进行身份和权限管理。另外，为了提高管理效率，自助服务和工作流引擎等现代身份管理的关键能力也必不可少。\n为了有效地管理网络中的信任，人们必须能够明确地识别可信信息，特别是在身份认证和身份识别的场景下。PKI是提供身份认证的最佳方法。\n\n\n零信任案例\n在这个例子中[7]，一个恶意的网络行为者通过一个基于互联网的移动代码漏洞损害了用户的设备。或者，该行为者是一个有恶意的内部授权用户。在一个典型的、非零信任的情况下，行为者使用用户的证书，列举网络，提升权限，并通过网络横向移动，破坏大量的数据存储，并最终实现持久化控制。\n在 “零信任 “网络中，被破坏的用户的证书和设备已经被认为是恶意的，而且网络被分割，限制了枚举和横向移动的机会。虽然恶意行为者可以同时以用户和设备的身份进行认证，但对数据的访问将根据安全策略、用户角色以及用户和设备属性进行限制。在一个成熟的零信任环境中，即使用户被允许访问，数据加密和数字权利管理也可以提供额外的保护，限制哪些数据可以被访问，可以对敏感数据采取的行动。此外，还将持续监测账户、设备、网络活动和数据访问的异常活动。虽然在这种情况下仍会发生一定程度的损害，但损害是有限的，防御系统检测和启动适当的缓解反应的时间也大大减少。\n零信任和传统安全结构的区别边界安全模型与零信任模型存在根本上的差别。边界安全模型试图在可信资源和不可信资源（本地网络和互联网）之间建一堵墙，而零信任模型则“认输”了，它接受“坏人”无处不在的现实。零信任模型不是依靠建造城墙来保护墙内柔弱的身体，而是让全体民众都拥有了自保的能力。\n总结：\n构建零信任网络并不需要太多新的技术，而是采用全新的方式使用现有技术。\n零信任模型颠覆了传统网络安全模型，不信任任何人是零信任的核心。\n零信任的核心是计算，这肯定会增加设备的负载；同时动态的信任评估也需要相互之间的协作。零信任之路，仍在路上。\n\n参考资料：[1]零信任（Zero Trust）简介， https://blog.csdn.net/baidu_41700102/article/details/104314323\n[2]What Is Zero Trust Security?https://www.mcafee.com/enterprise/zh-cn/security-awareness/cloud/what-is-zero-trust.html\n[3]零信任网络：在不可信网络中构建安全系统,【美】埃文·吉尔曼（Evan Gilman），道格·巴斯（Doug Barth）,人民邮电出版社\n[4]国内首份零信任安全白皮书：全面解读零信任安全架构， https://www.secrss.com/articles/18624\n[5]Zero Trust Architecture and Solutions, https://www.gartner.com/teamsiteanalytics/servePDF?g=/imagesrv/media-products/pdf/Qi-An-Xin/Qi-An-Xin-1-1OKONUN2.pdf\n[6]Rose, S. , Borchert, O. , Mitchell, S. and Connelly, S. (2020), Zero Trust Architecture, Special Publication (NIST SP), National Institute of Standards and Technology, Gaithersburg, MD, [online], https://doi.org/10.6028/NIST.SP.800-207, https://tsapps.nist.gov/publication/get_pdf.cfm?pub_id=930420 (Accessed June 16, 2021)\n[7]Embracing a Zero Trust Security Model, https://media.defense.gov/2021/Feb/25/2002588479/-1/-1/0/CSI_EMBRACING_ZT_SECURITY_MODEL_UOO115131-21.PDF\n[8]如果土匪都懂“零信任网络”，杨子荣还能智取威虎山吗？,https://cloud.tencent.com/developer/article/1429187\n","slug":"零信任","date":"2021-06-13T04:00:00.000Z","categories_index":"网络空间","tags_index":"网络安全","author_index":"明说网络"},{"id":"22d9cc0e40f8c7efc4434319669da2d7","title":"（转载）来网络空间钓鱼吧","content":"（转载）来网络空间钓鱼吧\n什么是网络钓鱼？网络钓鱼是一种尝试使用欺骗性电子邮件和网站收集个人信息的攻击方式。攻击者会伪装成信誉良好的实体或个人通过电子邮件或其他通信渠道，使用网络钓鱼电子邮件分发可执行各种功能的恶意链接或附件，从受害者中提取登录凭据或帐户信息；或者自动下载恶意软件，让受害者使用恶意软件感染自己的计算机。\n\n网络钓鱼的类型网络钓鱼很猖獗，这使得它很危险。模拟网站与真实网站普通人无法区分，黑客们正在寻找方法来克服日益复杂的垃圾邮件过滤。除了电子邮件和网站钓鱼之外，还有“vishing”（语音网络钓鱼），“smishing”（短信网络钓鱼）和网络犯罪分子不断提出的其他几种网络钓鱼技术。 下面我们来看看常见的网络钓鱼攻击类型。\n1、鱼叉式网络钓鱼攻击这是一种个人触摸的大量网络钓鱼。发件人将使用可用信息看似合法。此类别中最常见的伪装是银行，攻击可以发送您的姓名，地址等。\n它针对特定的个人或公司，通常是用来收集的受害者特定信息，以更成功地将该信息表示为真实信息。鱼叉式网络钓鱼电子邮件可能包括对受害者组织的同事或管理人员的引用，以及受害者姓名，地点或其他个人信息的使用。\n\n2、捕鲸攻击（行政网络钓鱼）这是一种专门针对组织内的高级管理人员的钓鱼攻击，通常是为了窃取大笔资金。\n典型的捕鲸攻击针对的是能够授权付款的员工，网络钓鱼消息似乎是来自管理人员的命令，用于向供应商授予大额付款，而实际上是向攻击者付款。\n3、克隆网络钓鱼它会收集先前已发送的电子邮件并复制其内容，将任何合法链接替换为恶意链接。然后使用欺骗帐户将电子邮件发送给原始电子邮件的收件人。基本上，攻击者克隆了合法的电子邮件。\n大多数克隆网络钓鱼的目标是感染目标计算机上的病毒，恶意软件传播到分支机器网络。随着链接的消失，更多用户被感染，然后发送更多受感染的链接。\n4、域欺骗它是一种新的网络钓鱼形式，依赖于DNS缓存污染，将用户从合法站点重定向到欺诈站点，并欺骗用户使用他们的登录凭据尝试登录欺诈站点。\n5、语音网络钓鱼它也称为vishing，是一种通过语音通信媒体发生的网络钓鱼形式，包括IP语音（VoIP）或POTS（普通老式电话服务）。犯罪者会使用语音合成软件留下声称通知受害者银行或信用账户中的可疑活动的语音邮件，并请求受害者回复恶意电话号码以验证他的身份 - 从而危及受害者的账户凭证。\n6、短信网络钓鱼它也称为SMishing或SMShing，犯罪者会使用短信来说服受害者披露帐户凭据或安装恶意软件。\n原文https://www.php.cn/windows-414137.html\n","slug":"来网络空间钓鱼吧","date":"2021-06-12T04:00:00.000Z","categories_index":"网络空间,网络战","tags_index":"网络攻击","author_index":"明说网络"},{"id":"3c29ac26f9501e1fdd3e38abb3f90334","title":"(转载)Cyber-Kill-Chain-网络杀伤链","content":"(转载)Cyber-Kill-Chain-网络杀伤链网络杀伤链“网络杀伤链”，是美国国防承包商洛克希德·马丁公司（Lockheed Martin）提出的网络安全威胁的杀伤链模型[2]（普遍适用的网络攻击流程与防御概念，参考军事上的杀伤链(Kill Chain)概念）。\n\n\n\n\n\n\n\n\n\n杀伤链源自军事领域，它是一个描述攻击环节的模型，理论上也可以用来预防此类攻击（即反杀伤链）。杀伤链共有发现-定位-跟踪-瞄准-打击-达成目标六个环节，每一环节都是对攻击做出侦测和反应的机会。\n内容包括成功的网络攻击所需的七个阶段：侦察跟踪、武器构建、载荷投递、漏洞利用、安装植入、命令与控制、目标达成。\n\n针对网络杀伤链的防御对策洛克希德·马丁公司在2015年发布的白皮书中提出预防措施，以降低上述每个阶段的影响程度。\n1、侦察跟踪　　描述：攻击者进行探测、识别及确定攻击对象（目标）的阶段。信息一般通过互联网进行收集（内容包括网站、邮箱、电话、社会工程学等一切可能相关的情报）\n　　预防：侦察跟踪阶段往往是防守方感知比较少的阶段；应关注于日常异常流量、日志和数据（特别是已经泄露的数据），将其存储备查是必要的，更重要的是建立和优化分析模型。\n2、武器构建　　描述：攻击者通过侦察跟踪阶段确定目标、收集足够的信息后，准备网络武器的阶段。网络武器一般由攻击者直接构建或使用自动化工具构建等。\n　　预防：武器构建行为本身对于防守方来说几乎无感知，但又与防守方的“资源”密切相关，武器的构建需要基于“资源”的漏洞或缺陷（包括操作系统、应用软件、甚至社会工程）；应关注“资产”相关漏洞、补丁、修复流程是否完备。\n3、载荷投递　　描述：攻击者将构建完成的网络武器向目标投递的阶段。投递方式一般包括钓鱼邮件、物理USB投递等。\n　　预防：防护策略在该阶段尤为重要，云防护、边界防护、区域防护、系统防护、应用防护等，应关注是否具备且有效防护措施，另外安全意识也同样重要，人的弱点往往比设备的弱点更容易被利用。\n4、漏洞利用　　描述：攻击者将网络武器投递到目标系统后，启动恶意代码的阶段。一般会利用应用程序或操作系统的漏洞或缺陷等。\n　　预防：安全检测、安全监测、阻断+审计，这就是日常的安全监控工作（看大门的工作，重要！）\n5、安装植入　　描述：攻击者在目标系统设置木马、后门等，一定期限内在目标系统营造活动环境的阶段。\n　　预防：在最短的时间内发现并隔离，关注终端&#x2F;服务器安全管理策略、防病毒。\n6、命令与控制　　描述：攻击者建立目标系统攻击路径的阶段。一般使用自动和手工相结合的方式进行，一旦攻击路径确立后，攻击者将能够控制目标系统。\n　　预防：洛克希德·马丁公司描述此阶段为“防御者阻止攻击的最后机会……如果对手无法发出命令，防御者便可控制影响”，此阶段正是考验响应策略的最后一次尝试，所以更应关注访问控制。\n7、目标达成　　描述：攻击者达到预期目标的阶段。攻击目标呈现多样化，可能包括侦察、敏感信息收集、数据破坏、系统摧毁等。\n　　预防：虽然木已成舟，但仍需要集中精力把损失降低到最小，吸取教训、改进措施，才能避免在同一个地方摔倒两次。\n\n总结现阶段大部分的攻击者可能都在遵循上述的步骤， 但APT（高级可持续攻击）趋势正在迅速增长，甚至未知威胁，所以防御对策也必须要不断的更新迭代来应对这潜移默化的威胁。\n参考资料：[1] 原文，Cyber-Kill-Chain-网络杀伤链，https://www.cnblogs.com/Michael-Scofields/p/13570827.html\n[2] Intelligence-Driven Computer Network Defense Informed by Analysis of Adversary Campaigns and Intrusion Kill Chains, https://www.lockheedmartin.com/content/dam/lockheed-martin/rms/documents/cyber/LM-White-Paper-Intel-Driven-Defense.pdf\n","slug":"Cyber-Kill-Chain-网络杀伤链","date":"2021-06-08T04:00:00.000Z","categories_index":"网络空间,网络战","tags_index":"网络攻击","author_index":"明说网络"},{"id":"bb153495d3c1c93b79c2ee5fc53737c7","title":"俄罗斯-格鲁吉亚网络冲突事件","content":"俄罗斯-格鲁吉亚网络冲突事件“正如你所看到的，看似平静的世界，硝烟弥漫。” ——点我试试\n事件简介2008 年 8 月，为了把格鲁吉亚从南奥塞梯驱逐出去，俄罗斯军队进攻格鲁吉亚。此次军事行动开展的同时，也伴随了大量经过协调的网络攻击行动。这是第一次与大规模地面作战行动配合的大规模网络攻击，对格鲁吉亚展开了全面的“蜂群”式网络阻瘫攻击，致使格方电视媒体、金融和交通等重要系统瘫痪，机场、物流和通信等信息网络崩溃，急需的战争物资无法及时运达指定位置，战争潜力被严重削弱，直接影响了格鲁吉亚的社会秩序以及军队的作战指挥和调度。\n网络攻击阶段一位安全专家将俄罗斯对格鲁吉亚的网络攻击分为两个阶段。\n第一阶段在第一阶段中，俄罗斯黑客发起的攻击类型主要是分布式拒绝服务（DDoS）攻击。\n\n此阶段的DDoS主要通过僵尸网络开展。\n俄罗斯商业网络（Russian Business Network ，RBN)这类犯罪组织出于各种目的使用并租赁僵尸网络。攻击格鲁吉亚网站中所使用的僵尸网络都隶属于俄罗斯的犯罪组织，其中就有包括 RBN。\n\n\n\n\n\n\n\n\n\n\n注：RBN是一种专门为违法犯罪分子进行网络犯罪提供庇护的自治域。\n第一阶段的攻击主要针对格鲁吉亚政府和媒体网站。俄罗斯的僵尸网络依靠强力的 DDoS 对这些目标采取行动。爱沙尼亚的网络在一年前受到俄罗斯黑客攻击，而格鲁吉亚的网络，由于其本身脆弱，比起前者更容易受到数据洪流包的影响 \n第二阶段格鲁吉亚媒体和政府网站持续受到 DDoS 攻击的同时，俄罗斯第二阶段的网络作战力求对更多目标进行破坏，其破坏目标名单上包括金融机构企业教育机构西方媒体（英国广播公司和美国有线电视新闻网络）以及一处格鲁吉亚黑客网站 （图 3.1）。对这些服务器的攻击不仅包括 DDoS 攻击，还包括篡改服务器的网站（如：在政府网站上添加将格鲁吉亚总统米哈伊尔·萨卡什维利比作阿道夫·希特勒的亲俄涂鸦）。此外，一些俄罗斯黑客利用格鲁吉亚政治人物公开可用的电子邮件地址，发起垃圾邮件攻击。\n同时，俄罗斯黑客利用BGP劫持，通过俄罗斯的服务器重新路由了格鲁吉亚的互联网流量，借机破坏政府网站，入侵电视和广播电台。\n\n对格鲁吉亚网络攻击的特点攻击目标俄罗斯网络攻击的目标是“隔离和压制”格鲁吉亚人。攻击有效地使（1）格鲁吉亚媒体沉默并（2）使格鲁吉亚从国际社会孤立开来。\n与常规部队的配合网络攻击与常规部队的协调是非常有限的。\n侦察和准备许多安全专家认为，在 8 月 7 日最初的网络攻击之前，俄罗斯黑客已经准备好行动。\n影响2008 年 8 月俄罗斯对格鲁吉亚发动的网络攻击是第一次与主要常规军事行动同时发生的大规模网络攻击。这些网络攻击削弱了格鲁吉亚人与外界沟通的能力，在信息和心理上对媒体、政府以及公众产生了重大影响。\n总结网络武器库2017年，NSA网络武器库的泄露[2]更是像世界展示了美国在网络战领域的狼子野心。僵尸网络，DDoS是发动网络攻击中非常有效的工具和手段。\n好用又廉价，网络战是未来战争不可缺少的一环1991年海湾战争让世界眼前一亮。现在网络战、网络武器也进入人民的视野。网络战具有隐蔽、攻击范围大，对信息基础设施影响大（甚至是物理基础设施，见震网、美东部输油管道中断等），容易制造舆论压力等特点，好用又廉价。未来战争，网络战是其中必不可少的一部分。\n“网络人民战争”有意思的是，在网络攻击期间，俄罗斯网民可以从网站上下载黑客软件，安装之后点击“开始攻击”按钮即可进行网络攻击。媒体评论俄罗斯打了一场名副其实的“网络人民战争”。\n正如你所看到的，看似平静的世界，硝烟弥漫。\n参考资料[1]《网络战》中文第三章：2008 年俄罗斯对格鲁吉亚的网络，https://blog.51cto.com/tasnrh/1908672\n[2] 2017 NSA网络武器库泄露工具总结分析,https://zhuanlan.zhihu.com/p/31793688\n","slug":"2008俄罗斯-格鲁吉亚网络冲突事件","date":"2021-06-06T04:00:00.000Z","categories_index":"网络空间,网络战","tags_index":"网络攻击","author_index":"明说网络"},{"id":"e16c0fea61760e1062aedc708c7317dc","title":"网络战武器——震网(Stuxnet)病毒","content":"网络战武器——震网(Stuxnet)病毒震网事件 2010 年 6 月 17 日，白俄罗斯一家小 公司 VirusBlockAda 的安全研究人员 发现一种能感染可移动存储设备的恶意软 件。2010年7月，“震网”（Stuxnet）蠕虫攻击事件浮出水面，引发了国际主流安全厂商和安全研究者的全面关注，卡巴斯基、赛门铁克、安天等安全厂商，Ralph Langne等著名安全研究者，以及多国的应急组织和研究机构，都投入到了全面的分析接力中。2010 年 11 月，伊朗总统艾哈迈迪内贾 德公开承认，一种计算机病毒对“我国（核） 离心机中为数不多的几台机制造了一些问 题，”\n最终使这场攻击的大量细节被呈现出来：这是一起经过长期规划准备和入侵潜伏作业；借助高度复杂的恶意代码和多个零日漏洞作为攻击武器；以铀离心机为攻击目标；以造成超压导致离心机批量损坏和改变离心机转数导致铀无法满足武器要求为致效机理，以阻断伊朗核武器进程为目的的攻击。\n事件时间轴下图取自安天实验室关于震网的报告：\n\n震网病毒Stuxnet 是一种计算机蠕虫，大约写于 2005 年到 2010 年之间。主要针对西门子型号为S7-315 和 S7-417 的工控机。其中对于315在攻击发生时，就让他宕机，对于417就使用类似中间人攻击的方式，对工控系统进行欺骗。具体可参考[3].\n工作原理工作原理如下图所示，蠕虫的基本操作。\n\n震网影响Stuxnet 是网空武器针对工业设备的首件案例。Stuxnet 成功地 影响了一个非虚拟实体。这是武器研制的一 项重大进展——在计算机打开后才存在的一 个 软 件 能 成 功 地 对 真 实 世 界 造 成 破 坏。 Stuxnet 清楚地展示，网空武器在军事行动中 能发挥重要作用。\nStuxnet 所引发的军事革命 的最后一个方面是，它证明一些安全假设是 站不住脚的。常见的第一个假设是，物理隔 离的系统更安全。按照定义，SCADA 系统控 制对使命具有关键意义的设备，很多管理人 员不把这些计算机同外部网络相连，以物理 隔离的方式来保证安全，结果是采用可移动 媒介把文件传至计算机。Stuxnet 的设计者利 用了这一假设，使病毒通过 U 盘等可移动存 储设备来传播。一旦 U 盘被感染，病毒软件 本身就在后来使用被感染驱动器的计算机上 运行 ；使用者只要在视窗上点击相关图形， 便开始被感染。这是 Stuxnet 利用其中一个 零日漏洞的直接应用。\n被 Stuxnet 证明是错误的另外一个关键 安全假设，是数字签名证书设立的信任关系。为了提供更大的稳定性，当代操作系统，包 括微软视窗，限制计算机的程序访问系统部 件。一个正常的程序要求系统经由驱动软件 呼叫硬件。鉴于这种情况，驱动软件比其他 程序具更高权限访问低层级系统部件。为了 避免轻易产生恶意驱动软件，微软视窗依赖 数字签名证书识别。Stuxnet 为了防止被杀毒 软件发现，使用了合法的数字签名证书。这 是此前没有发现的 Stuxnet 的另外一个方 面。早期的 Stuxnet 版本使用瑞昱（Realtek） 半导体系统公司提供的证书，后来的版本使 用智微（JMicron）科技公司的证书。使用这 些证书使病毒在微软视窗面前呈现合法软件 的假象。ESET 的安全专家注意到，两家公司 都在台湾地区，因此怀疑这些证书系被盗窃。 此外，他们相信，这极可能是实物盗窃（甚 至可能是内贼所为），因为在互联网的黑市上 驱动软件的数字证书并不常见。\n思考\n网络空间作为一个新的虚拟空间，网络作战的参与方的能量不能以现实实体的大小来标定。\n\n最近的事件表面，即使是个人，也能够宣告对公司、企业发动勒索；即使是组织，也能在网络空间中，对某国发动攻击。那么，网络空间的国家意志如何体现呢？在美国，或许就是网络空间作战司令部吧。\n\n网络空间已经渗透入生活的方方面面，发动网络攻击对现实社会的影响巨大。\n\n前段时间，美国东部输油管道被勒索，导致供应紧张，这件事情前后还报道了有相关的对物理基础设施的攻击事件，足以见到网络武器的威力。一枪一炮或许威力有限，但是对信息社会来说，信息类攻击的损失无可估量，每天都上演的DDoS分布式拒绝服务攻击造成了极大的经济损失。\n\n与自然空间相比，人造空间还是有差距啊。\n\n在网络空间中，规则是协议，落地是代码，协议和代码都是人设计和实现的，所以难免有漏洞，只要还有人的参与，漏洞就依旧会存在。自然空间就不一样了，规律就是规律(谁设计的呢？)，例如热力学第一定律（解释了为什么没有永动机），熵增定律（解释了人为啥会内卷）\n\n\n\n\n\n\n\n\n\n 闲扯一句：这就是为什么唯物辩证法说，一定要掌握事物运行的规律，运动和静止都是相对的等等\n马克思诚不欺我也\n参考文献[1]震网事件的九年再复盘与思考，https://www.antiy.cn/research/notice&amp;report/research_report/20190930.html\n[2]震网——掀起网空战争军事革命， http://www.knowfar.org.cn/publication/uploadfiles/0204/0129/4.1.pdf\n[3]  Stuxnet: Dissecting a Cyberwarfare Weapon, https://courses.cs.duke.edu/spring20/compsci342/netid/readings/stuxnet-dissect.pdf\n","slug":"网络战武器——震网(Stuxnet)病毒","date":"2021-06-06T04:00:00.000Z","categories_index":"网络空间,网络战","tags_index":"网络攻击","author_index":"明说网络"},{"id":"7a13bd9ca5179d5ce2129efba7233d10","title":"Unit 8200 世界上最强的网络部队之一","content":"Unit 8200 世界上最强的网络部队之一神秘的Unit 82002014年，以色列出口的网络安全产品（即公司、银行和政府购买使自己免受黑客、病毒攻击的产品）总值达60亿美金，首次超越了以色列军事硬件的出口值，占领了全球10%的网络安全市场。2014-2016年，微软用3.2亿美元买下数据隐私公司Adallom；Facebook花了1.5亿美元收购移动端数据分析公司Onavo；PayPal以6千万美元收下CyActive, 一家能预判黑客进攻行为的公司；谷歌更是斥11亿美元收购Waze ，一款通过众包形式更新地图数据的导航应用\n而这些被高价收购的公司都有一个共同点：初创者均为以色列国防军（IDF，Israel Defense Forces）下属部队Unit 8200的退伍士兵。\n不仅如此，Unit 8200还盛产纳斯达克上市公司：Wix（WIX），目前世界上领先的建立在云架构基础上的网页开发平台；CheckPoint（CHKP）， 全球首屈一指的 Internet 安全解决方案供应商；Imperva（IMPV）, 全球领先的新型数据应用公司，提供数据库安全和审计解决方案；NICE（NICE），企业级安全解决方案公司； 卫星应用企业Gilat Network（GILT）\n被称为创业之国的以色列，是平均出产科学家、技术大拿、风投机构最多的国家，这其中 Unit 8200是个绕不过去的存在。\nUnit 8200历史沿革\nUnit 8200 是以色列情报部队的一部分，以培养世界上一些受欢迎的网络安全公司的创始人而闻名。\n它的前身始于20世纪30年代的英国托管时期（British Mandate Period）, 最开始被称为“Shin Mem 2”，即希伯来语的“第二信息服务部门”, 负责窃听阿拉伯部落的电话线，提前获取暴动的消息。\n1948年以色列建国时，它被称为515部队，这个随意想出来的数字为的是在公开谈话中无需特意避讳。1952年，它正式成为单独的情报部门，1956年，第二次中东战争时，它又变成848部队。 1973年第四次中东战争后， 改名为Unit 8200，沿用至今。\n根据一些情报专家的分析，Unit 8200可以与美国国家安全局 （NSA，National Security Agency）或英国政府通讯总部（ GCHQ，Britain’s Government Communications Headquarters）相提并论，在某些领域甚至更强。它负责综合协调军队的情报工作，以色列之外的所有地区都属于它的势力范围（包括巴勒斯坦）。\n\n\n\n\n\n\n\n\n\nUnit 8200参与过的行动：\n\n1967年，“8200部队”获得了当年最成功的情报——在“六日战争”的第一天，就成功截获埃及总统纳赛尔和约旦国王侯赛因的高保密专线电话，从而详尽地了解己方战果以及敌方下一步计划。\n1985年，Unit 8200提供了一份电话监听记录，证实了阿拉法特与1973年发生在苏丹的美外交官被劫、被杀事件有关；\n2007年，根据Unit 8200提供的情报，以色列炸掉了一个叙利亚核反应堆；\n2010年，伊朗核反应堆中了Stuxnet电脑病毒， 五分之一的离心器被摧毁，伊朗拥有核武器的时间因此延迟了好几年，而“据说”这是Unit 8200和CIA联手的成果（IDF拒不承认）\n相关资料：http://paranoidechochamber.com/unit-8200/\n\n\n序列根据以色列国防军的序列\n\n8200部队隶属于以色列国防军军事情报部(简写：AMAN，而AMAN隶属于国防军总参谋部)的。\nUnit8200组成序列（补充）\nUnit Hatzav\n开源情报部队，主要面向全世界的媒体：电视，广播，新闻报纸，Internet，甚至是社交网络。\n\nUnit81\nAMAN 的技术部队，主要是搜集和支持最先进的技术（通常结合软硬件产品），大约有1000人。\n\nGedasim\n信息作战团。主要是实时获取地面情报并实时传输战场。\n\n\n以色列人才孵化器以色列最优秀的人才集中在部队。军事部门可以直接对优秀的高中毕业生选召，如果能被8200部队选上，对犹太人来讲，则是一生的荣誉。\n以色列强制兵役规定，犹太人满18岁需服兵役。一般情况下，他们会被随机分配到不同的部队。但一批天资聪颖，最具培养前途的孩子则被Unit 8200经过严格筛选后挑走。这是一支专攻网络安全及情报收集的秘密部队，是顶尖的以色列高科技情报部门。当然8200部队选拔过程极其严格，每年挑选50-100人。同龄人中智力水平最高，最有培养前途，品格正直敢于承担责任的那些人才有可能被安排进入代表以色列最高水平的高科技情报部门在实战中学习与服役。进入Unit 8200后，这些大部分刚满18岁的孩子马上就被投入实战，边服役边学习。加入该单位的年轻人会接触到真实的计算机黑客和网络间谍活动任务。服役完毕后，他们可以选择加入高科技公司，也可以选择继续深造。\n目前，Unit 8200集情报部门、人才训练营、科技孵化器为一体，是以色列国防军中最大且发展速度最快的部门，据估有5000人。每时每刻，它都处理着海量电子数据，数据来源包括移动端、网络、微波信号发生器和卫星。以色列国防军中最重要的信号情报（signals intelligence, SIGINT）部门Urim SIGINIT Base也是Unit 8200的一部分。\n美国《福布斯》报道说，以色列的高科技领域的精英大多来自神秘的8200部队。这些人要么是企业家，要么是公司的创立人或者是中高级主管。以色列的三大高科技公司Nice、Comverse和Check Point的很多技术都来自这个神秘的8200部队。\n参考文献Unit 8200: How NSA of Israel Has One Of The Most Powerful Cyber Armies In The World，https://fossbytes.com/unit-8200-israel-cyber-army/\nhttps://www.sohu.com/a/119924768_464003\nThe Israeli Unit 8200 An OSINT-based study，https://www.research-collection.ethz.ch/handle/20.500.11850/389135\n以色列网电空间作战力量浅析, https://www.secrss.com/articles/29670\n","slug":"Unit 8200 世界上最强的网络部队之一","date":"2021-06-05T09:00:00.000Z","categories_index":"网络空间,网络战","tags_index":"网络空间","author_index":"明说网络"},{"id":"197250d2b2cd50e7198037568060a1f7","title":"互联网发展简史(5)第一次浏览器大战","content":"\n背景万维网真正开始在 1990 年代中期起飞。如果你想使用它，你需要一个网络浏览器。早期的互联网用户可以使用简单的基于文本的终端软件，但 Web 从一开始就有一个图形界面。\n早期的网络浏览器由 Tim Berners-Lee设计的第一个网络浏览器被称为World Wide Web，但它无法在文档中显示图像，只能在弹出窗口中显示。然而，万维网只不过是一个原型。很快，其他开发商也加入了竞争。中国台湾工程师魏培元开发了一款名为 ViolaWWW 的浏览器。这可以在网页中显示图像，并具有基本的框架和脚本。但是 ViolaWWW 很快就被所有现代浏览器之父 Mosaic 打败。\n马赛克Mosaic是在伊利诺伊大学国家超级计算应用中心(NCSA) 开发的。与其他早期浏览器相比，Mosaic 更易于使用，具有更好的网页渲染，包括内嵌图形。最重要的是，它背后有一支才华横溢的工程师团队。Mosaic 不是第一个浏览器，但它确是第一个做对的浏览器，点燃了浏览器的市场。\n\n网景Netscape 的浏览器对网络冲浪体验进行了大量技术改进，例如 cookie 和 Javascript。Navigator 是一种商业产品，售价约为 30 美元。他们 Netscape 对大学和 ISP 的许可有宽松的政策，因此许多人可以免费获得它。由于广泛分布和大量技术创新，Netscape Navigator 迅速成为主导标准。\n\n望远镜(Spyglass)和 Internet Explorer尽管 Netscape 取得了成功，但它并没有杀死 Mosaic。为了将他们的浏览器货币化，NCSA 将他们的商业资产分拆成一家名为Spyglass的公司。Spyglass 与 Netscape 竞争了一段时间，直到世界上最强大的软件公司微软进入网络浏览器市场。因此，他们从 Spyglass 获得了 Mosaic 许可，并创建了一个名为 Internet Explorer (IE) 的新浏览器。第一次浏览器战争由此开始。\n\n第一次浏览器战争在 1990 年代中期，Netscape 是硅谷的宠儿。Netscape 的商业模式建立在销售 Navigator 之上。但微软的大部分收入来自销售Windows 95和微软Office。为了抢占浏览器市场，Microsoft 决定将 Internet Explorer 与 Windows 98 的每个副本捆绑在一起。不仅捆绑在一起，而且集成到操作系统中(免费赠送 Internet Explorer)。在 Windows 98 中，计算机默认使用 IE。\n网景分崩离析Netscape 通过向他们的产品添加更多功能来回击。他们将 Navigator 4.0 集成到名为 Netscape Communicator 的应用程序套件中。这包括浏览器以及电子邮件客户端、HTML 编辑器、新闻聚合器和其他 Internet 实用程序。但随着 Netscape 添加更多功能，它们的代码库变得笨拙。\n1998 年初，Netscape 创建了一个非盈利基金会来创建开源代码库。他们以他们的吉祥物 Mozilla 命名基金会。Mozilla 基金会有潜力，但 Netscape 作为一个商业实体继续受到影响。那年晚些时候，他们与AOL合并。这也帮助他们免费提供他们的浏览器，但随着 Windows 98 接管桌面，为时已晚。在短短几年内，甚至 AOL 也转向了 Internet Explorer。Netscape的时代过去了。\n\n微软的胜利通过将 Internet Explorer 与 Windows 以及 Mac OS 捆绑在一起，微软完全占领了市场。到 2002 年，Internet Explorer 占据了超过 95% 的市场份额。微软赢得了第一次浏览器战争。然后他们固步自封。当Windows XP时，微软已经停止创新。他们认为 IE 只是操作系统的另一部分，就像纸牌一样。随后几年停滞不前，但随着 Web 的发展和变化，新产品将从 Netscape 的灰烬中崛起。几乎被遗忘的 Mozilla 项目将再次挑战 IE，为第二次浏览器战争开辟道路。\n参考资料：The First Browser War http://steve-lovelace.com/the-first-browser-war/\n欢迎关注我的微信公众号，扫描下方二维码，就可以找到我，我会持续为你分享 IT 技术和珠宝知识。\n\n也可以关注我的个人博客:点我试试的个人博客\n点我试试的个人博客\n","slug":"互联网发展简史(5)第一次浏览器大战","date":"2021-06-04T01:00:00.000Z","categories_index":"总结","tags_index":"互联网,历史","author_index":"明说网络"},{"id":"5d2e184bda0a232f0b0f257b7b58fa39","title":"互联网发展简史(4) WWW","content":"互联网发展简史(4) WWW\n万维网(World Wide Web, WWW)是可以通过一种被称为超文本传输协议(HTTP)来搜索和检索网站。该协议简化了地址的书写（使用前面所说的DNS系统），自动在互联网上搜索指定的地址，并自动调出文件查看，正如你现在浏览本文时看到的一样，不过那时候可没有现在这么酷。\n万维网万维网的概念是1989年由Tim Berners-Lee和CERN(日内瓦的欧洲高能物理中心)的科学家们设计(前文说过研究资料在网上开放，但是需要自己检索，但他们觉得检索文件太麻烦，为了简化检索程序，提出了万维网的概念)。1990年，他们开发了一个“浏览器&#x2F;编辑器”程序，并命名为“万维网”(World Wide Web)。该程序在ftp网站上免费发布，这极大的简化了检索程序。 这个系统可以让链接隐藏在文本后面(使用超文本标记语言，HTML)，点击“鼠标”就可以激活。但这种新系统似乎并没有迅速应用起来，到1992年底，世界上只有50个网站，一年后这个数字仍然不超过150个。\n\n上面的图片显示了1994年浏览器技术的“最先进”(早期版本不支持颜色，徽号和图表也在不同的窗口中)。\n点燃WebMosaic(马赛克)1993年，NCSA(美国国家超级计算应用中心，伊利诺斯州)的Mark Andreesen推出了Mosaic x(没错，这就是后来的网景浏览器，中文翻译可以叫做马赛克… …互联网历史上第一个获普遍使用和能够显示图片的网页浏览器)。它易于安装、使用，而且有24小时的客户支持。它还极大地提高了图形功能和安装的许多我们现在熟悉的特性(被后来Netscape Navigator和比尔·盖茨的Internet Explorer继承)。像其他许多互联网创新一样，Mosaic的试用版也免费提供给教育社区。Mosaic x很快就成为了一个大热门。到1994年，在世界各地的计算机上安装了成千上万个版本。\n\n\n\n\n\n\n\n\n\n当时的Mosaic开发的中心人物Mark Andreesen(这哥们曾经说，在网景面前，Windows只是一堆设计拙劣的驱动程序)和Silicon Graphic(计算机绘图用的高性能计算机制造公司，简称为SGI)公司的创始人吉姆·克拉克设立了「MOSAIC Communication Corp.」，这家公司之后1994年11月改名为「Netscape Communication Corp.」，中译为网景。于1997年1月7日正式终止开发和支持\n虽然网景消失了，但是从html的img标签开始，到创造javascript，开创SSL，奠定了未来几十年的互联网Web基础，当年的星星之火现已燎原。\n第一次浏览器大战后，在1998年网景公开了浏览器源代码，并将其命名为Mozilla。2004年基于Mozilla源代码，另一个杰出的浏览器诞生了，它就是Firefox（火狐）\n笔者认为，这个公司在互联网历史上真的是神一样的存在。\n\n\nHTML可以创建具有吸引力的图形网站，这些网站可以通过新一代的浏览器轻松访问，这为全新的群体打开了Web。\n到目前为止，Web已经服务于两个主要社区——科学界(访问在线文档)和更广泛的“网民”(网民)社区(访问电子邮件和新闻组设施)。现在商业网站开始大量涌现，紧随其后的是不远处的当地学校&#x2F;俱乐部&#x2F;家庭网站。功能更强大(也更便宜)的个人电脑(增加了网民数量和潜在的商业市场)的出现，以及通信基础设施容量的增加，加速了这些发展。\n蓬勃发展1994年，有3,200万个主机和3,000个网站。12个月后，主机数量翻了一番，网站数量攀升至2.5万个。到第二年年底，主机的数量又翻了一番，网站的数量也增加了十倍以上。顺便提一下，在那一年，莱顿大学历史系建立了自己的网站，使其网站成为有史以来第一批的网站之一。第二年，我们开设了“历史学家的互联网”课程，在经济和社会历史板块内，我们开始开发“基于课程”的网站(云课堂？？？)。这一切都发生在1997年，当时集成到网络的主机数量已经达到了1,950万台，而网站的数量已经激增到1,200万台。据2001年1月的最新统计，主机数量达到1.1亿，网站数量达到3000万。\n互联网和网络之间的区别是什么?Tim Berners-Lee(没错，就是提出万维网概念的那个哥们)经常被问到同样的问题，他的回答是:\n\n“互联网(‘Net’)是网络的网络。基本上它是由电脑和电缆制成的。Vint Cerf 和 Bob Khan所做的是弄清楚如何用它来发送小“包”的信息。正如Vint Cerf 指出的，数据包有点像明信片，上面有一个简单的地址。如果你把正确的地址放在一个数据包上，并把它交给任何一台作为网络一部分相连的计算机，每台计算机就会找出下一条电缆将它发送下去，这样它就能到达目的地。这就是互联网的作用。它可以在一秒钟之内将数据包发送到世界上的任何地方。\n网络是一个抽象的(想象的)信息空间。\n在互联网上，你可以找到电脑——在Web上，你可以找到文件、声音、视频，….信息。\n在互联网上，连接是计算机之间的电缆;在Web上，连接是超文本链接。\n互联网的存在是由于网络上计算机之间通信的程序。没有互联网就没有Web。万维网使互联网变得有用（现在这个说法好像不太准确），因为人们对信息真的很感兴趣(更不用说知识和智慧了!)，而不是真的想知道关于计算机和电缆的知识。\n\n\n\n参考资料Chapter Two: From ARPANET to World Wide Web\n欢迎关注我的微信公众号，扫描下方二维码，就可以找到我，我会持续为你分享 IT 技术和珠宝知识。\n\n也可以关注我的个人博客:点我试试的个人博客\n点我试试的个人博客\n","slug":"互联网发展简史(4) WWW","date":"2021-06-03T01:00:00.000Z","categories_index":"总结","tags_index":"互联网,历史","author_index":"明说网络"},{"id":"c7a457163a6f4d52d27ef049f0b12c55","title":"互联网发展简史(3)从Internet到WWW","content":"新品ISN潮流质感钻石G项链气质百搭款\n\n前文讲到，TCP&#x2F;IP协议助力ARPANET统一了网络协议标准，自此使用TCP&#x2F;IP协议标准的Internet诞生了。\n到目前为止，网络的发展几乎完全是“科学主导的”，本节我们将讲述Internet到万维网(WWW)的发展。\n网络出现瓶颈此前计算机能力和速度的并行进步使Internet得以扩张。但规模扩张的同时也带来了问题。\n到20世纪80年代初，当互联网正式开始运营时\n\n连接到网络上的计算机“主机”比最初设想的要多(1984年主机的数量首次超过1000台);\n每台主机的流量要大得多(主要是因为电子邮件的成功)。\n\n越来越多的人预言，整个网络最终会陷入瘫痪。\n解决网络瓶颈这一时期产生了两个重要事件，有效的缓解了网络瓶颈，并促进了网络的发展：\n第一个重要的发展是1984年引入的域名服务器(Domain Name System)。\n\nDNS系统使得主机的名称更容易记住，用户不用去记住每一个又数字组成的IP地址，如116.25.XXX.XXX，而是类似于www.example[.]com的容易记住的名字。\nDNS系统在互联网地址中引入了一些分层结构,更加利于组织众多域名和主机，如edu(教育),com(商业)、gov(政府)和org(组织)和一系列国家代码。\n\n第二个是各国政府决定鼓励在整个高等教育系统中使用互联网，并制定了一系列利好政策，促进了互联网的进一步统一和繁荣。\n1984年，英国政府宣布建立JANET(联合学术网络)，为英国大学服务；1985年，基于同样的目的，美国国家科学基金会(National Science Foundation)建立了国家科学基金网(NSFNet)(为其提供资助的条件是，“校园内所有合格用户”都必须能够访问该网络)。美国的这项计划涉及了一系列对互联网发展至关重要的决定：\n\n所有参与者都必须使用TCP&#x2F;IP协议\n\n联邦机构将分担建立公共基础设施(如跨洋连接)的费用并支持网关\n\nNSFNet与其他科学网络(包括阿帕网ARPANet)签署了共享基础设施的“no-metered-cost”协议，为所有后续协议做出了示范。\n\n鼓励进一步国际合作\n\nNSFNet同意为美国互联网服务提供“主干”，并提供5台“超级计算机”来服务通信。第一批计算机提供每秒56 000字节(56KB&#x2F;s)的网络能力\n\n\n\n\n\n\n\n\n\n国家科学基金网（NSFNet）的建立对互联网产生了巨大的影响。\n\n首先，它打破了网络的容量瓶颈。\n\n其次，它促进了互联网使用的激增。之前用了十年的时间，联网的主机数量才突破了千台大关；到1986年，主机的数量已经达到5000台，一年后这个数字攀升到28000台。\n\n\n\n\n\n\n互联网商业化发展我们注意到，之前网络的参与者基本上没有商业用户，这是由于NSFNet将商业用户排除在其网络之外。\n虽然NSFNet将商业用户排除在网络之外，但并不意味着他们的对互联网不感兴趣。多年来，硬件和软件供应商一直在将TCP&#x2F;IP添加到他们的产品包中，但他们对产品如何工作缺乏经验，因此他们在提供满足需求的产品方面遇到了困难。这时，互联网活动委员会(IAB)迈出了一步：\n1985年，IAB组织了第一个专门针对私营部门的研讨会，讨论TCP&#x2F;IP协议的潜力(和目前的限制)， 这次讨论在在政府&#x2F;学术科学家和私营部门之间，以及私营企业家之间进行。其中一个重要的内容就是：确保他们的产品的互操作性\n“晦涩难懂”的互联网到1989年，主机的数量首次超过了10万，并在一年后攀升至30万。\n但在这个阶段，互联网仍然只是少数人内行的网络，对外行来说仍然是一个相当令人生畏的地方。例如：查找数据的访问命令从复杂到难以理解，可用的文档大多是(高度)科学的，显示不吸引人(信使脚本，没有颜色)，寻找东西是一件棘手的事情，传输时间相对较慢)。对商业部门的主要吸引力是电子邮件设施和使用电子邮件、新闻组、“聊天”设施和电脑游戏。\n互联网发展的分界点转眼来到了上世纪80年代末和90年代初，这个时间点是互联网发展的一个分界点，原因有几个：\n\n1990年，阿帕网(1983年被剥夺了军事研究功能)成为了自身成功的牺牲品。\n1990年，蒙特利尔麦吉尔大学开发了第一个用于查找和检索计算机文件的互联网搜索引擎Archie。\n1991年，美国国家科学基金会取消了对私人访问其骨干计算机的限制，\n“信息高速公路”项目应运而生。这是为了普及戈尔的高性能计算法案而起的名字，该法案为进一步研究计算和改善美国互联网结构的基础设施提供了资金。\n1992- 1996年期间，其最大拨款为国家科学基金15亿美元，NASA 6亿美元，能源部660美元。\n1991年，万维网(WWW)问世\n\n下一节，我们将讲述WWW(万维网)的发展。敬请关注。\n参考资料：[1] Chapter Two: From ARPANET to World Wide Web\n欢迎关注我的微信公众号，扫描下方二维码，就可以找到我，我会持续为你分享 IT 技术和珠宝知识。\n\n也可以关注我的个人博客\n点我试试的个人博客\n","slug":"互联网发展简史(3)","date":"2021-06-01T13:00:00.000Z","categories_index":"总结","tags_index":"互联网,历史","author_index":"明说网络"},{"id":"4f4a3f49aadb725ec5f1304e6694920e","title":"互联网发展简史(2)从ARPANET到Internet","content":"今日珠宝\n\n原文为知乎，现转移到个人博客。知乎原文\n原文为微信公众号文章，现转移到个人博客。微信公众号原文\n互联网发展简史(2) 从ARPANET到Internet前文我们说到，ARPANET诞生了。\n点我试试：互联网发展简史(1)互联网雏形ARPANET的诞生1 赞同 · 2 评论文章\n实际上，这个时候ARPANET还相当的初级：我们从一个终端、一个主机、一个键盘和一台计算机互联的感觉开始说起，它们通过电缆连接在一起。\n通过输入计算机识别的命令，您可以使用存储在其计算机中的程序，访问其文件（并根据需要修改和打印）。大多数人都可以在一栋建筑或建筑群中设想这种设计。\n为了访问在一个完全不同设施中的另一台计算机，我们必须首先到达它。这通常是在这些时候通过（高速）电话线完成的。一旦你到达了新的“主机”，你就必须说服它像对待自己系统中终端后面的人一样对待你。因此，需要一个接口消息处理器（IMP），并在两台计算机上安装相同的IMP！(1968年由ARPA牵头完成设计)\n现在你可以访问它的文件了。当然，为了保护机密性，所有计算机都将“打开的”文件和受密码保护的文件区分开来。如果您想将文件或程序传输到您自己的计算机，主机将使用一个程序将其分解为“包”，每个包都附有地址及其原始位置。然后，它将它们发送到你的“家庭”计算机，在那里镜像程序按照原始顺序重新组装消息。将来，你可以从你的基地访问它们。\n当处理像ARPANET这样的“简单”网络时，很难看出这个过程的真正优势是什么。但这很快就发生了改变。。。\nARPANET公开亮相1972年10月，ARPANET公开亮相。在华盛顿举行的第一届国际计算机与通信会议上，ARPA的科学家们演示了这个系统：ARPANET将来自40个不同地点的计算机连接在了一起。\nARPANET发展美国国防部高级研究计划局(ARPA)的科学家们并没有躺在过去的功劳簿上，他们正在改进ARPANET系统，扩大其能力。\n\n1972年，他们成功地采用了一种新的程序，即我们现在所称的电子邮件，允许在网上发送信息，允许人与人之间的直接交流。\n同样在70年代早期，科学家们开发了主机(host)对主机的协议。 在此之前，系统只允许一个“远程终端”访问每个单独主机的文件。 新的协议允许访问主机的程序(在连接期间有效地将两台主机合并为一台)。\n1974年，ARPA的科学家们与斯坦福大学的专家们密切合作，开发出一种使不同的网络能够相互交流的“共同语言”。这被称为传输控制协议&#x2F;互联网协议(TCP&#x2F;IP)。TCP&#x2F;IP的发展标志着网络发展的一个关键阶段，现如今使用最广泛的协议仍然是TCP&#x2F;IP协议，其分层、解耦合的设计是他生命力所在。反思设计概念中固有的含义非常重要。一个关键的概念是，该系统应具有“开放式体系结构”，实际上实现了利克利德（Leonard Klienrock）关于“银河网络”的原始想法：\n\n\n\n\n\n\n\n\n\n\n一个未来的愿景，电脑将联网，每个人都能访问(a futuristic vision where computers would be networked together and would be accessible to everyone)\n“银河网络”的原始想法\n每个网络都应该能够独立工作，不受限制地开发自己的应用程序，并且无需修改即可加入互联网\n在每个网络中都会有一个“网关”，将其连接到“外部世界”。这将是一台更大的计算机（为了处理流量），配备必要的软件来传输和重定向任何“包”。\n此网关软件不会保留有关通过的流量的任何信息。这是为了减少工作量和加快流量，但也消除了可能的审查和控制手段，数据包将通过最快的可用路线发送。\n如果一台计算机被阻塞或运行缓慢，软件包将通过新的服务器重新路由，直到最终到达目的地\n网络之间的网关始终是开放的，它们可以毫无歧视地路由流量\n这项发展还隐含着，所有网络都可以免费获得操作原则（the operating principles would be freely available to all the networks）。这种设计信息的释放是早期研究环境的一个组成部分，并极大地促进了后来的技术进步\n\n值得记住的是，在现阶段，我们仍然处在一个几乎只讨论大型主机（仅由大公司、政府机构和大学拥有）的世界中。因此，设计该系统的目的是希望它能够通过数量有限的国家（子）网络工作。直至目前，互联网依旧没有超出这个设计。\n各种NET的”百家争鸣”前面讲到ARPANET的公开亮相，激发了整个西方世界科学界对互联网的进一步的研究。很快其他的网络也出现了。在这个阶段，各类网络各自为战，提出了自己的技术和协议。华盛顿会议还成立了一个互联工作组(IWG，Internetworking Working Group)来协调正在进行的研究。例如：\n\n1974年，斯坦福大学开通了Telenet，这是第一个公开访问的公共“分组数据服务”(ARPANET的商业版本)。\n上世纪70年代，美国能源部为磁性聚变能的研究人员建立了MFENet，这催生了致力于高能物理的HEPNet。这启发了NASA的物理学家们建立了空间物理学家SPAN。\n1976年，美国电话电报公司贝尔实验室开发了一种Unix-to-Unix协议，并免费分发给所有使用Unix的计算机用户(因为Unix是大学使用的主要操作系统，这为学术界打开了网络的大门)。\n在1979年Usenet建立，一个开放的系统专注于电子邮件通信和致力于“新闻组”的开放，并仍然蓬勃发展到今天。\n在1981年，纽约城市大学开发了Bitnet，用来连接美国东部大学的科学家，使用IBM计算机，不管学科。\nCSNet由美国国家科学基金会资助，旨在促进大学、工业和政府计算机科学家的交流。\n1982年，欧洲版本的Unix网络Eunet建立，连接了英国、斯堪的纳维亚和荷兰的网络。\n1984年又建立了欧洲版本的Bitnet，称为EARN(欧洲学术和研究网络)。\n\n在这一时期，世界仍然相当混乱，有过多的相互竞争的技术和协议，各种计算机网络之间没有标准的通信方式。但ARPANET仍然是整个系统的主干。\n\nTCP&#x2F;IP一统天下随着越来越多的网络挂接到ARPANET上，网络互联变得越来越重要。\n1973年，Robert Kahn和Vinton Cerf合作开发了一种将多个网络连接在一起的协议。这后来成为传输控制协议&#x2F;互联网协议（TCP&#x2F;IP），这是一种将多个网络连接在一起的技术。这使得不同网络上的不同类型的计算机能够相互“交谈”。1983年1月1日，ARPANET和国防数据网络正式改为TCP&#x2F;IP标准，由此诞生了互联网。所有网络现在都可以通过通用语言连接起来。\n最终在1983年， TCP&#x2F;IP 协议统一了天下，成为了标准，使用TCP&#x2F;IP标准的互联网诞生了！\n下一期，我们将讲述：从Internet到WWW，从因特网到万维网。敬请关注\n参考连接：‌[1] Chapter Two: From ARPANET to World Wide Web , \n[‌2] 关于互联网的由来和发展简史\n\n 欢迎关注我的微信公众号，扫描下方二维码，就可以找到我，我会持续为你分享 IT 技术和珠宝知识。\n\n也可以关注我的个人博客\n点我试试的个人博客\n","slug":"互联网发展简史(2)","date":"2021-05-31T16:00:00.000Z","categories_index":"总结","tags_index":"互联网,历史","author_index":"明说网络"},{"id":"8d4902c1935b049d5d1f9b7dd1b3e316","title":"互联网发展简史(1)ARPANET的建立","content":"原文为知乎，现转移到个人博客。知乎原文\n原文为微信公众号原文，现转移到个人博客。微信公众号原文\n\n[toc]摘要：冷战初期，为了对抗苏联的太空计划，美国成立了ARPA来研发高新技术，以制衡苏联。ARPANET作为ARPA的一项计算机网研究项目，不经意间孕育了风靡世界的互联网。\n\n\n20世纪50年代 ARPA成立想要了解互联网的起源，我们必须追溯到美苏争霸之初的20世纪50年代，那时候，冷战（1947年—1991年之间）开始没有多久，两强争霸正如火如荼的进行着。\n1955年，美国总统艾森豪威尔宣布，美国希望发射一颗小型地球轨道卫星，而克里姆林宫也宣布这样的类似计划。在具体执行方面：美国将计划集中在精密的三级火箭上，但苏联却采取了更直接的方法：把四枚军用火箭绑在一起！并且真的实现了。\n\n\n另一件事是，1957年8月27日，苏联塔斯社（ITAR-TASS，现为俄罗斯通讯社）发布公告：“1957年8月21日，世界上第一枚多级远程弹道火箭向太平洋进行全程发射试验成功”。通过公告，苏联向全世界宣布自己可以瞬间攻击地球上的任何地区。这意味着苏联可以将核弹送往地球上的任何地区。\n一夜之间，苏联的行为冲击了美国自13年前第一颗核弹爆炸以来一直享有的“无懈可击”的感觉，感受到了来自苏联的技术赶超所带来的“威胁”。针对苏联这一行动，美国的立即反应之一就是：在国防部(Defense of Department)内设立了高级研究计划局(Advanced Research Projects Agency，ARPA)。高级研究计划局的任务是将最先进的技术应用于美国国防，避免敌人的技术超越。‌\nARPA在当时的地位毋庸置疑。ARPA拥有几百名顶级科学家，并拥有足够的预算将研究分包给美国其他顶级机构（举国之力，不是吗？）；在1958年10月美国国家航空航天局成立之前，ARPA还被授予了美国卫星计划的临时控制权，足以见得当时ARPA的权利。ARPA一瞬间成为了美国国防的技术智囊团。\nARPA最初的活动重点是空间、弹道导弹和核试验监测（符合冷战的预期），并不是网络，但无心插柳柳成荫，网络却恰恰是ARPA最成功的项目之一。\n从一开始，ARPA就有一个重要的需求，资源互通系统。ARPA体系内的技术专家分散于全国各地，资源无法及时对接；不同的机构，不同的研究之间需要经常通信和资源共享，这使得ARPA对资源互通系统很感兴趣，尤其是各种计算机之间的直接连接的通信系统。\n另一方面，核威慑下，这种通信需要具有抗毁性。美国国防部不得不考虑在核打击后仍能传播信息，而不丢失相关技术资料。这为ARPA研究计算机网埋下了伏笔\n1962年阿帕网(ARPANET)计算机网络系统研究计划真正互联网的历史开始于20世纪60年代\n1962年，ARPA启动了一个计算机研究项目，并任命麻省理工学院(MIT)的科学家约翰·利克利德(John Licklider)为负责人。妥妥的互联网名人堂：\n\n\n\n\n\n\n\n\n\n1962年，约瑟夫·卡尔·罗布内特·利克利德博士在一系列讨论“银河网络”的备忘录中阐述了全球联网的最早想法。他既受人喜爱又受人尊敬，多次表现出惊人的先见之明。他的独创性和远见概括了当今互联网提供的许多功能：图形计算、用户友好界面、数字图书馆、电子商务、网上银行和云计算。1963年，当他担任美国国防部高级研究计划局（ARPA）主任时，正是利克利德博士对建立计算机分时网络所面临的挑战的有说服力的详细描述最终导致了ARPA网的诞生。1968年，他发表了一篇名为“计算机作为通信设备”的论文，阐述了他对网络应用的看法，并预测了计算机网络在通信中的应用。在此之前，计算机通常被认为是加速计算的数学设备。ARPAnet最终被互联网所取代，在ARPANET正式关闭的同一年——1990年——利克利德博士去世，享年75岁。\n在ARPA期间，Leonard Klienrock的研究是（实际上小伙伴还有Leonard Kleinrock, Thomas Merrill 和 Lawrence G. Roberts）：如何将信息分解成“数据包”，将它们分别发送到目的地，然后在另一端重新组装，也就是我们现在所熟知的“分组路由”的雏形。分包发送使得发送信息更具灵活性，例如具有安全优势：系统将不依赖于单个路由、单条链路；如果文件在传输前被分割为多个数据包，那么消息将更难以被窃听等。\n\n\n\n\n\n\n\n\n\n那时候，Licklider刚刚发表了他关于“银河网络”概念的第一份备忘录……一个未来的愿景，电脑将联网，每个人都能访问(a futuristic vision where computers would be networked together and would be accessible to everyone)。\n那时候的广域网严格来说还是电话网，存在很多问题。1965年，伯克利和麻省理工学院的计算机通过低速拨号电话线连接起来，成为有史以来第一个“广域网”(WAN)，但电话网络在运行程序和传输数据方面的存在诸多不足，如低速，抗毁性差等。在当时，所有的军用网络都是电话网，非常的脆弱。但作为军事网络来说，抗毁性是第一位的，尤其是在美苏争霸的背景下，因为谁也不知道核弹会在什么时候落下。\n‌直到1966&#x2F;67年，相关的研究工作足以支持ARPA的计算机研究部的计算机网络系统的研究计划。这时，新主管伦纳德·罗伯茨(Leonard Roberts)立即发布了名为阿帕网(ARPANET)的研究计划。\n计划发布之后，麻省理工学院,国家物理实验室(英国),兰德公司的团队都积极参与广域网(wide area networks)可行性的研究，而他们的最佳创意都将纳入阿帕网的设计。\n这个计划最终的要求是：设计一个允许计算机发送和接收消息和数据的协议，也就是总所周知的“接口消息处理器”(IMPs)。\n假如将互联网类比成以前的邮电网络，IMP就是该网络中遍布各地的邮局，负责邮件（数据）的存储和转发。若一个数据到达某个IMP，目的地又是该IMP连接的计算机，那么数据就会直接输送至目的地；反之，IMP会将数据转发至新的IMP传递，履行分布式网络节点传输的“中转”职能，是当今互联网不可或缺的硬件路由器的前身。\n最终，IMPs的相关工作于1968年完成，是时候将理论付诸于实践了。\n‌1969年互联网雏形诞生了1969年10月，IMPs安装在加州大学洛杉矶分校和斯坦福大学的计算机上，并进行了联通性的实验。实验是成功的，加州大学洛杉矶分校的学生“登录”了斯坦福大学的计算机，并访问其数据库、发送数据。网络的雏形已经形成。\n到1969年12月，阿帕网由四台主机组成。‌‌美军在ARPA（阿帕网，美国国防部研究计划署）制定的协定，该协定下将美国西南部的大学UCLA(加利福尼亚大学洛杉矶分校)、Stanford Research Institute(斯坦福大学研究学院)、UCSB(加利福尼亚大学)和University of Utah(犹他州大学)的四台主要计算机相连\n\n到1970年6月，MIT(麻省理工学院)、Harvard(哈佛大学)、BBN和Systems Development Corp in Santa Monica(加州圣达莫尼卡系统发展公司)加入进来。到1972年1月，Stanford(斯坦福大学)、MIT’s Lincoln Labs(麻省理工学院的林肯实验室)、Carnegie-Mellon(卡内基梅隆大学)和Case-Western ReserveU加入进来。\n紧接着的几个月内NASA&#x2F;Ames(国家航空和宇宙航行局)、Mitre、Burroughs、RAND(兰德公司)和the Uof Illinois(伊利诺利州大学)也加入进来。到1971年12月，阿帕网将23台主机相互连接起来。\n\n由此，ARPANET成为现代计算机网络诞生的标志，第一个真正意义上的计算机网络诞生。\n‌\n参考连接：‌[1] Chapter Two: From ARPANET to World Wide Web , \n[‌2] 关于互联网的由来和发展简史\nThe History of the Internet, Chapter Twowww.let.leidenuniv.nl/history/ivh/chap2.htm#The%20Creation%20of%20ARPANET\n关于互联网的由来和发展简史baijiahao.baidu.com&#x2F;s?id&#x3D;1639113082776464538&amp;wfr&#x3D;spider&amp;for&#x3D;pc\nhttps://online.jefferson.edu/business/internet-history-timeline/online.jefferson.edu/business/internet-history-timeline/\nA Brief History of the Internetusg.edu&#x2F;galileo&#x2F;skills&#x2F;unit07&#x2F;internet07_02.phtml\nhttps://www.internetsociety.org/internet/history-internet/brief-history-internet/www.internetsociety.org/internet/history-internet/brief-history-internet/\n纪念ARPANET诞生50周年：互联网发展史-中国教育和科研计算机网CERNETwww.edu.cn/info/focus/rd_xin_wen&#x2F;202001&#x2F;t20200102_1703268.shtml\n资料：\n互联网简史，袁载誉，中国经济出版社，2020年5月\n欢迎关注我的微信公众号，扫描下方二维码，就可以找到我，我会持续为你分享 IT 技术和珠宝知识。\n\n也可以关注我的个人博客\n点我试试的个人博客\n","slug":"互联网发展简史(1)","date":"2021-05-29T16:00:00.000Z","categories_index":"总结","tags_index":"互联网,历史","author_index":"明说网络"},{"id":"158651fee9d411bd24619607a126b812","title":"Linux系统下的系统资源和网络资源控制","content":"今日珠宝宝格丽BVLGARI系列戒指\n18K玫瑰金材质镶嵌7颗钻石，非常经典优雅的设计风格。指圈大小63号（正品实拍）\n\n原文为知乎，现转移到个人博客。知乎原文\nLinux系统下的系统资源和网络资源控制众所周知，在互联网诞生之初都是各个高校和科研机构相互通讯，并没有网络流量控制方面的考虑和设计，IP协议的原则是尽可能好地为所有数据流服务，不同的数据流之间是平等的。然而多年的实践表明，这种原则并不是最理想的，有些数据流应该得到特别的照顾， 比如，远程登录的交互数据流应该比数据下载有更高的优先级。\n同样，我们希望操作系统内的资源也是不平等的，我们总是希望某些进程占用更多的资源，以满足我们当前最迫切的需求，比如看电影的时候，我们希望视频播放器更多的资源，而不希望这个时候浏览器占用过多的资源。\n因此细粒度的对操作系统资源的控制是我们每一个人都想做的事，自己的地盘自己做主。\n限制系统资源在Linux上限制系统资源主要使用的工具是cgroup.\n基本语法不在赘述，相关文章很多见参考资料。我们想限制的系统资源主要是CPU，内存还有IO设备(例如，硬盘读写速度)。在Linux系统中，这些资源的分配和管理都由相应目录/cgroup/cpu/,/cgroup/memory ,/cgroup/blkio下配置。下面举例进行说明：例如你想建一个cpu控制策略，取名为foo,则你只需要在目录/cgroup/cpu/中mkdir foo，操作系统会为你创造一些列文件，就可以用操作文件的方式控制你的系统了。如下例：\ncpu限制实例1. [root@localhost &#x2F;]# mkdir -p &#x2F;cgroup&#x2F;cpu&#x2F;foo&#x2F; \n2. [root@localhost &#x2F;]# mkdir -p &#x2F;cgroup&#x2F;cpuset&#x2F;foo&#x2F; \n3. [root@localhost &#x2F;]# echo 50000 &gt; &#x2F;cgroup&#x2F;cpu&#x2F;foo&#x2F;cpu.cfs_quota_us \n4. [root@localhost &#x2F;]# echo 100000 &gt; &#x2F;cgroup&#x2F;cpu&#x2F;foo&#x2F;cpu.cfs_period_us \n5. [root@localhost &#x2F;]# echo &quot;0&quot; &gt; &#x2F;cgroup&#x2F;cpuset&#x2F;foo&#x2F;cpuset.mems \n6. [root@localhost &#x2F;]# echo &quot;1&quot; &gt; &#x2F;cgroup&#x2F;cpuset&#x2F;foo&#x2F;cpuset.cpus \n7. [root@localhost &#x2F;]# echo 28819 &gt; &#x2F;cgroup&#x2F;cpu&#x2F;foo&#x2F;tasks  \n\n\n\n内存限制实例1. [root@localhost &#x2F;]# mkdir -p &#x2F;cgroup&#x2F;memory&#x2F;foo \n2. [root@localhost &#x2F;]# echo &gt; &#x2F;cgroup&#x2F;memory&#x2F;foo&#x2F;memory.limit_in_bytes \n3. [root@localhost &#x2F;]# echo 44476 &gt; &#x2F;cgroup&#x2F;memory&#x2F;foo&#x2F;tasks  \n\n\n\n\n\n\n\n\n\n\n内存参数\ncgroup.event_control       #用于eventfd的接口\nmemory.usage_in_bytes      #显示当前已用的内存\nmemory.limit_in_bytes      #设置&#x2F;显示当前限制的内存额度\nmemory.failcnt             #显示内存使用量达到限制值的次数\nmemory.max_usage_in_bytes  #历史内存最大使用量\nmemory.soft_limit_in_bytes #设置&#x2F;显示当前限制的内存软额度\nmemory.stat                #显示当前cgroup的内存使用情况\nmemory.use_hierarchy       #设置&#x2F;显示是否将子cgroup的内存使用情况统计到当前cgroup里面\nmemory.force_empty         #触发系统立即尽可能的回收当前cgroup中可以回收的内存\nmemory.pressure_level      #设置内存压力的通知事件，配合cgroup.event_control一起使用\nmemory.swappiness          #设置和显示当前的swappiness\nmemory.move_charge_at_immigrate #设置当进程移动到其他cgroup中时，它所占用的内存是否也随着移动过去\nmemory.oom_control         #设置&#x2F;显示oom controls相关的配置\nmemory.numa_stat           #显示numa相关的内存\n\n\nIO限制实例1. [root@localhost ~]# mkdir -p &#x2F;cgroup&#x2F;blkio&#x2F;foo \n2. [root@localhost ~]# echo &#39;8:0  10485760&#39; &gt; &#x2F;cgroup&#x2F;blkio&#x2F;foo&#x2F;blkio.throttle.read_bps_device \n3. [root@localhost ~]# echo 45033 &gt; &#x2F;cgroup&#x2F;blkio&#x2F;foo&#x2F;tasks \n#  注2：8:0对应主设备号和副设备号，可以通过ls -l &#x2F;dev&#x2F;sda查看\n\n\n\n一个限制内存和CPU的具体例子之前在学习cgroup的时候，较多的都是减少原理和一些简单的例子，但这对直观的取理解cgroup还是有点障碍，所以学习的过程中，参考他人的博客结合自己的理解写了一个例子，供大家参考。\n例子分为两个部分\n0x01 被限制应用被限制应用是一个CPU消耗型，具体见下面代码\nint main(void)\n&#123;\n    int i = 0;\n    for(;;) i++;\n    return 0;\n&#125;\n\n直接编译，假如这里编译出的程序名为deadloop, top查看如下：\n PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND     \n31404 root  20   0    4220    656    588 R  98.7  0.0   8:45.27 deadloop\n\n\n\n0x02 限制规则这里我们做两个方面的工作：限制CPU使用率和限制内存。具体代码如下：\n# 增加规则代码\n#!&#x2F;bin&#x2F;bash\n# 规则集合在testdead\ngname&#x3D;&#39;testdead&#39;\nvalue&#x3D;50000\nprog&#x3D;$1\nmem_val&#x3D;1024000\n\nrmdir &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu&#x2F;$&#123;gname&#125;;\nrmdir &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memory&#x2F;$gname;\n\nmkdir &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu&#x2F;$gname;\nmkdir &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memory&#x2F;$gname;\n\necho $value | sudo tee &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu&#x2F;$gname&#x2F;cpu.cfs_quota_us;\necho $mem_val | sudo tee &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memory&#x2F;$gname&#x2F;memory.limit_in_bytes;\n\nfor x in $(pidof $prog)\ndo \n\techo $x  | sudo tee &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu&#x2F;$gname&#x2F;tasks;\n\techo $x | sudo tee &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memory&#x2F;$gname&#x2F;tasks\n\n\techo 0 | sudo tee &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memory&#x2F;$gname&#x2F;memory.swappiness\ndone\n\n# 删除规则代码\n#!&#x2F;bin&#x2F;bash\n\ndname&#x3D;testdead\n\ncgdelete cpu:$dname\n\n上述规则应用后，top查看如下：\n31404 root  20   0    4220    656    588 R  49.8  0.0   8:08.46 deadloop   \n\n可以看出，两次的CPU使用率不一样，显示出了cgroup的限制效果。\n限制网络资源背景Linux操作系统中，报文分组从输入网卡(入口)接收进来，经过路由的查找， 以确定是发给本机的，还是需要转发的。如果是发给本机的，就直接向上递交给上层的协议，比如TCP，如果是转发的， 则会从输出网卡(出口)发出。网络流量的控制通常发生在输出网卡处。虽然在路由器的入口处也可以进行流量控制，Linux也具有相关的功能， 但一般说来， 由于我们无法控制自己网络之外的设备， 入口处的流量控制相对较难。本文将集中介绍出口处的流量控制。\n相关概念流量控制（Traffic Control， tc）是Linux内核提供的流量限速、整形和策略控制机制。它以qdisc-class-filter的树形结构来实现对流量的分层控制\n在Linux中，流量控制都是通过TC这个工具来完成的。通常， 要对网卡进行流量控制的配置，需要进行如下的步骤:\n\n为网卡配置一个队列;\n\n在该队列上建立分类;\n\n根据需要建立子队列和子分类;\n\n为每个分类建立过滤器。\n\n\n\n基本组成从上图中可以看到，tc由qdisc、fitler和class三部分组成：\n\nqdisc通过队列将数据包缓存起来，用来控制网络收发的速度\n\n常见的classless qdisc有：choke, codel, p&#x2F;bfifo,fq, fq_codel, gred, hhf, ingress,mqprio, multiq, netem, pfifo_fast, pie, red, rr, sfb, sfq, tbf。linux默认使用的就是fifo_fast。\n常见的classful qdisc有：ATM, CBQ, DRR, DSMARK, HFSC, HTB, PRIO, QFQ\n\n\nclass用来表示控制策略\n\n分类只存在于可分类排队规则（classful qdisc）（例如，HTB和CBQ）中。\n\n\n\n\n\n\n\n\n\n\ndefault 这是HTB排队规则的一个可选参数，默认值为0， 当值为0时意味着会绕过所有和rootqdisc相关联的分类，然后以最大的速度出队任何未分类的流量。 \nrate 这个参数用来设置流量发送的最小期望速率。这个速率可以被当作承诺信息速率(CIR), 或者给某个叶子分类的保证带宽。 \nceil 这个参数用来设置流量发送的最大期望速率。租借机制将会决定这个参数的实际用处。 这个速率可以被称作“突发速率”。 \nburst 这个参数是rate桶的大小(参见令牌桶这一节)。HTB将会在更多令牌到达之前将burst个字节的数据包出队。 \ncburst 这个参数是ceil桶的大小（参见令牌桶这一节）。HTB将会更多令牌(ctoken)到达之前将cburst个字节的数据包出队。 \nquantum 这个是HTB控制租借机制的关键参数。正常情况下，HTB自己会计算合适的quantum值，而不是由用户来设定。对这个值的轻微调整都会对租借和整形造成巨大的影响，因为HTB不仅会根据这个值向各个子分类分发流量(速率应高于rate，小于ceil)，还会根据此值输出各个子分类中的数据。 \nr2q 通常,quantum 的值由HTB自己计算，用户可以通过此参数设置一个值来帮助HTB为某个分类计算一个最优的quantum值。\n\n\n\nfilter用来将数据包划分到具体的控制策略中\n\n包含了一个分类器实现，常见的分类器如u32，u32分类器可以允许用户基于数据包的属性来选择数据包。\n\n\n\n语法不再赘述，相关参考资料里有。\n入流量调度Linux中的QoS分为入口(Ingress)部分和出口(Egress)部分，入口部分主要用于进行入口流量限速(policing)，出口部分主要用于队列调度(queuing scheduling)。\n大多数排队规则(qdisc)都是用于输出方向的，输入方向只有一个排队规则，即ingress qdisc。ingress qdisc本身的功能很有限，但可用于重定向incoming packets。通过Ingress qdisc把输入方向的数据包重定向到虚拟设备ifb，而ifb的输出方向可以配置多种qdisc，就可以达到对输入方向的流量做队列调度的目的。\n\nIFB说明：\n\n\n\n\n\n\n\n\n\nIFB — Intermediate Functional Block device。Q: How can we use qdisc (e.g., netem) on incoming traffic?A: You need to use IFB. This network device allows attaching queueing disciplines to incoming packets.To use an IFB, you must have IFB support in your kernel (configuration option CONFIG_IFB). Assuming that you have a modular kernel, the name of the IFB module is ifb and may be loaded using the command modprobe ifb (if you have modprobe installed) or insmod /path/to/module/ifb.\nip link set ifb0 up\nip link set ifb1 up\n\nBy default, two IFB devices(ifb0 and ifb1) are created.IFB allows for queueing incoming traffic for shaping instead of dropping.\n参考资料:https://blog.csdn.net/eydwyz/article/details/53392227\n一个例子#!&#x2F;bin&#x2F;bash\n#fb驱动并创建ifb网卡(使用ifconfig -a 如果看到已有则无需该步骤)\n#分别为出设备和入设备\noutdevice&#x3D;ens33\nindevice&#x3D;ifb0\n\nmodprobe ifb numifbs&#x3D;1\n# up网卡\nip link set dev $indevice up\n\n# ------\n\t# 清除原有的根队列(根据实际情况操作,非必要) \n\ttc qdisc del dev $outdevice root 2&gt;&#x2F;dev&#x2F;null\n\ttc qdisc del dev $outdevice ingress 2&gt;&#x2F;dev&#x2F;null\n\ttc qdisc del dev $indevice root 2&gt;&#x2F;dev&#x2F;null\n \n\t#  将$outdevice的ingress流量全部重定向到 $indevice 处理\n\ttc qdisc add dev $outdevice handle ffff: ingress\n\ttc filter add dev $outdevice parent ffff: protocol ip u32 match u32 0 0 action mirred egress redirect dev $indevice\n\t \n\t# $outdevice的出向限速:$outdevice添加根队列,使用htb,添加1:1类,使用htb \n\ttc qdisc add dev $outdevice root handle 1: htb r2q 625 default 65\n\ttc class add dev $outdevice parent 1: classid 1:1 htb rate 1000Mbit\n\t \n\t# $outdevice的入向限速:$indevice添加根队列,使用htb,添加1:1类,使用htb \n\ttc qdisc add dev $indevice root handle 1: htb r2q 625 default 65\n\ttc class add dev $indevice parent 1: classid 1:1 htb rate 1000Mbit\n\t \n\t# $outdevice的出向限速:$outdevice设备添加子类\\对应的filter配置规则和子类的队列\n\ttc class add dev $outdevice parent 1:1 classid 1:10 htb rate 10Mbit\n\ttc filter add dev $outdevice parent 1: protocol all prio 1 u32 match ip dst 192.168.0.2 classid 1:10\n\ttc qdisc add dev $outdevice parent 1:10 handle 10: sfq\n\t \n\t# $outdevice的出向限速:$outdevice设备添加子类\\对应的filter配置规则和子类的队列 \n\ttc class add dev $outdevice parent 1:1 classid 1:11 htb rate 20Mbit\n\ttc filter add dev $outdevice parent 1: protocol all prio 1 u32 match ip dst 192.168.0.3 classid 1:11\n\ttc qdisc add dev $outdevice parent 1:11 handle 11: sfq\n\t \n\t \n\t# $outdevice的入向限速:$indevice设备添加子类\\对应的filter配置规则和子类的队列\n\ttc class add dev $indevice parent 1:1 classid 1:10 htb rate 10Mbit\n\ttc filter add dev $indevice parent 1: protocol all prio 1 u32 match ip src 192.168.0.2 classid 1:10\n\ttc qdisc add dev $indevice parent 1:10 handle 10: sfq\n\t \n\t \n\t# $outdevice的入向限速:$indevice设备添加子类\\对应的filter配置规则和子类的队列 \n\ttc class add dev $indevice parent 1:1 classid 1:11 htb rate 20Mbit\n\ttc filter add dev $indevice parent 1: protocol all prio 1 u32 match ip src 192.168.0.3 classid 1:11\n\ttc qdisc add dev $indevice parent 1:11 handle 11: sfq\n\n网络压力测试压力测试工具使用iperf网络测试工具\n\n\n\n\n\n\n\n\n\n常用参数指南（详见附录）：\n-c&#x2F;s：客户端模式&#x2F;服务端模式\n-p：指定iperf测试端口\n-i：指定报告间隔\n-b：设置UDP的发送带宽，单位bit&#x2F;s\n-t：设置测试的时长，单位为秒，不设置默认10s\n-l：指定包大小，TCP默认8k，UDP默认1470字节\n# 针对TCP进行带宽性能测试\n#服务端命令：\niperf -s -i 1 -p 3389\n#\niperf -c 192.168.158.128 -p 3389 -i 1\n\n#针对UDP进行带宽性能测试\n#服务端命令\niperf -u -s -i 1 -p 3389\n#客户端命令\niperf -u -c 192.168.158.128 -p 3389 -b 1500M -i 1 \n# 参考资料：iperf网络测试工具， https:&#x2F;&#x2F;cloud.tencent.com&#x2F;developer&#x2F;article&#x2F;1688469\n\n带宽查看使用工具iftop\n\n\n\n\n\n\n\n\n\nTX：发送流量\nRX：接收流量\nTOTAL：总流量\nCumm：运行iftop到目前时间的总流量\npeak：流量峰值\nrates：分别表示过去 2s 10s 40s 的平均流量\n\n执行脚本前后，对于网络带宽进行检测，发现流量带宽明显受到TC的控制。实验成功。\n总结本文通过对Linux操作系统中cgroup、tc的使用，实现了对Linux操作系统中系统资源和网络资源的控制。本文的方法和工具在写作过程中可能还有用到，但是没有写进来的，欢迎大家留言或通过微信公众号联系我，我会尽力为大家解答。\n其他补充如何获取进程ID根据进程名称获取pid 最简单的方法是使用 pidof 命令，用法：pidof  process_name，例如：\n# 查看初始进程的pid\npidof init\n# \n\n有事可能因为同一个名称的程序启动了多个进程，使用pidof时会返回多个pid，使用空格分开\n查找当前激活状态的网络链接及进程IDlsof -i -n（不反向解析DNS）\n# eg\nlsof -i -n | awk   &#39;&#123;print $2, $9&#125;&#39;\n# 输出为\n#PID NAME\n#29646 192.168.153.129:51044-&gt;13.250.177.223:https\n#29646 192.168.153.129:52970-&gt;54.149.208.57:https\n\nlsof -i -n -P  | awk &#39;&#123;print $1, $2,$5,$9&#125;&#39;\n# 输出时，不解析端口，应该将https-&gt;443\n\n\n\n参考资料：Linux 资源隔离机制 – CGroup https://zhuanlan.zhihu.com/p/47590418\nCGroup 介绍、应用实例及原理描述 https://www.cnblogs.com/caoxiaojian/p/5633430.html\n流量控制 https://tonydeng.github.io/sdn-handbook/linux/tc.html\nTraffic Control HOWTO https://tldp.org/HOWTO/Traffic-Control-HOWTO/\nLinux TC(Traffic Control)框架原理解析， https://blog.csdn.net/dog250/article/details/40483627\n linux下使用tc(Traffic Control) 流量控制命令模拟网络延迟和丢包\nTC流量控制 https://blog.csdn.net/who538592/article/details/79483323\n","slug":"资源保障","date":"2021-05-29T16:00:00.000Z","categories_index":"学习","tags_index":"Linux,系统管理,网络管理","author_index":"明说网络"},{"id":"4d9d98482a8c5e3d334a143c492b338d","title":"区块链中的密码学知识","content":"原文为知乎，现转移到个人博客。知乎原文转发微信公众号文章微信公众号原文\nTable of Contents\nBitCoin是什么\n密码学是什么\nBitCoin中的密码学知识1.  哈希(Hash)    2.  公钥密码体制\n总结\nReference\n\n\nBitCoin是什么BitCoin，又称比特币，是2009年中本聪提出了一种点对点的数字现金系统，是一种分布式、点对点的货币,允许在线的交易不用经过中心化机构（如银行，支付宝）的情况下，在网络合作支持下，直接由一个用户发往另一个用户,并且可以提供防篡改，可验证的能力。Bitcoin是最早实现“加密货币”这一概念的系统，该设想最早由戴伟（Dai Wei1,音译）于1998年在cypherpunks函件用户组首次提出的:货币可以是任何东西或记录，只要它在一个国家或社会经济体系内被接受为商品服务的支付方式，或是债务偿还的方式。比特币的设计核心思想是以密码学难题(cryptography puzzle)答案作为货币，其发行权独立于任何中央机构之外。\n比特币使用了公开密钥系统2. 每一个钱币都包括了其拥有者的公开秘钥。当钱币从用户A支付给用户B时, A将B的公开秘钥添加到钱币中, 然后这个钱币又被A用私人密码匙来签名。B现在即拥有了这个钱币并且可以将来使用，而A就不可能再次使用这个钱币，因为以前的交易记录以被全体网络计算机记录。在每笔交易前，钱币的有效性都必须经过检验确认。\n\n密码学是什么密码学是一种使用先进的数学原理以特定的形式存储和传输数据的方法，以便只有它的目标用户能够读取和处理数据。密码学已经被人们用来在不被发现的情况下转发信息。随着互联网及信息技术的飞速发展，密码学被赋予了新的含义。密码哈希，电子签名等被广泛使用在防篡改，身份认证等场合。当前有三种广泛使用的加密形式：对称加密、非对称加密和哈希。\n\nBitCoin中的密码学知识在中本聪的Bitcoin: A Peer-to-Peer Electronic Cash System一文中我们可以看见如下一段话，从这段话中我们可以看出密码学在BitCoin中的应用：\n\n\n\n\n\n\n\n\n\nWe define an electronic coin as a chain of digital signatures. Each owner transfers the coin to the next by digitally signing a hash of the previous transaction and the public key of the next owner and adding these to the end of the coin. A payee can verify the signatures to verify the chain of ownership.——Bitcoin: A Peer-to-Peer Electronic Cash System[1]\n下面就主要从哈希和 公钥密码体制两个方面介绍BitCoin中的密码学知识。\n\n哈希(Hash)哈希（有时称“摘要”,密码散列,Hashing）是文本或数据文件的经过压缩的一种”指纹”。 Hash函数是把任意长度的输入通过散列函数或者说是hash函数转化为固定长度的输出的一种算法。这个输入区间可以无穷大，但输出区间是固定的。比如输入可以是任意的，输出是一个3位数。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来确定唯一的输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。\nBitCoin中的hash函数主要有SHA-256，RIPEME-160，hash的一个主要应用是Merkle树,其中算法前缀“SHA”和”RIPEMD”表示基础算法，数字后缀”256”和”160”表示输出的固定长度。 \n在比特币协议中，SHA256和RIPEMD160一起用于保护数字签名中使用的公钥。SHA256方法也用于比特币挖掘中的工作函数证明，并作为数字签名算法的一部分。\n\nSHA-256\nSHA就是安全哈希算法（Secure Hash Algorithm）的简写。SHA-256为文本生成几乎唯一的256位（32字节）签名。另外，比特币挖矿（mining）的cryptograph puzzle也是通过计算满足一定条件的hash来完成的，例如计算的满足256bit位hash前缀满足60个0(由区块链中区块内部的nonce决定)的hash。\n\nRIPEME-160\nRIPEMD（RIPE Message Digest）是1992年（原始RIPEMD）和1996年（其他变体）开发的一系列密码哈希函数。 该系列有五个功能：RIPEMD，RIPEMD-128，RIPEMD-160，RIPEMD-256和RIPEMD-320，其中RIPEMD-160是最常见的,也是比特币中使用的Hash算法之一。\n之所以使用RIPEMD，是因为它产生了最短的哈希,用于生成比特币地址,这允许比特币地址更短。同时，其唯一性仍得到了充分保证。 \n\nMerkle Tree\nMerkle树是一种哈希树，其中叶节点是根据数据块计算的加密哈希，而非叶节点是其直接子节点的哈希。根散列也称为数据的“摘要”。\no要验证一个记录，它需要一个数据“证明”，其中包含根路径上的节点。递归地重新计算新的根散列，并使用先前保存的摘要检查相等性。\n如下图：例如L4被修改，那么hash1-1，hash1，top hash 都会被重新计算，最终显示为Top hash的变化，只需要对比Top hash 就能够知道节点中的数据有没有被篡改。\n\nMerkle 树将根存储在比特币区块中，验证者只用验证根的hash是否变化，就可以判断Merkle 树中的子节点是否被篡改，而不用验证全部的节点，极大的减少了验证的复杂度。\n\n\n\n\n公钥密码体制公钥密码体制使用*不同的加密密钥与解密密钥*，是一种“由已知加密密钥推导出解密密钥在计算上是不可行的”密码体制。\n公钥密码体制使用的密钥分为公钥和私钥，两种密钥成对使用。使用公钥加密和私钥解密；使用私钥加密和公钥解密。\n现有最著名的公钥密码体制是*RSA* 体制，它基于数论中大数分解问题，由美国三位科学家 Rivest, Shamir 和 Adleman 于 1976 年提出并在 1978 年正式发表的。\n公钥密码体制根据使用秘钥的不同，可以分为两类：发送者使用发送者的私钥处理数据，接受者使用发送者的公钥逆向处理，为签名；发送者使用接受者的公钥处理数据，接受者使用接受者的私钥处理数据，为加密。下面分别讨论这两种方式：\n\n非对称加密\n非对称密码学利用两个密钥（公共密钥和私有密钥）来加密和解密特定数据。例如：我发消息给你，用你的公钥进行加密，而你用自己的私钥进行解密，你的公钥可以公开，但是你的私钥只有自己知道.这样每个人都可以给你发信息，但只有你自己能通过私钥解密查看。\n下图为正常的加密、解密流程：\n\n两种常用的非对称加密算法：Rivest-Shamir-Adleman算法又称为RSA，椭圆曲线密码（ECC）。\n\n数字签名\n比特币本身是不加密的，那么比特币不加密怎么安全呢？\n如果我要交易，把我的比特币给你，那么我在交易上，用我的私钥进行签名，大家都可以用我的公钥进行验证，这样大家都能知道确实是我进行的交易，证明币是你的，这就涉及到了数字签名。\n如下图所示：发送者用自己的private key 处理message 和 经过hash的message digest，然后通过信道发送个接受者，接受者通过发送者的public key逆向处理消息，得到message 和 message disgest，通过验证hash(message)是否与messagedigest相等，可以验证是否是发送者发来的消息。\n\n\n\n\n总结随着互联网和公钥密码体制的发展，人们越来越关注安全和隐私，密码学在日常生活中处处可见，掌握必要的密码学知识至关重要。\nbitcoin通过一系列密码算法的组合，实现了一个分布式、点对点、可信、可验证、不可篡改的加密数字货币，比特币种的密码学知识主要有哈希，公钥密码体制，数字签名。\n\nReference[1] Wright, C. S. (2019). Bitcoin: A Peer-to-Peer Electronic Cash System. SSRN Electronic Journal, 1–9. https://doi.org/10.2139/ssrn.3440802\nFootnotes1 https://en.bitcoin.it/wiki/Wei_Dai\n2 http://zh.wikipedia.org/wiki/公开密钥加密\n欢迎关注我的微信公众号，扫描下方二维码，就可以找到我，我会持续为你分享 IT 技术和珠宝知识。\n\n也可以关注我的个人博客\n点我试试的个人博客\n","slug":"区块链中的密码学知识","date":"2021-05-27T16:00:00.000Z","categories_index":"学习","tags_index":"比特币,区块链,密码学","author_index":"明说网络"},{"id":"ba6efd3696babbc595a9e44929f12852","title":"关于RFC文档有趣的事情","content":"原文为知乎文章， 现转移到个人博客。\nTable of Contents\n事情的起源\n研究经过\n查询相关资料\n查询相关RFC\n一个想法\n第一个发现\n第二个发现\n第三个发现\n第四个发现\n\n\n\n\n总结\n\n\n事情的起源一次被问起，为何TLSv1.0(RFC2246),TLSv1.1(RFC4346),TLSv1.2(RFC5246),TLSv1.3(RFC8446)中的RFC编号都是以64结尾。印象中关于RFC编号都是递增的，因为RFC写好之后就不允许再修改了，如果有新的标准出来，只能在其后某个编号出现，并且引用之前的RFC。但是上述这个问题，TLS四个版本均以64结尾，也太凑巧了，确实很让人疑惑。本着好奇，去研究了研究这事。\n&lt;！–more–&gt;\n\n研究经过\n查询相关资料首先在网上搜索为什么TLS均以64结尾，网上的回答基本上来自如下解释\n\n\n\n\n\n\n\n\n\nIn the IETF, protocols are called RFCs. TLS 1.0 was RFC 2246, TLS 1.1 was RFC 4346, and TLS 1.2 was RFC 5246. Today, TLS 1.3 was published as RFC 8446. RFCs are generally published in order, keeping 46 as part of the RFC number is a nice touch1.\n显然，并没有解决我们的问题。\n\n查询相关RFC思考是否会有某个RFC对这事做了说明吗？查询未果。但是在此过程中，我发现了在RFC文档中，有相邻两个递增编号文档，但是RFC时间并不递增的现象。举个例子\n\n\n\n\n\n\n\n\n\n1478 An Architecture for Inter-Domain Policy Routing. M. Steenstrup. June\n\n(Format: TXT, HTML) (Status: HISTORIC) (DOI: 10.17487&#x2F;RFC1478)\n\n1479 Inter-Domain Policy Routing Protocol Specification: Version 1. M.     Steenstrup. July 1993. (Format: TXT, HTML) (Status: HISTORIC) (DOI:     10.17487&#x2F;RFC1479) \n1480 The US Domain. A. Cooper, J. Postel. June 1993. (Format: TXT, HTML)     (Obsoletes RFC1386) (Status: INFORMATIONAL) (DOI: 10.17487&#x2F;RFC1480) \n其中RFC1478的时间为1993年6月，RFC1479的时间为1993年7月，但是RFC1480的时间为1993年6月，出现了非递增的情况。\n虽然又发现，但好像并没有什么卵用。但是自然会想到，有可能时间上有大的反复吗？有年的反复现象吗？\n\n一个想法\n第一个发现所以就想分析分析RFC文档的编号的时间问题。第一想法是爬虫，但是工作量太复杂。左搜索右搜索，找到了官网提供的XML版列表2.超级开心。然后写了个python脚本，自动进行了分析(忽略并不想改的变量名，来自一个豆瓣电影爬虫)。\n#!/usr/bin/python3\nimport calendar\nfrom xml.dom.minidom import parse\nimport xml.dom.minidom\n\nimport numpy as np\nimport matplotlib.pyplot as plt \n\n# 使用minidom解析器打开 XML 文档\nDOMTree = xml.dom.minidom.parse(\"rfc-index.xml\")\ncollection = DOMTree.documentElement\nif collection.hasAttribute(\"shelf\"):\n   print (\"Root element : %s\" % collection.getAttribute(\"shelf\"))\n\n# 在集合中获取所有电影\nmovies = collection.getElementsByTagName(\"rfc-entry\")\n\n# 打印每部电影的详细信息\nprint (\"*****Movie*****\")\nx = [];\nyears = [];\nmonths = [];\ntotal = [];\nfor movie in movies:\n\n   type = movie.getElementsByTagName('doc-id')[0].childNodes[0].data\n\n   id = int(type[3:]);\n   x.append(id);\n#    print (\"doc-id: %d\" % id)\n#    author = movie.getElementsByTagName('author')[0]\n#    print (\"author: %s\" % author.childNodes[1].data)\n   date = movie.getElementsByTagName('date')[0]\n   month = date.getElementsByTagName('month')[0].childNodes[0].data;\n   int_month = int(list(calendar.month_name).index(month))\n   months.append(int_month);\n#    print (\"date month: %d\" % int_month)\n   year = int(date.getElementsByTagName('year')[0].childNodes[0].data);\n#    print (\"date year: %d\" % year)\n   years.append(year);\n#    description = movie.getElementsByTagName('description')[0]\n#    print (\"Description: %s\" % description.childNodes[0].data)\n   total.append(year + 10  + int_month  )\n\nplt.rcParams['font.sans-serif'] = ['Arial Unicode MS']\nplt.rcParams['axes.unicode_minus'] = False   # 解决保存图像是负号'-'显示为方块的问题\nplt.title(\"Matplotlib\") \nplt.xlabel(\"RFC编号\") \nplt.ylabel(\"年份\") \n\nplt.plot(x,years, label=r'年') \nplt.plot(x,total, label=r'年 + 月 + 10(向上平移10)') \n# plt.subplot(2,1,1)\n# plt.plot(x,years) \n# plt.subplot(2,1,2)\n# plt.plot(x,months) \nplt.legend();\n\nplt.grid()\nplt.show()\n\n经过经过分析有了如下所示图：果然有问题！！！！上图横坐标为RFC编号，纵坐标为RFC编号对应的年份。可以看出RFC文档从一九六几年到今天一共发表8000余份。有意思的是，其中有一些凸起的部分，就是一些异常点。例如2000年前有一个极高的凸起，这代表这个编号的年份远远超出这个编号附近的年份，这与我们的常识不符。实际上，查看这个异常点，如下图所示：其中RFC1849的年份为2010年，但其附近的RFC文档编号均为1995年，其中相差15年，造成第一幅图中的凸起。\n\n第二个发现同时，我们还会发现另一个有意思的现象。如下图所示：其中编号为1299，1399，1499，1599，1699,&amp;#x2026;等，均出现凸起现象。并且实际上1299，1399，1499，1599，1699，1799，1899，1999的年份均为1997年。存在明显的人为痕迹。\n\n第三个发现年份和月份基本满足递增，但是有波动。如下图所示：放大后：为方便对比，将其中月份显示为（年+月，再向上平移10个单位(年)）。\n\n第四个发现TLS的主要作者，目前是Eric Rescorla。对TLS四个版本作者做简单统计，如下图：可以看出，最开始Tim Dierks逐渐从第二作者，向第一作者上升，此时带了个徒弟。慢慢Tim Dierks开始退居二线，Eric Rescorla开始独挡一面（纯属胡说八道）。\n\n总结虽然并没有直接的证据来回答开头提出的问题，但是我们可以发现以下现象：\n\nRFC的编号并非严格的时间递增，而是存在一些波动\nRFC的编号中存在一些，小概率发生的现象，例如等间隔凸起\n\n基于以上现象呢，我们可以大胆猜测（hu shuo ba dao）：\n\nRFC编号的审批机构，会因为某些原因，保留一些编号\nRFC的编号其实并没有想象中的那么严格\n大佬在RFC编号中具有一定的发言权，可以”预定“一些编号。如TLSv1，2，3，4以64结尾\n\nFootnotes1 https://blog.cloudflare.com/rfc-8446-aka-tls-1-3/\n2 https://www.rfc-editor.org/rfc-index.xml\n","slug":"关于RFC文档有趣的事情","date":"2021-05-26T16:00:00.000Z","categories_index":"研究","tags_index":"RFC,编号,python","author_index":"明说网络"},{"id":"343b3a587bf8e0f8dd96b05800c8d194","title":"Linux下从汇编手撕c++值传递和引用传递","content":"Linux下从汇编手撕c++-值传递和引用传递示例程序main.c\n主要分为两个部分，每个部分使用一个display函数，函数内使得传入的参数自加1，然后打印到标准输出上。不同的地方在于，display1使用了值传递，display2使用了引用传递\n#include &lt;stdio.h&gt;\n\nvoid display1(int num)&#123; &#x2F;&#x2F;int num，属于值传递\n    num++;\n    printf(&quot;display1: %d\\n&quot;, num);\n&#125;\n\nvoid display2(int &amp; num)&#123; &#x2F;&#x2F;int &amp; num ，属于引用传递\n    num++;\n    printf(&quot;display2: %d\\n&quot;, num);\n&#125;\n\nint main()&#123;\n    int num1 &#x3D; 0, num2 &#x3D; 0;\n    display1(num1);\n    printf(&quot;num1:%d\\n&quot;, num1);\n    printf(&quot;--------------------\\n&quot;);\n    display2(num2);\n    printf(&quot;num2:%d\\n&quot;, num2);\n    return 0;\n&#125;\n\nmakefile\nOBJ&#x3D;reference\n\n$(OBJ):\n    g++ main.c -o $@\n\nclean:\n    -rm -rf $(OBJ)\n\n在ubuntu中使用make命令进行编译并运行，结果如下图所示。\n\n通过上述结果我们可以看出，虽然仅仅一个&amp;符号的差异，但通过参数传递和通过值传递获得的结果不一样。\n\n值传递中的num虽然进行了自加操作(输出display:1可以看出)，但是并没有影响到main函数中的num1（num1:0可以看出)\n\n但是引用传递中的num进行了自加1(输出display:1可以看出)，并且影响到了main函数中的num2(num2:1可以看出).\n\n\n提出问题是什么原因造成了仅仅一个&amp;符号的差异，导致函数内值传递和引用传递的差别呢？\n实验objdump -d ./reference &gt; objdump.txt\n.&#x2F;reference:     file format elf64-x86-64\n\n00000000004005d6 &lt;_Z8display1i&gt;:\n  4005d6:    55                       push   %rbp\n  4005d7:    48 89 e5                 mov    %rsp,%rbp\n  4005da:    48 83 ec 10              sub    $0x10,%rsp\n  4005de:    89 7d fc                 mov    %edi,-0x4(%rbp) #将值取出到%rbp-0x4\n  4005e1:    83 45 fc 01              addl   $0x1,-0x4(%rbp)    # +1运算\n  4005e5:    8b 45 fc                 mov    -0x4(%rbp),%eax    #写回%rbp-0x4, 仍然是局部变量，生命周期在函数内\n  4005e8:    89 c6                    mov    %eax,%esi\n  4005ea:    bf 44 07 40 00           mov    $0x400744,%edi\n  4005ef:    b8 00 00 00 00           mov    $0x0,%eax\n  4005f4:    e8 b7 fe ff ff           callq  4004b0 &lt;printf@plt&gt;\n  4005f9:    90                       nop\n  4005fa:    c9                       leaveq \n  4005fb:    c3                       retq   \n\n00000000004005fc &lt;_Z8display2Ri&gt;:\n  4005fc:    55                       push   %rbp\n  4005fd:    48 89 e5                 mov    %rsp,%rbp\n  400600:    48 83 ec 10              sub    $0x10,%rsp\n  400604:    48 89 7d f8              mov    %rdi,-0x8(%rbp)#将值取出到%rbp-0x8， 注意此时%rdi为地址\n  400608:    48 8b 45 f8              mov    -0x8(%rbp),%rax\n  40060c:    8b 00                    mov    (%rax),%eax\n  40060e:    8d 50 01                 lea    0x1(%rax),%edx  #加一\n  400611:    48 8b 45 f8              mov    -0x8(%rbp),%rax\n  400615:    89 10                    mov    %edx,(%rax) # 将结果放入原地址所指的内存当中，\n  400617:    48 8b 45 f8              mov    -0x8(%rbp),%rax\n  40061b:    8b 00                    mov    (%rax),%eax\n  40061d:    89 c6                    mov    %eax,%esi\n  40061f:    bf 52 07 40 00           mov    $0x400752,%edi\n  400624:    b8 00 00 00 00           mov    $0x0,%eax\n  400629:    e8 82 fe ff ff           callq  4004b0 &lt;printf@plt&gt;\n  40062e:    90                       nop\n  40062f:    c9                       leaveq \n  400630:    c3                       retq   \n\n0000000000400631 &lt;main&gt;:\n  400631:    55                       push   %rbp\n  400632:    48 89 e5                 mov    %rsp,%rbp\n  400635:    48 83 ec 10              sub    $0x10,%rsp\n  400639:    64 48 8b 04 25 28 00     mov    %fs:0x28,%rax\n  400640:    00 00 \n  400642:    48 89 45 f8              mov    %rax,-0x8(%rbp)\n  400646:    31 c0                    xor    %eax,%eax\n  400648:    c7 45 f4 00 00 00 00     movl   $0x0,-0xc(%rbp)\n  40064f:    c7 45 f0 00 00 00 00     movl   $0x0,-0x10(%rbp)\n  400656:    8b 45 f4                 mov    -0xc(%rbp),%eax # 将%rbp-0xc的值放入%eax，相当于复制了一份\n  400659:    89 c7                    mov    %eax,%edi\n  40065b:    e8 76 ff ff ff           callq  4005d6 &lt;_Z8display1i&gt;\n  400660:    8b 45 f4                 mov    -0xc(%rbp),%eax\n  400663:    89 c6                    mov    %eax,%esi\n  400665:    bf 60 07 40 00           mov    $0x400760,%edi\n  40066a:    b8 00 00 00 00           mov    $0x0,%eax\n  40066f:    e8 3c fe ff ff           callq  4004b0 &lt;printf@plt&gt;\n  400674:    bf 69 07 40 00           mov    $0x400769,%edi\n  400679:    e8 12 fe ff ff           callq  400490 &lt;puts@plt&gt;\n  40067e:    48 8d 45 f0              lea    -0x10(%rbp),%rax # 将%rbp-0xc的地址放入%eax，想到与对原地址进行操作\n  400682:    48 89 c7                 mov    %rax,%rdi\n  400685:    e8 72 ff ff ff           callq  4005fc &lt;_Z8display2Ri&gt;\n  40068a:    8b 45 f0                 mov    -0x10(%rbp),%eax\n  40068d:    89 c6                    mov    %eax,%esi\n  40068f:    bf 7e 07 40 00           mov    $0x40077e,%edi\n  400694:    b8 00 00 00 00           mov    $0x0,%eax\n  400699:    e8 12 fe ff ff           callq  4004b0 &lt;printf@plt&gt;\n  40069e:    b8 00 00 00 00           mov    $0x0,%eax\n  4006a3:    48 8b 55 f8              mov    -0x8(%rbp),%rdx\n  4006a7:    64 48 33 14 25 28 00     xor    %fs:0x28,%rdx\n  4006ae:    00 00 \n  4006b0:    74 05                    je     4006b7 &lt;main+0x86&gt;\n  4006b2:    e8 e9 fd ff ff           callq  4004a0 &lt;__stack_chk_fail@plt&gt;\n  4006b7:    c9                       leaveq \n  4006b8:    c3                       retq   \n  4006b9:    0f 1f 80 00 00 00 00     nopl   0x0(%rax)\n\n通过上述汇编代码（相关关键步骤已经使用注释进行了说明）。\ndisplay1(num1);\ndisplay2(num2);\n\n400656:    8b 45 f4                 mov    -0xc(%rbp),%eax # 注意mov操作！！将%rbp-0xc的值（也就是局部变量num1）放入%eax，相当于复制了一份\n400659:    89 c7                    mov    %eax,%edi\n40065b:    e8 76 ff ff ff           callq  4005d6 &lt;_Z8display1i&gt;  \n\n40067e:    48 8d 45 f0              lea    -0x10(%rbp),%rax # 注意lea 操作！！将%rbp-0xc（也就是局部变量num2）的地址放入%eax，想当于对原地址进行操作\n400682:    48 89 c7                 mov    %rax,%rdi\n400685:    e8 72 ff ff ff           callq  4005fc &lt;_Z8display2Ri&gt;\n\n可以看出：\n\n对于值传递，使用mov指令，相当于复制了一份；\n\n对于引用，使用lea指令，得到了地址，随后的操作都在地址上进行，相当于直接对该地址的数进行操作。\n\n\n因此，我们知道，虽然传递的都是传递的一个变量名，但display1使用的值传递，display2使用的是引用传递：\ndisplay1(num1);&#x2F;&#x2F;虽然进行了自加1，但是是对num1的副本进行的操作，作用范围在display函数内\ndisplay2(num2);&#x2F;&#x2F;使用引用传递，相当于指针操作，作用范围在main函数当中。\n\n\n当使用值传递时，在函数内对参数的操作，参数作用范围只在函数内，跳出函数后该是啥还是啥，在原函数(这里是main)里就是进入函数前的状态。因为值传递方式，在函数中只改变的是值的副本。\n\n在使用引用传递时，引用的本质使用的是指针。因此在函数中的操作，都会直接作用于该地址的值。\n\n\n总结通过对值传递和引用传递的汇编代码的分析，我们清晰的看出值传递本是上是传递了一个原值的副本，其变化并不影响调用函数的值；引用传递的本质是指针，其变化，直接作用于调用函数的值。\n","slug":"Linux下手撕c++-值传递和引用传递","date":"2020-08-15T10:49:36.000Z","categories_index":"编程开发","tags_index":"C语言回头看,汇编","author_index":"明说网络"},{"id":"2ff47a92226f01edf6d15cdf11e2957f","title":"消息队列学习笔记","content":"\n\n\n\n\n\n\n\n\n摘要：本文将描述消息队列，物联网MQTT协议，开源消息队列rabbitmq及实操\n故事的开头，我们从MQ（Message Queue）说起。\n什么是MQMQ,Message queue,消息队列，就是指保存消息的一个容器。\n消息队列最原始的模型：生产者先将消息投递一个叫做「队列」的容器中，然后再从这个容器中取出消息，最后再转发给消费者。如下图所示：\n\n那么问题来了，那么为什么生产者不直接将消息发送给消费者呢？好处在哪里呢？\n消息队列有什么优势呢？\n如下图所示，本身串行的订单，会员，消息，推荐系统在MQ的加持下，变成了并行，系统和系统之间只依赖于MQ，而不依赖于各类系统。\n\n\n\n\n\n\n\n\n\n\n参考：https://www.zhihu.com/question/54152397\n其实，MQ在其中起到了以缓冲的作用。\nMQ 解决的最核心的问题：系统解耦（系统之间不相互依赖）和异步（流程不再串行）：\n以上为MQ的背景，下面进入正题。\n物联网通信协议MQTT下面我们来聊一聊物联网通协议MQTT（Message Queuing Telemetry Transport，消息队列遥测传输协议）。\nMQTT简介随着 5G 时代的来临，万物互联的伟大构想正在成为现实。海量的设备接入和设备管理对网络带宽、通信协议以及平台服务架构都带来了很大挑战。尤其对于物联网设备来说，电量消耗，资源控制等都尤为重要。在此背景下MQTT应运而生。\n\nMQTT（Message Queuing Telemetry Transport，消息队列遥测传输协议），是一种基于发布&#x2F;订阅（publish&#x2F;subscribe）模式的”轻量级“通讯协议，该协议构建于TCP&#x2F;IP协议上，由IBM在1999年发布（由 IBM 的 Andy Stanford-Clark 和 Arcom 的 Arlen Nipper 为了一个通过卫星网络连接输油管道的项目开发，之后 IBM 一直将 MQTT 作为一个内部协议在其产品中使用，直到 2010 年，IBM 公开发布了 MQTT 3.1 版本。在 2014 年，MQTT 协议正式成为了 OASIS（结构化信息标准促进组织）的标准协议，来源）。\nMQTT最大优点在于，可以以极少的代码和有限的带宽，为连接远程设备提供实时可靠的消息服务。作为一种低开销、低带宽占用的即时通讯协议，使其在物联网、小型设备、移动应用等方面有较广泛的应用。MQTT 3 （当前版本3.1.1）是目前使用的最为广泛的 MQTT 协议标准。\n为什么选择MQTT它的设计思想是轻巧、开放、简单、规范，易于实现。这些特点使得它对很多场景来说都是很好的选择，特别是对于受限的环境如机器与机器的通信（M2M）以及物联网环境（IoT）。\n\nMQTT的应用场景MQTT 协议广泛应用于物联网、移动互联网、智能硬件、车联网、电力、能源等领域。\n\n\n\n\n\n\n\n\n\n\n相关参考资料 https://www.emqx.cn/mqtt https://www.runoob.com/w3cnote/mqtt-intro.html https://www.jianshu.com/p/ecde412d2eeb MQTT协议中文版，https://mcxiaoke.gitbooks.io/mqtt-cn/content/ https://zhuanlan.zhihu.com/p/158145940\nMQTT通信模型有别于传统的客户端&#x2F;服务器通讯协议，MQTT协议并不是端到端的，消息传递通过代理，包括会话（session）也不是建立在发布者和订阅者之间，而是建立在端和代理之间。代理解除了发布者和订阅者之间的耦合。这对理解MQTT很重要\n通过下面两个图理解MQTT（不愧是MQ）\n\n\n从MQ的角度去理解MQTT而MQTT是专门针对物联网设计的消息队列！实际上使用的是MQ其中的发布&#x2F;订阅模式\n\n订阅什么意思呢？举个例子，订报纸。设想一个场景：你从报亭A订阅了“人民日报”，那么一旦报亭有了”人民日报”，就会给你发一份。其实，这个“人民日报”在MQTT中就是topic的角色。\n\n\n\n\n\n\n\n\n\n如果熟悉设计模式的同学，一定会联想到观察者模式，简直是异曲同工之妙啊。 观察者模式：当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知依赖它的对象。观察者模式属于行为型模式。 观察者模式 | 菜鸟教程\nMQTT中的角色在MQTT中，有三个主要的角色：\n\n\n\n角色\n解释\n类比\n\n\n\n发布者（Publish）\n可以是一个应用程序或一台设备\n类似于报纸发布者\n\n\n代理（Broker）（服务器）\nMQTT服务器以称为”消息代理”（Broker），可以是一个应用程序或一台设备。它是位于消息发布者和订阅者之间\n类似于以前的报刊亭，会有很多人向报亭发布报纸，报停会更具不同的订阅分发报纸。\n\n\n订阅者（Subscribe）\n可以是一个应用程序或一台设备\n类似于报纸订阅者\n\n\n需要注意的是，这里的发布者和订阅者并不是绝对的。发布者可以变成订阅者，订阅者也可以变成发布者，甚至是同一台设备既可以是发布者也可以是订阅者，甚至是broker。\n这是与现实中报亭的例子有些区别的地方，人们可以订报纸，同时还能发报纸，甚至是自己给自己卖报纸！\nMQTT消息这三个角色之间通过消息进行通信：MQTT传输的消息分为：主题（Topic）和负载（payload）两部分：\n\nTopic，可以理解为消息的类型，订阅者订阅（Subscribe）后，就会收到该主题的消息内容（payload）\n\n连接到一个应用程序消息的标签，该标签与服务器的订阅相匹配。服务器会将消息发送给订阅所匹配标签的每个客户端。一个主题可以有多个级别，级别之间用斜杠字符分隔。例如，/world 和 emq/emqtt/emqx 是有效的主题。订阅者的Topic name支持通配符#和+ ：\n\n\n# 支持一个主题内任意级别话题\n+只匹配一个主题级别的通配符\n\n\npayload，可以理解为消息的内容，是指订阅者具体要使用的内容。\n\n\n**Payload消息体** CONNECT、SUBSCRIBE、SUBACK、UNSUBSCRIBE四种类型的消息 有消息体：\n\n\nCONNECT，消息体内容主要是：客户端的ClientID、订阅的Topic、Message以及用户名和密码\nSUBSCRIBE，消息体内容是一系列的要订阅的主题以及QoS。\nSUBACK，消息体内容是服务器对于SUBSCRIBE所申请的主题及QoS进行确认和回复。\nUNSUBSCRIBE，消息体内容是要订阅的主题。\n\n\n\n\n\nmosquitto使用Mosquitto是一个实现了MQTT3.1协议的代理服务器，由MQTT协议创始人之一的Andy Stanford-Clark开发\n\n\n\n\n\n\n\n\n\n学习网址：libmosquitto编程：https://blog.csdn.net/dancer__sky&#x2F;article&#x2F;details&#x2F;77855249MQTT的学习之Mosquitto安装&amp;使用MQTT服务端软件使用：https://zhuanlan.zhihu.com/p/56727359\n安全\n\n\n\n\n\n\n\n\nMQTT安全篇：为何以及如何运用MQTT提供的安全特性来保证物联网项目的顺利实施 https://zhuanlan.zhihu.com/p/21421094\n开源消息队列RabbitMQ首先来看看官网的简介：RabbitMQ is the most widely deployed open source message broker.\n\n\n\n\n\n\n\n\n\nWith tens of thousands of users, RabbitMQ is one of the most popular open source message brokers. From T-Mobile to Runtastic, RabbitMQ is used worldwide at small startups and large enterprises.RabbitMQ is lightweight and easy to deploy on premises and in the cloud. It supports multiple messaging protocols. RabbitMQ can be deployed in distributed and federated configurations to meet high-scale, high-availability requirements.RabbitMQ runs on many operating systems and cloud environments, and provides a wide range of developer tools for most popular languages.RabbitMQ拥有数万用户，是最受欢迎的开源消息代理之一。从T-Mobile到Runtastic，RabbitMQ在世界各地的小型初创公司和大型企业中都有使用。RabbitMQ轻量级，易于在本地和云中部署。它支持多种消息传递协议。RabbitMQ可以在分布式和联邦配置中部署，以满足高规模、高可用性需求。RabbitMQ运行在许多操作系统和云环境上，并为最流行的语言提供了广泛的开发工具。\n部署Rabbitmq随着容器化的浪潮来临，再也不用像以前一样Vmware，vitualbox费劲的安装虚拟机，费时费力去解决一些系统安装上的问题。小明同学最近也是恶补了一些容器方面的知识，赶上了浪潮的尾巴。\n部署rabbitmq docker非常的容易，在已经安装docker并且确保顺利运行的前提下（在确保docker正常运行，且网速可以接受的情况下）\n\n\n\n\n\n\n\n\n\n经常遇到的一个问题就是网速不行，怎么办? 配置一下国内镜像\nDocker必备六大国内镜像 - SegmentFault 思否segmentfault.com&#x2F;a&#x2F;1190000023117518\n你只用运行下列命令即可完成\ndocker run -d --hostname my-rabbit --name some-rabbit -p 15672:15672 -e RABBITMQ_DEFAULT_USER&#x3D;user -e RABBITMQ_DEFAULT_PASS&#x3D;password rabbitmq:3-management\n\n\n\n\n\n\n\n\n\n\n注意这里用了3-management这个版本，因为这个版本里面默认开启了rabbitmq_management这个插件，否则需要自己进入docker exec 启动\n这条命令完成了下述过程，\n查找本地是否有rabbitmq:3-management的image\nUnable to find image &#39;rabbitmq:3-management&#39; locally\n3-management: Pulling from library&#x2F;rabbitmq\n08c01a0ec47e: Pull complete\n1ceb23964d6c: Pull complete\n3cc5b082947a: Pull complete\n92491b691ce1: Pull complete\n8357a2e621fb: Pull complete\n05ad3a718787: Pull complete\n2fe7a6043e36: Pull complete\n67ae316617cc: Pull complete\nc5d125b106ab: Pull complete\n183ebf352080: Pull complete\nDigest: sha256:7edc83ca2e05d9550a49870eaad268e6fc8738d0806d12c1f2b8c8e9d96b51a5\nStatus: Downloaded newer image for rabbitmq:3-management\n616fb1f06a0750659a522e7012218d31823563f41f671809a3a1d57c3d53fc59\n\n通过已有image运行，这里注意暴露15672端口，用于web访问\n ~  docker run -d --hostname my-rabbit --name some-rabbit -p 15672:15672 -e RABBITMQ_DEFAULT_USER&#x3D;user -e RABBITMQ_DEFAULT_PASS&#x3D;password rabbitmq:3-management\n7de389d7c54a9b829c17b95c42b7a8d6ffb43cf1c36d6dd23baaff16ad89e5be\n ~  docker ps\nCONTAINER ID   IMAGE                   COMMAND                  CREATED         STATUS         PORTS                                                                                      NAMES\n7de389d7c54a   rabbitmq:3-management   &quot;docker-entrypoint.s…&quot;   6 seconds ago   Up 5 seconds   4369&#x2F;tcp, 5671-5672&#x2F;tcp, 15671&#x2F;tcp, 15691-15692&#x2F;tcp, 25672&#x2F;tcp, 0.0.0.0:15672-&gt;15672&#x2F;tcp   some-rabbit\n\n等上一会(或者直接查看容器的log,等到服务启动完毕）\n\nrabbitmq相关端口的说明：https://www.rabbitmq.com/networking.html#ports\n\n\n\n\n\n\n\n\n\nCLI tools, client libraries and RabbitMQ nodes also open connections (client TCP sockets). Firewalls can prevent nodes and CLI tools from communicating with each other. Make sure the following ports are accessible:\n\n4369: epmd, a peer discovery service used by RabbitMQ nodes and CLI tools\n5672, 5671: used by AMQP 0-9-1 and AMQP 1.0 clients without and with TLS\n5552, 5551: used by the RabbitMQ Stream protocol clients without and with TLS\n6000 through 6500 (usually 6000, 6001, 6002, and so on through 6005): used by RabbitMQ Stream replication\n25672: used for inter-node and CLI tools communication (Erlang distribution server port) and is allocated from a dynamic range (limited to a single port by default, computed as AMQP port + 20000). Unless external connections on these ports are really necessary (e.g. the cluster uses federation or CLI tools are used on machines outside the subnet), these ports should not be publicly exposed. See networking guide for details.\n35672-35682: used by CLI tools (Erlang distribution client ports) for communication with nodes and is allocated from a dynamic range (computed as server distribution port + 10000 through server distribution port + 10010). See networking guide for details.\n15672, 15671: HTTP API clients, management UI and rabbitmqadmin, without and with TLS (only if the management plugin is enabled)\n61613, 61614: STOMP clients without and with TLS (only if the STOMP plugin is enabled)\n1883, 8883: MQTT clients without and with TLS, if the MQTT plugin is enabled\n15674: STOMP-over-WebSockets clients (only if the Web STOMP plugin is enabled)\n15675: MQTT-over-WebSockets clients (only if the Web MQTT plugin is enabled)\n15692: Prometheus metrics (only if the Prometheus plugin is enabled)\n\nPython实操其实，不管什么指南文档，都没有官方的文档清晰透彻。\nhttps://www.rabbitmq.com/getstarted.htmlwww.rabbitmq.com/getstarted.html\n有这样，还有那样，非常的清晰。\n\n\n示例代码这个给出第一个Hello world的例子\ngithub：https://github.com/rabbitmq/rabbitmq-tutorials\n关于代码中用户名密码的问题看这：https://pika.readthedocs.io/en/stable/modules/parameters.html\n发送：\npython3 send.py\n [x] Sent &#39;Hello World!&#39;\n\n\n可以通过web界面看到，我们发送了一个消息\n接收\npython3 receive.py\n [*] Waiting for messages. To exit press CTRL+C\n [x] Received &#39;Hello World!&#39;\n\n\n通过web界面看到，处理了一个消息\n","slug":"消息队列学习笔记","date":"2020-08-15T10:49:36.000Z","categories_index":"学习笔记","tags_index":"物联网,协议,消息队列","author_index":"明说网络"}]