{"title":"从hello world开始，拆解函数栈结构","uid":"422918ab17fac2b9611905dfbc28c6cc","slug":"从hello world开始，拆解函数栈结构","date":"2022-02-26T04:40:06.928Z","updated":"2022-02-26T05:20:58.557Z","comments":true,"path":"api/articles/从hello world开始，拆解函数栈结构.json","cover":[],"content":"<h1 id=\"从hello-world开始，拆解函数栈结构\"><a href=\"#从hello-world开始，拆解函数栈结构\" class=\"headerlink\" title=\"从hello world开始，拆解函数栈结构\"></a>从hello world开始，拆解函数栈结构</h1><h2 id=\"第一个程序helloworld\"><a href=\"#第一个程序helloworld\" class=\"headerlink\" title=\"第一个程序helloworld\"></a>第一个程序helloworld</h2><h3 id=\"编写程序\"><a href=\"#编写程序\" class=\"headerlink\" title=\"编写程序\"></a>编写程序</h3><p>首先我们有如下程序：<code>main.c</code></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token comment\">//main.c</span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;stdio.h></span></span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">test_stack</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n\t<span class=\"token keyword\">char</span> name<span class=\"token punctuation\">[</span><span class=\"token number\">25</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token number\">0</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">scanf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%s\"</span><span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">puts</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n\t<span class=\"token function\">test_stack</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>上述程序实现的功能很简单，就是从<code>scanf</code>输入一个字符串，赋值到<code>name</code>，并且通过<code>puts</code>打印。</p>\n<p>是不是很简单！</p>\n<h3 id=\"程序编译makefile\"><a href=\"#程序编译makefile\" class=\"headerlink\" title=\"程序编译makefile\"></a>程序编译makefile</h3><p>为了便于说明，我们使用makefile文件进行编译。创建文件名为<code>makefile</code>的文件，内容如下：</p>\n<pre class=\"line-numbers language-makefile\" data-language=\"makefile\"><code class=\"language-makefile\"><span class=\"token comment\"># makefile</span>\nOBJ<span class=\"token operator\">=</span>stack\n\n<span class=\"token symbol\"><span class=\"token variable\">$</span>(OBJ)</span><span class=\"token punctuation\">:</span>\n\tgcc main.c -o <span class=\"token variable\">$@</span>\n\n<span class=\"token symbol\">clean</span><span class=\"token punctuation\">:</span>\n\t-rm -rf <span class=\"token variable\">$</span><span class=\"token punctuation\">(</span>OBJ<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>我们生成的文件名为<code>stack</code>，这里你可以改为你喜欢的任意名称。</p>\n<p>使用<code>make</code>命令进行编译，会生成最终文件。运行后就可以看见输出。</p>\n<h2 id=\"提出问题\"><a href=\"#提出问题\" class=\"headerlink\" title=\"提出问题\"></a>提出问题</h2><p>C语言中函数栈是如何组织的呢？都有哪些元素呢？</p>\n<h2 id=\"分析问题\"><a href=\"#分析问题\" class=\"headerlink\" title=\"分析问题\"></a>分析问题</h2><p>首先，我们通过汇编代码，理解上述C语言代码，我们能更加清晰的看出一个<code>test_stack</code>函数到底干了什么。相关内容我们在其后直接进行了注释。</p>\n<pre class=\"line-numbers language-asm\" data-language=\"asm\"><code class=\"language-asm\"># objdump -d .&#x2F;stack\n.&#x2F;stack:     file format elf64-x86-64\n\n00000000004005f6 &lt;test_stack&gt;:\n  4005f6:\t55                   \tpush   %rbp\n  4005f7:\t48 89 e5             \tmov    %rsp,%rbp\n  4005fa:\t48 83 ec 30          \tsub    $0x30,%rsp #栈上开辟了0x30&#x3D;48的空间，注意我们的局部变量只需要25的空间\n  4005fe:\t64 48 8b 04 25 28 00 \tmov    %fs:0x28,%rax # 从%fs:0x28取了一个值，放在了栈底之上，这就是canary，一种栈溢出的保护措施\n  400605:\t00 00 \n  400607:\t48 89 45 f8          \tmov    %rax,-0x8(%rbp)\n  40060b:\t31 c0                \txor    %eax,%eax\n  40060d:\t48 c7 45 d0 00 00 00 \tmovq   $0x0,-0x30(%rbp) #char name[25] &#x3D; &#123;0&#125;;\n  400614:\t00 \n  400615:\t48 c7 45 d8 00 00 00 \tmovq   $0x0,-0x28(%rbp)\n  40061c:\t00 \n  40061d:\t48 c7 45 e0 00 00 00 \tmovq   $0x0,-0x20(%rbp)\n  400624:\t00 \n  400625:\tc6 45 e8 00          \tmovb   $0x0,-0x18(%rbp)\n  400629:\t48 8d 45 d0          \tlea    -0x30(%rbp),%rax\n  40062d:\t48 89 c6             \tmov    %rax,%rsi\n  400630:\tbf 04 07 40 00       \tmov    $0x400704,%edi #’%s&#39;\n  400635:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  40063a:\te8 a1 fe ff ff       \tcallq  4004e0 &lt;__isoc99_scanf@plt&gt;\n  40063f:\t48 8d 45 d0          \tlea    -0x30(%rbp),%rax\n  400643:\t48 89 c7             \tmov    %rax,%rdi\n  400646:\te8 65 fe ff ff       \tcallq  4004b0 &lt;puts@plt&gt;\n  40064b:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  400650:\t48 8b 55 f8          \tmov    -0x8(%rbp),%rdx\n  400654:\t64 48 33 14 25 28 00 \txor    %fs:0x28,%rdx #检查canary\n  40065b:\t00 00 \n  40065d:\t74 05                \tje     400664 &lt;test_stack+0x6e&gt;\n  40065f:\te8 5c fe ff ff       \tcallq  4004c0 &lt;__stack_chk_fail@plt&gt;\n  400664:\tc9                   \tleaveq \n  400665:\tc3                   \tretq   \n\n0000000000400666 &lt;main&gt;:\n  400666:\t55                   \tpush   %rbp\n  400667:\t48 89 e5             \tmov    %rsp,%rbp\n  40066a:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  40066f:\te8 82 ff ff ff       \tcallq  4005f6 &lt;test_stack&gt;\n  400674:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  400679:\t5d                   \tpop    %rbp\n  40067a:\tc3                   \tretq   \n  40067b:\t0f 1f 44 00 00       \tnopl   0x0(%rax,%rax,1)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>主要进行了以下操作：</p>\n<ul>\n<li><strong>callq操作。</strong>我们需要注意一个隐含操作，就是上述第40行<code>callq  4005f6 &lt;test_stack&gt;</code>,这个操作隐含将下一条指令地址压栈，即0x400674</li>\n<li><strong>开辟栈空间。</strong>开辟了大小为48的栈空间，这里注意，我们的局部变量name只需要25大小的空间</li>\n<li><strong>canary值。</strong>从%fs:0x28取了一个值，放在了栈底之上，这就是canary，一种栈溢出的保护措施，最后对其检查</li>\n<li><strong>初试化操作。</strong>使用3个<code>movq</code>和1个<code>movb</code>对name变量进行了初始化。name变量的起始地址为<code>$rbp-0x30$</code>即<code>$rsp$</code>栈顶</li>\n<li><strong>赋值。</strong>使用<code>scanf</code>函数，对name变量进行了赋值</li>\n</ul>\n<p>其中，初始化，赋值通过汇编代码都很容易看出。下面我们通过gdb主要来看看栈结构吧。</p>\n<h2 id=\"实验\"><a href=\"#实验\" class=\"headerlink\" title=\"实验\"></a>实验</h2><p>使用gdb+pwngdb插件进行解释，如不清楚，可私信我或加我公众号。</p>\n<h3 id=\"callq操作\"><a href=\"#callq操作\" class=\"headerlink\" title=\"callq操作\"></a>callq操作</h3><p>![image-20210721000901757](从hello world开始，拆解函数栈结构&#x2F;image-20210721000901757.png)</p>\n<p>在进行callq操作之前，rbp和rsp为同一地址，说明栈空间大小为0.</p>\n<p>![image-20210721001254187](从hello world开始，拆解函数栈结构&#x2F;image-20210721001254187.png)</p>\n<p>注意箭头部分，当我们进入<code>test_stack</code>函数时，callq操作，进行了隐含操作，callq的下一条指令地址压栈，在这里我们可以看出，其内容为<code>0x400674</code>，与我们静态分析汇编代码一致。验证了callq操作对栈的影响。</p>\n<h3 id=\"开辟栈空间\"><a href=\"#开辟栈空间\" class=\"headerlink\" title=\"开辟栈空间\"></a>开辟栈空间</h3><p>此操作中，注意rsp和rbp的变化。</p>\n<ul>\n<li>push指令，将栈底压栈。</li>\n</ul>\n<p>![image-20210721001715969](从hello world开始，拆解函数栈结构&#x2F;image-20210721001715969.png)</p>\n<ul>\n<li>将栈底和栈顶地址设为相同（可通过栈底的上一条内容01：0008，恢复上一个栈底）。</li>\n</ul>\n<p>![image-20210721001827503](从hello world开始，拆解函数栈结构&#x2F;image-20210721001827503.png)</p>\n<ul>\n<li>开辟栈空间，大小为0x30&#x3D;48。</li>\n</ul>\n<p>![image-20210721002102212](从hello world开始，拆解函数栈结构&#x2F;image-20210721002102212.png)</p>\n<p>红框中<code>[00:0000-06:0030)</code>之间，为当前<code>test_stack</code>栈帧中的结构，大小为0x30&#x3D;48字节。中间的数据为一些初始化函数执行过程中残留的栈数据，暂时不用管它。(s + buffer + canary)</p>\n<p>rbp为test_stack函数的第一个push rbp的操作压入的栈底（saved ebp)</p>\n<p>07:0038为test_stack函数执行完毕后的返回地址。(return address)</p>\n<p>示意图如下：</p>\n<p><img src=\"https://manybutfinite.com/img/stack/bufferCanary.png\" alt=\"See the source image\"></p>\n<h3 id=\"canary值\"><a href=\"#canary值\" class=\"headerlink\" title=\"canary值\"></a>canary值</h3><p>如下图，我们继续执行两步，该函数在<code>fs:[0x28]</code>处取了一个值，然后放入了rbp-8的位置，即图中画线的位置，值为：0x92cb97cb6f51ae00，这个数就是我们所谓的canary，金丝雀。主要用来检测栈溢出。</p>\n<p>![image-20210721003510355](从hello world开始，拆解函数栈结构&#x2F;image-20210721003510355.png)</p>\n<p>然后我们查看栈顶开始的48个字节，即栈的内容</p>\n<p>![image-20210721004153415](从hello world开始，拆解函数栈结构&#x2F;image-20210721004153415.png)</p>\n<p>s: 0x7fffffffddd0:    （0x00000000    0x00000000    0x00000000    0x00000000<br>0x7fffffffdde0:    0x00000000    0x00000000    0x00）s表示我们局部变量填充的空间         </p>\n<p>buffer: (000000    0x00000000<br>0x7fffffffddf0:    0x00400680    0x00000000)buffer    代表补齐8字节所占用的空间</p>\n<p>canary: (0x6f51ae00    0x92cb97cb)canary 代表栈溢出检测指标。</p>\n<p><img src=\"https://manybutfinite.com/img/stack/bufferCanary.png\" alt=\"See the source image\"></p>\n<p>通过IDA pro验证我们的想法：</p>\n<p>![image-20210721010044515](从hello world开始，拆解函数栈结构&#x2F;image-20210721010044515.png)</p>\n<h2 id=\"缓冲区溢出分析\"><a href=\"#缓冲区溢出分析\" class=\"headerlink\" title=\"缓冲区溢出分析\"></a>缓冲区溢出分析</h2><p>实际上我们花了大量的篇幅去讲栈的结构，其实目的就是这么一张图</p>\n<p><img src=\"https://manybutfinite.com/img/stack/bufferCanary.png\" alt=\"See the source image\"></p>\n<p>栈溢出其实就是使得字符串长度达到return address的位置，使得在函数执行完毕retn时，return address的地址弹出给rip寄存器，从而使得CPU按照rip寄存的内容执行下一条指令。这里面要非常清楚的就是栈的结构，栈空间的计算真正要做到”一字不差“！</p>\n<p>当然了，这里的canary对栈进行了保护，是一个随机生成的数。当然还有很多办法来绕过甚至是猜出canary，实现栈溢出，这不在本篇文章的范畴之内，留给下一次机会吧。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>对通过一个最简单的程序对栈的结构进行了静态和动态的分析，得出了一张刻画栈帧空间的图。对于栈的计算要十分的仔细，这样在pwn题中才能做到心中有数，一招制敌。</p>\n","text":"从hello world开始，拆解函数栈结构第一个程序helloworld编写程序首先我们有如下程序：main.c //main.c #include&lt;stdio.h> int test_stack()&#123; char name[25] = &#123;0&#125;...","link":"","photos":[],"count_time":{"symbolsCount":"5k","symbolsTime":"5 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BB%8Ehello-world%E5%BC%80%E5%A7%8B%EF%BC%8C%E6%8B%86%E8%A7%A3%E5%87%BD%E6%95%B0%E6%A0%88%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">从hello world开始，拆解函数栈结构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8Fhelloworld\"><span class=\"toc-text\">第一个程序helloworld</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BC%96%E5%86%99%E7%A8%8B%E5%BA%8F\"><span class=\"toc-text\">编写程序</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91makefile\"><span class=\"toc-text\">程序编译makefile</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8F%90%E5%87%BA%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">提出问题</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%86%E6%9E%90%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">分析问题</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E9%AA%8C\"><span class=\"toc-text\">实验</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#callq%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">callq操作</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BC%80%E8%BE%9F%E6%A0%88%E7%A9%BA%E9%97%B4\"><span class=\"toc-text\">开辟栈空间</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#canary%E5%80%BC\"><span class=\"toc-text\">canary值</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90\"><span class=\"toc-text\">缓冲区溢出分析</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol></li></ol>","author":{"name":"明说网络","slug":"明说网络","avatar":"https://pic3.zhimg.com/v2-7803c8223e2c425aea4fc530975ee5f2_xl.jpg","link":"https://github.com/dianwoshshi","description":"A Jewllery Lover.","socials":{"github":"https://github.com/dianwoshshi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"从hello world开始，拆解函数栈结构","uid":"422918ab17fac2b9611905dfbc28c6cc","slug":"从hello world开始，拆解字符串常量的存储位置","date":"2022-02-26T04:40:06.930Z","updated":"2022-02-26T05:35:01.072Z","comments":true,"path":"api/articles/从hello world开始，拆解字符串常量的存储位置.json","cover":null,"text":"从hello world开始，拆解字符串常量的存储位置第一个程序helloworld编写程序首先我们有如下程序：main.c //main.c #include &lt;stdio.h> int display(char *name)&#123; printf(\"hello wo...","link":"","photos":[],"count_time":{"symbolsCount":"6.4k","symbolsTime":"6 mins."},"categories":[],"tags":[],"author":{"name":"明说网络","slug":"明说网络","avatar":"https://pic3.zhimg.com/v2-7803c8223e2c425aea4fc530975ee5f2_xl.jpg","link":"https://github.com/dianwoshshi","description":"A Jewllery Lover.","socials":{"github":"https://github.com/dianwoshshi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"“黑客”组织仍在积极重新调整其恶意软件库","uid":"cca119383a62ab6c2d67564c0f149f86","slug":"“黑客”组织仍在积极重新调整其恶意软件库","date":"2022-02-26T04:40:06.568Z","updated":"2022-02-26T04:40:06.571Z","comments":true,"path":"api/articles/“黑客”组织仍在积极重新调整其恶意软件库.json","cover":[],"text":"“黑客”组织仍在积极重新调整其恶意软件库 摘要臭名昭著的TrickBot恶意软件与一种名为Diavol的新勒索软件有关联。 正文根据Fortinet的FortiGuard实验室的研究人员，本月初针对其一个客户的攻击中，Diavol和Conti勒索软件的有效载荷(payloads)...","link":"","photos":[],"count_time":{"symbolsCount":664,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"明说网络","slug":"明说网络","avatar":"https://pic3.zhimg.com/v2-7803c8223e2c425aea4fc530975ee5f2_xl.jpg","link":"https://github.com/dianwoshshi","description":"A Jewllery Lover.","socials":{"github":"https://github.com/dianwoshshi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}