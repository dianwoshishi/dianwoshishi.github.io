{"title":"Linux下从汇编手撕c++-值传递和引用传递e","uid":"b6bf4c7e3900b8748512b429df38f3f6","slug":"Linux下手撕c++-值传递和引用传递","date":"2020-08-15T10:49:36.000Z","updated":"2022-02-26T04:40:06.491Z","comments":true,"path":"api/articles/Linux下手撕c++-值传递和引用传递.json","cover":[],"content":"<h1 id=\"Linux下从汇编手撕c-值传递和引用传递\"><a href=\"#Linux下从汇编手撕c-值传递和引用传递\" class=\"headerlink\" title=\"Linux下从汇编手撕c++-值传递和引用传递\"></a>Linux下从汇编手撕c++-值传递和引用传递</h1><h2 id=\"示例程序\"><a href=\"#示例程序\" class=\"headerlink\" title=\"示例程序\"></a>示例程序</h2><p><code>main.c</code></p>\n<p>主要分为两个部分，每个部分使用一个display函数，函数内使得传入的参数自加1，然后打印到标准输出上。不同的地方在于，display1使用了值传递，display2使用了引用传递</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;stdio.h&gt;\n\nvoid display1(int num)&#123; &#x2F;&#x2F;int num，属于值传递\n\tnum++;\n\tprintf(&quot;display1: %d\\n&quot;, num);\n&#125;\n\nvoid display2(int &amp; num)&#123; &#x2F;&#x2F;int &amp; num ，属于引用传递\n\tnum++;\n\tprintf(&quot;display2: %d\\n&quot;, num);\n&#125;\n\nint main()&#123;\n\tint num1 &#x3D; 0, num2 &#x3D; 0;\n\tdisplay1(num1);\n\tprintf(&quot;num1:%d\\n&quot;, num1);\n\tprintf(&quot;--------------------\\n&quot;);\n\tdisplay2(num2);\n\tprintf(&quot;num2:%d\\n&quot;, num2);\n\treturn 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><code>makefile</code></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">OBJ&#x3D;reference\n\n$(OBJ):\n\tg++ main.c -o $@\n\nclean:\n\t-rm -rf $(OBJ)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>在ubuntu中使用<code>make</code>命令进行编译并运行，结果如下图所示。</p>\n<p><img src=\"/post/Linux%E4%B8%8B%E6%89%8B%E6%92%95c++-%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/image-20210724002053895.png\" alt=\"image-20210724002053895\"></p>\n<p>通过上述结果我们可以看出，虽然仅仅一个<code>&amp;</code>符号的差异，但通过参数传递和通过值传递获得的<strong>结果不一样</strong>。</p>\n<ul>\n<li><p>值传递中的num虽然进行了自加操作(输出display:1可以看出)，但是<strong>并没有影响</strong>到main函数中的num1（num1:0可以看出)</p>\n</li>\n<li><p>但是引用传递中的num进行了自加1(输出display:1可以看出)，并且<strong>影响到</strong>了main函数中的num2(num2:1可以看出).</p>\n</li>\n</ul>\n<h2 id=\"提出问题\"><a href=\"#提出问题\" class=\"headerlink\" title=\"提出问题\"></a>提出问题</h2><p>是什么原因造成了仅仅一个<code>&amp;</code>符号的差异，导致函数内值传递和引用传递的差别呢？</p>\n<h2 id=\"实验\"><a href=\"#实验\" class=\"headerlink\" title=\"实验\"></a>实验</h2><p><code>objdump -d ./reference &gt; objdump.txt</code></p>\n<pre class=\"line-numbers language-asm\" data-language=\"asm\"><code class=\"language-asm\">\n.&#x2F;reference:     file format elf64-x86-64\n\n00000000004005d6 &lt;_Z8display1i&gt;:\n  4005d6:\t55                   \tpush   %rbp\n  4005d7:\t48 89 e5             \tmov    %rsp,%rbp\n  4005da:\t48 83 ec 10          \tsub    $0x10,%rsp\n  4005de:\t89 7d fc             \tmov    %edi,-0x4(%rbp) #将值取出到%rbp-0x4\n  4005e1:\t83 45 fc 01          \taddl   $0x1,-0x4(%rbp)\t# +1运算\n  4005e5:\t8b 45 fc             \tmov    -0x4(%rbp),%eax\t#写回%rbp-0x4, 仍然是局部变量，生命周期在函数内\n  4005e8:\t89 c6                \tmov    %eax,%esi\n  4005ea:\tbf 44 07 40 00       \tmov    $0x400744,%edi\n  4005ef:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  4005f4:\te8 b7 fe ff ff       \tcallq  4004b0 &lt;printf@plt&gt;\n  4005f9:\t90                   \tnop\n  4005fa:\tc9                   \tleaveq \n  4005fb:\tc3                   \tretq   \n\n00000000004005fc &lt;_Z8display2Ri&gt;:\n  4005fc:\t55                   \tpush   %rbp\n  4005fd:\t48 89 e5             \tmov    %rsp,%rbp\n  400600:\t48 83 ec 10          \tsub    $0x10,%rsp\n  400604:\t48 89 7d f8          \tmov    %rdi,-0x8(%rbp)#将值取出到%rbp-0x8， 注意此时%rdi为地址\n  400608:\t48 8b 45 f8          \tmov    -0x8(%rbp),%rax\n  40060c:\t8b 00                \tmov    (%rax),%eax\n  40060e:\t8d 50 01             \tlea    0x1(%rax),%edx  #加一\n  400611:\t48 8b 45 f8          \tmov    -0x8(%rbp),%rax\n  400615:\t89 10                \tmov    %edx,(%rax) # 将结果放入原地址所指的内存当中，\n  400617:\t48 8b 45 f8          \tmov    -0x8(%rbp),%rax\n  40061b:\t8b 00                \tmov    (%rax),%eax\n  40061d:\t89 c6                \tmov    %eax,%esi\n  40061f:\tbf 52 07 40 00       \tmov    $0x400752,%edi\n  400624:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  400629:\te8 82 fe ff ff       \tcallq  4004b0 &lt;printf@plt&gt;\n  40062e:\t90                   \tnop\n  40062f:\tc9                   \tleaveq \n  400630:\tc3                   \tretq   \n\n0000000000400631 &lt;main&gt;:\n  400631:\t55                   \tpush   %rbp\n  400632:\t48 89 e5             \tmov    %rsp,%rbp\n  400635:\t48 83 ec 10          \tsub    $0x10,%rsp\n  400639:\t64 48 8b 04 25 28 00 \tmov    %fs:0x28,%rax\n  400640:\t00 00 \n  400642:\t48 89 45 f8          \tmov    %rax,-0x8(%rbp)\n  400646:\t31 c0                \txor    %eax,%eax\n  400648:\tc7 45 f4 00 00 00 00 \tmovl   $0x0,-0xc(%rbp)\n  40064f:\tc7 45 f0 00 00 00 00 \tmovl   $0x0,-0x10(%rbp)\n  400656:\t8b 45 f4             \tmov    -0xc(%rbp),%eax # 将%rbp-0xc的值放入%eax，相当于复制了一份\n  400659:\t89 c7                \tmov    %eax,%edi\n  40065b:\te8 76 ff ff ff       \tcallq  4005d6 &lt;_Z8display1i&gt;\n  400660:\t8b 45 f4             \tmov    -0xc(%rbp),%eax\n  400663:\t89 c6                \tmov    %eax,%esi\n  400665:\tbf 60 07 40 00       \tmov    $0x400760,%edi\n  40066a:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  40066f:\te8 3c fe ff ff       \tcallq  4004b0 &lt;printf@plt&gt;\n  400674:\tbf 69 07 40 00       \tmov    $0x400769,%edi\n  400679:\te8 12 fe ff ff       \tcallq  400490 &lt;puts@plt&gt;\n  40067e:\t48 8d 45 f0          \tlea    -0x10(%rbp),%rax # 将%rbp-0xc的地址放入%eax，想到与对原地址进行操作\n  400682:\t48 89 c7             \tmov    %rax,%rdi\n  400685:\te8 72 ff ff ff       \tcallq  4005fc &lt;_Z8display2Ri&gt;\n  40068a:\t8b 45 f0             \tmov    -0x10(%rbp),%eax\n  40068d:\t89 c6                \tmov    %eax,%esi\n  40068f:\tbf 7e 07 40 00       \tmov    $0x40077e,%edi\n  400694:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  400699:\te8 12 fe ff ff       \tcallq  4004b0 &lt;printf@plt&gt;\n  40069e:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  4006a3:\t48 8b 55 f8          \tmov    -0x8(%rbp),%rdx\n  4006a7:\t64 48 33 14 25 28 00 \txor    %fs:0x28,%rdx\n  4006ae:\t00 00 \n  4006b0:\t74 05                \tje     4006b7 &lt;main+0x86&gt;\n  4006b2:\te8 e9 fd ff ff       \tcallq  4004a0 &lt;__stack_chk_fail@plt&gt;\n  4006b7:\tc9                   \tleaveq \n  4006b8:\tc3                   \tretq   \n  4006b9:\t0f 1f 80 00 00 00 00 \tnopl   0x0(%rax)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>通过上述汇编代码（相关关键步骤已经使用注释进行了说明）。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">display1(num1);\ndisplay2(num2);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-asm\" data-language=\"asm\"><code class=\"language-asm\">400656:\t8b 45 f4             \tmov    -0xc(%rbp),%eax # 注意mov操作！！将%rbp-0xc的值（也就是局部变量num1）放入%eax，相当于复制了一份\n400659:\t89 c7                \tmov    %eax,%edi\n40065b:\te8 76 ff ff ff       \tcallq  4005d6 &lt;_Z8display1i&gt;  \n\n40067e:\t48 8d 45 f0          \tlea    -0x10(%rbp),%rax # 注意lea 操作！！将%rbp-0xc（也就是局部变量num2）的地址放入%eax，想当于对原地址进行操作\n400682:\t48 89 c7             \tmov    %rax,%rdi\n400685:\te8 72 ff ff ff       \tcallq  4005fc &lt;_Z8display2Ri&gt;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>可以看出：</p>\n<ul>\n<li><p>对于值传递，使用<code>mov</code>指令，相当于<strong>复制</strong>了一份；</p>\n</li>\n<li><p>对于引用，使用<code>lea</code>指令，得到了地址，随后的操作都在<strong>地址上</strong>进行，相当于直接对该地址的数进行操作。</p>\n</li>\n</ul>\n<p>因此，我们知道，虽然传递的都是传递的一个变量名，但display1使用的值传递，display2使用的是引用传递：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">display1(num1);&#x2F;&#x2F;虽然进行了自加1，但是是对num1的副本进行的操作，作用范围在display函数内\ndisplay2(num2);&#x2F;&#x2F;使用引用传递，相当于指针操作，作用范围在main函数当中。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<ul>\n<li><p>当使用值传递时，在函数内对参数的操作，参数作用范围只在函数内，跳出函数后该是啥还是啥，在原函数(这里是main)里就是进入函数前的状态。因为值传递方式，在函数中只改变的是值的副本。</p>\n</li>\n<li><p>在使用引用传递时，引用的本质使用的是指针。因此在函数中的操作，都会直接作用于该地址的值。</p>\n</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过对值传递和引用传递的汇编代码的分析，我们清晰的看出值传递本是上是传递了一个原值的副本，其变化并不影响调用函数的值；引用传递的本质是指针，其变化，直接作用于调用函数的值。</p>\n","text":"Linux下从汇编手撕c++-值传递和引用传递示例程序main.c 主要分为两个部分，每个部分使用一个display函数，函数内使得传入的参数自加1，然后打印到标准输出上。不同的地方在于，display1使用了值传递，display2使用了引用传递 #include &lt;st...","link":"","photos":[],"count_time":{"symbolsCount":"5.8k","symbolsTime":"5 mins."},"categories":[{"name":"开发","slug":"开发","count":3,"path":"api/categories/开发.json"},{"name":"编程","slug":"开发/编程","count":1,"path":"api/categories/开发/编程.json"}],"tags":[{"name":"C语言回头看","slug":"C语言回头看","count":1,"path":"api/tags/C语言回头看.json"},{"name":"汇编","slug":"汇编","count":1,"path":"api/tags/汇编.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Linux%E4%B8%8B%E4%BB%8E%E6%B1%87%E7%BC%96%E6%89%8B%E6%92%95c-%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92\"><span class=\"toc-text\">Linux下从汇编手撕c++-值传递和引用传递</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F\"><span class=\"toc-text\">示例程序</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8F%90%E5%87%BA%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">提出问题</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E9%AA%8C\"><span class=\"toc-text\">实验</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol></li></ol>","author":{"name":"明说网络","slug":"blog-author","avatar":"https://pic3.zhimg.com/v2-7803c8223e2c425aea4fc530975ee5f2_xl.jpg","link":"/","description":"和你去看网络空间","socials":{"github":"https://github.com/dianwoshishi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2119505607","zhihu":"https://www.zhihu.com/people/dianwoshishi","csdn":"https://blog.csdn.net/wanglihongwm","juejin":"","customs":{"bilibili":{"icon":"http://localhost:4000/svg/bilibili.svg","link":"https://space.bilibili.com/432126410"}}}},"mapped":true,"prev_post":{"title":"关于RFC文档有趣的事情","uid":"ba6efd3696babbc595a9e44929f12852","slug":"关于RFC文档有趣的事情","date":"2021-05-26T16:00:00.000Z","updated":"2022-02-26T04:40:07.062Z","comments":true,"path":"api/articles/关于RFC文档有趣的事情.json","cover":[],"text":"原文为知乎文章， 现转移到个人博客。 Table of Contents 事情的起源 研究经过 查询相关资料 查询相关RFC 一个想法 第一个发现 第二个发现 第三个发现 第四个发现 总结 事情的起源一次被问起，为何TLSv1.0(RFC2246),TLSv1.1(RFC4346...","link":"","photos":[],"count_time":{"symbolsCount":"4.1k","symbolsTime":"4 mins."},"categories":[{"name":"研究","slug":"研究","count":1,"path":"api/categories/研究.json"}],"tags":[{"name":"RFC","slug":"RFC","count":1,"path":"api/tags/RFC.json"},{"name":"编号","slug":"编号","count":1,"path":"api/tags/编号.json"},{"name":"python","slug":"python","count":1,"path":"api/tags/python.json"}],"author":{"name":"明说网络","slug":"blog-author","avatar":"https://pic3.zhimg.com/v2-7803c8223e2c425aea4fc530975ee5f2_xl.jpg","link":"/","description":"和你去看网络空间","socials":{"github":"https://github.com/dianwoshishi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2119505607","zhihu":"https://www.zhihu.com/people/dianwoshishi","csdn":"https://blog.csdn.net/wanglihongwm","juejin":"","customs":{"bilibili":{"icon":"http://localhost:4000/svg/bilibili.svg","link":"https://space.bilibili.com/432126410"}}}}},"next_post":{}}